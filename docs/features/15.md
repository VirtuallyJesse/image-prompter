### TASK

Perchance Page Enhancements - Full metadata saving for EXIF to match our other services, and auto-download of images

## TASK DETAILS

Your task is a bit unique. Through a grueling debug session, success for the task has already been achieved. However it's left the solution files in a messy state filled with debug logging and possible dead/unused code (not sure, analysis for this is part of your task).

You will be provided below the AGENT SUMMARY, which contains a brief summary of events, the SOLUTION CONTEXT, which contains the working solution files and associated debug log, and the CONTEXT, which contains the current production files.

As part of your task, you are to not only strip out the debug, but also enhance the manual download handler to properly embed the full metadata exif as the auto-downloader does. This will be a new addition not present in the solution files. And yes, it's fine if the user manually saves a file that was already auto-downloaded.

Look for refactoring enhancement possibilities and perform cleanup for the perchance service and page final revisions.

### PROJECT 

Image Assistant is a PyQt6 desktop application that transforms user concepts into optimized image generation prompts via AI services (Gemini, NVIDIA NIM), with integrated text-to-image synthesis through Pollinations, Airforce, and Perchance APIs.

### DELIVERABLES

Please produce the final `perchance_service.py` and `perchance_page.py` files in full rewrites. You may omit `config.py` and `gallery_service.py`.

### AGENT SUMMARY

```markdown
Here is a detailed summary of our session, breaking down the initial challenge, how we arrived at the final solution, and the critical lessons learned along the way.

### 1. The Task Presented
You brought forward a three-part enhancement request for the application's Perchance integration:
*   **UI Cleanup**: A newly introduced navigation menu bar (`#menuBarEl`) was taking up screen space and needed to be forcefully hidden without breaking page functionality.
*   **Metadata Extraction**: You noted that Perchance displays rich generation metadata (prompt, negative prompt, seed, guidance scale) when hovering over images, but our existing app couldn't capture it. We needed a way to extract this data and embed it into the downloaded images' EXIF tags.
*   **True Auto-Download**: The existing "auto-download" for Perchance was actually just hooking into a manual user action (clicking a "heart" icon, then clicking "save to your device"). The goal was to fully automate this, silently saving images to disk the moment they finished generating.

### 2. The Final Solution
To solve this, we implemented a hybrid JavaScript-to-Python pipeline:

*   **Menu Bar Hiding**: We added `#menuBarEl` and its minimal-mode counterpart (`#minimalModeMenuBtn`) to our CSS-injection list. We also explicitly set `--menu-bar-height: 0px` to ensure no invisible layout gaps remained.
*   **The PostMessage Interception (Auto-Download & Metadata)**: 
    *   Instead of waiting for user interaction, we injected a permanent JavaScript payload into the browser engine.
    *   This script listens for the internal `postMessage` events that Perchance's underlying generators use to pass base64 image data back to the UI.
    *   Simultaneously, the script locates the specific `<iframe src="...#%7B%22prompt...">` that generated the image. We discovered Perchance encodes all metadata (prompts, seeds, resolution) directly into the URL hash of these iframes. 
    *   The script decodes this hash, pairs it with the base64 image data, and forwards it to the top-level window.
*   **Python Polling**: The top-level window stores these completed images in a JavaScript array (`window._perchanceImageQueue`). Our Python backend uses a `QTimer` to poll this array every 1 second. When it finds images, it pulls them across the bridge, decodes the base64 data, uses `PIL` to embed the comprehensive EXIF metadata, and saves them directly to the `images/` directory.

### 3. Pitfalls, Lessons Learned, and the "Shift in Strategy"
The primary reason the auto-download failed in the penultimate stepâ€”and why it magically started working in the final stepâ€”comes down to the brutal reality of **Cross-Origin Iframes and Qt WebEngine timings**. 

Here are the key lessons for any future Perchance (or general WebEngine) work:

*   **The "Profile vs. Page" Script Injection**: In the failing iteration, I attached our `QWebEngineScript` to the `QWebEnginePage` and triggered it at `DocumentReady`. However, Perchance dynamically spins up `image-generation.perchance.org` iframes on the fly. Because these frames are dynamically created *after* the main page loads, the script wasn't reliably attaching to them. **The Fix:** I shifted the injection to the `QWebEngineProfile` level and changed the timing to `DocumentCreation`. This tells the Chromium backend: *"The absolute microsecond you create a new iframe, inject this code before you evaluate a single line of its HTML."* This guaranteed our listener was waiting before the image generation even started.
*   **Cross-Origin Iframe Hell**: Perchance is a Russian nesting doll of iframes. 
    1. Top frame (`perchance.org`) 
    2. Generator frame (`<hash>.perchance.org`) 
    3. Image frames (`image-generation.perchance.org`). 
    Because of browser security (CORS), Frame 1 cannot look at Frame 3. We overcame this by injecting the script into *all* frames, catching the data in Frame 2, and using `window.top.postMessage()` to securely blast the data up to Frame 1 where Python could reach it.
*   **State stored in the DOM**: A massive lesson learned is how Perchance manages state. Instead of holding the "prompt" in a JavaScript variable, they JSON-stringify it, URL-encode it, and append it to the `#hash` of the iframe's `src` attribute. If you ever need to scrape data from Perchance in the future, check the iframe URLs first!
*   **C++ Virtual Methods in Python**: During our debug phase, we learned that PyQt6's `javaScriptConsoleMessage` cannot be monkey-patched on an instance variable. Because it's a C++ virtual method, you *must* subclass `QWebEnginePage` to override it. This is a crucial PyQt6 quirk to remember for future debugging.

This was a fantastic debugging session. We completely bypassed their UI layer to hook directly into their internal rendering pipeline!
```

### SOLUTION CONTEXT

```log
E:\Videos\image-prompter>python -m app.main
Qt QtWarningMsg: setHighDpiScaleFactorRoundingPolicy must be called before creating the QGuiApplication instance
[Perchance] Profile created successfully
[Perchance] Page and profile initialized
[Perchance] Auto-download script registered on profile. Found=1 scripts, runsOnSubFrames=True
[Perchance] Loading URL: https://perchance.org/a1481832-0a06-414f-baa6-616052e5f61d
[3532:31796:0221/231150.316:ERROR:sqlite_persistent_shared_dictionary_store.cc(1698)] Invalid total_dict_size detected.
[3532:29712:0221/231150.331:ERROR:sqlite_persistent_shared_dictionary_store.cc(1698)] Invalid total_dict_size detected.
[Perchance] JS: [Perchance-AD] INJECTED into TOP frame. hasPromptInput=false
[Perchance] JS: [Perchance-AD] TOP: Queue + diag listener registered
[Perchance] JS-ERR: Blocked script execution in 'about:blank' because the document's frame is sandboxed and the 'allow-scripts' permission is not set. [about:blank:0]
[Perchance] JS: [Perchance-AD] DIAG from sub-frame: isTop=false hasPrompt=false href=about:blank
[Perchance] JS: [Perchance-AD] DIAG from sub-frame: isTop=false hasPrompt=false href=https://03e65191fae29f82a46a2bc88999865b.perchance.org/a1481832-0a06-414f-baa6-616052e5f61d?__generatorLastEditTime=1756
[Perchance] loadFinished: ok=True
[Perchance] Ad-hide script injected
[Perchance] Poll timer started (1s interval)
[Perchance] JS: [Perchance-AD] DIAG from sub-frame: isTop=false hasPrompt=false href=about:blank
[Perchance] JS: [Perchance-AD] DIAG from sub-frame: isTop=false hasPrompt=false href=about:blank
[Perchance] JS: [Perchance-AD] DIAG from sub-frame: isTop=false hasPrompt=false href=about:blank
[Perchance] JS: [Perchance-AD] DIAG from sub-frame: isTop=false hasPrompt=false href=about:blank
[Perchance] JS: [Perchance-AD] DIAG from sub-frame: isTop=false hasPrompt=false href=https://image-generation.perchance.org/embed#%7B%22saveChannel%22%3A%22a1481832-0a06-414f-baa6-616052e5f61d%22%2C%22save
[Perchance] JS: [Perchance-AD] DIAG from sub-frame: isTop=false hasPrompt=false href=https://image-generation.perchance.org/embed#%7B%22saveChannel%22%3A%22a1481832-0a06-414f-baa6-616052e5f61d%22%2C%22save
[Perchance] JS: [Perchance-AD] DIAG from sub-frame: isTop=false hasPrompt=false href=https://image-generation.perchance.org/embed#%7B%22saveChannel%22%3A%22a1481832-0a06-414f-baa6-616052e5f61d%22%2C%22save
[Perchance] JS: [Perchance-AD] DIAG from sub-frame: isTop=false hasPrompt=false href=https://image-generation.perchance.org/embed#%7B%22saveChannel%22%3A%22a1481832-0a06-414f-baa6-616052e5f61d%22%2C%22save
[Perchance] JS: [Perchance-AD] TOP: Queued image #1 seed=868236749
[Perchance] Queue result received: 162816 chars
[Perchance] Processing 1 queued images
[Perchance] JS: [Perchance-AD] TOP: Queued image #1 seed=1058104180
[Perchance] Queue result received: 113913 chars
[Perchance] Processing 1 queued images
[Perchance] JS: [Perchance-AD] TOP: Queued image #1 seed=523470894
[Perchance] Queue result received: 159076 chars
[Perchance] Processing 1 queued images
[Perchance] JS: [Perchance-AD] TOP: Queued image #1 seed=100830968
[Perchance] Queue result received: 141324 chars
[Perchance] Processing 1 queued images
[Perchance] JS: [Perchance-AD] DIAG from sub-frame: isTop=false hasPrompt=false href=about:blank
[Perchance] JS: [Perchance-AD] DIAG from sub-frame: isTop=false hasPrompt=false href=about:blank
[Perchance] JS: [Perchance-AD] DIAG from sub-frame: isTop=false hasPrompt=false href=about:blank
[Perchance] JS: [Perchance-AD] DIAG from sub-frame: isTop=false hasPrompt=false href=about:blank
[Perchance] JS: [Perchance-AD] DIAG from sub-frame: isTop=false hasPrompt=false href=https://image-generation.perchance.org/embed#%7B%22saveChannel%22%3A%22a1481832-0a06-414f-baa6-616052e5f61d%22%2C%22save
[Perchance] JS: [Perchance-AD] DIAG from sub-frame: isTop=false hasPrompt=false href=https://image-generation.perchance.org/embed#%7B%22saveChannel%22%3A%22a1481832-0a06-414f-baa6-616052e5f61d%22%2C%22save
[Perchance] JS: [Perchance-AD] DIAG from sub-frame: isTop=false hasPrompt=false href=https://image-generation.perchance.org/embed#%7B%22saveChannel%22%3A%22a1481832-0a06-414f-baa6-616052e5f61d%22%2C%22save
[Perchance] JS: [Perchance-AD] DIAG from sub-frame: isTop=false hasPrompt=false href=https://image-generation.perchance.org/embed#%7B%22saveChannel%22%3A%22a1481832-0a06-414f-baa6-616052e5f61d%22%2C%22save
[Perchance] JS: [Perchance-AD] TOP: Queued image #1 seed=127570186
[Perchance] Queue result received: 311392 chars
[Perchance] Processing 1 queued images
[Perchance] JS: [Perchance-AD] TOP: Queued image #1 seed=997694346
[Perchance] Queue result received: 174412 chars
[Perchance] Processing 1 queued images
[Perchance] JS: [Perchance-AD] TOP: Queued image #1 seed=684335342
[Perchance] Queue result received: 99400 chars
[Perchance] Processing 1 queued images
[Perchance] JS: [Perchance-AD] TOP: Queued image #1 seed=137212247
[Perchance] Queue result received: 138284 chars
[Perchance] Processing 1 queued images
```

```perchance_service.py
# core/services/perchance_service.py
"""
Perchance Service â€“ WebEngine profile management, ad blocking, auto-download
interception, and EXIF metadata embedding for the embedded Perchance generator.
"""

import base64
import io
import os
from datetime import datetime
from pathlib import Path
from typing import Optional

_LOG_PREFIX = "[Perchance]"


def _log(msg):
    print(f"{_LOG_PREFIX} {msg}", flush=True)

_WEBENGINE_AVAILABLE = False
try:
    from PyQt6.QtWebEngineCore import (
        QWebEngineProfile,
        QWebEnginePage,
        QWebEngineUrlRequestInterceptor,
    )
    _WEBENGINE_AVAILABLE = True
except ImportError:
    QWebEngineUrlRequestInterceptor = None


def is_webengine_available() -> bool:
    return _WEBENGINE_AVAILABLE


# â”€â”€ Ad-block request interceptor â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

if _WEBENGINE_AVAILABLE:

    class AdBlockInterceptor(QWebEngineUrlRequestInterceptor):
        def __init__(self, blocked_domains: list, parent=None):
            super().__init__(parent)
            self.blocked_domains = blocked_domains or []

        def interceptRequest(self, info):
            url = info.requestUrl().toString()
            for domain in self.blocked_domains:
                if domain in url:
                    info.block(True)
                    return


# â”€â”€ Service class â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

class PerchanceService:
    """
    Creates a persistent WebEngine profile with ad-blocking and handles
    auto-download of generated images with full EXIF metadata.
    """

    DEFAULT_BLOCKED_DOMAINS = [
        "a.pub.network",
        "d.pub.network",
        "cdn.snigelweb.com",
        "googletagmanager.com",
        "cloudflareinsights.com",
        "static.criteo.net",
        "secure.quantserve.com",
        "fundingchoicesmessages.google.com",
    ]

    DEFAULT_HIDDEN_SELECTORS = [
        ".ad-providers-ctn-el",
        "#adCtn",
        "#pmLink",
        "#menuBarEl",
        "#minimalModeMenuBtn",
    ]

    def __init__(self, config_manager=None):
        self.config_manager = config_manager
        self._profile = None
        self._interceptor = None
        self._page = None
        self._status_callback = None

    def set_page(self, page):
        self._page = page

    def set_status_callback(self, callback):
        self._status_callback = callback

    def _emit_status(self, msg: str):
        if self._status_callback:
            self._status_callback(msg)

    # â”€â”€ Profile creation â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    def create_profile(self, parent=None):
        if not _WEBENGINE_AVAILABLE:
            return None

        from PyQt6.QtCore import QStandardPaths

        base = QStandardPaths.writableLocation(
            QStandardPaths.StandardLocation.AppDataLocation
        )
        storage_root = os.path.join(base, "webengine", "perchance")
        os.makedirs(storage_root, exist_ok=True)

        profile = QWebEngineProfile("perchance", parent)
        profile.setPersistentStoragePath(os.path.join(storage_root, "storage"))
        profile.setCachePath(os.path.join(storage_root, "cache"))
        profile.setHttpCacheType(QWebEngineProfile.HttpCacheType.DiskHttpCache)

        try:
            profile.setPersistentCookiesPolicy(
                QWebEngineProfile.PersistentCookiesPolicy.ForcePersistentCookies
            )
        except AttributeError:
            pass

        blocked = self._get_blocked_domains()
        if blocked:
            self._interceptor = AdBlockInterceptor(blocked, parent)
            profile.setUrlRequestInterceptor(self._interceptor)

        # Fallback: manual download handling (heart â†’ save to device)
        profile.downloadRequested.connect(self._on_download_requested)

        self._profile = profile
        _log("Profile created successfully")
        return profile

    # â”€â”€ Manual download fallback â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    def _on_download_requested(self, download):
        """Fallback handler for manual 'save to device' downloads."""
        try:
            mime_type = (download.mimeType() or "").lower()
            dl_name = (download.downloadFileName() or "").lower()
            is_image = mime_type.startswith("image/") or dl_name.endswith(
                (".png", ".jpg", ".jpeg", ".webp", ".gif")
            )
            if not is_image:
                _log(f"Non-image download ignored: {dl_name}")
                return

            images_dir = Path("images")
            images_dir.mkdir(exist_ok=True)

            timestamp = datetime.now().strftime("%Y-%m-%d_%H-%M-%S")
            orig_ext = Path(download.downloadFileName() or "image.png").suffix or ".png"
            temp_name = f"_perchance_tmp_{timestamp}{orig_ext}"

            download.setDownloadDirectory(str(images_dir.resolve()))
            download.setDownloadFileName(temp_name)

            temp_path = images_dir / temp_name

            download.isFinishedChanged.connect(
                lambda tp=temp_path, ts=timestamp: self._finalize_manual_download(tp, ts)
            )

            download.accept()
            _log(f"Manual download accepted: {temp_name}")
            self._emit_status("Downloading image from Perchance\u2026")

        except Exception as e:
            _log(f"Manual download error: {e}")
            self._emit_status(f"Download error: {e}")

    def _finalize_manual_download(self, temp_path: Path, timestamp: str):
        """Post-process a manually saved download with basic metadata."""
        if not temp_path.exists():
            _log(f"Manual download temp file missing: {temp_path}")
            return
        try:
            if temp_path.stat().st_size == 0:
                temp_path.unlink(missing_ok=True)
                return
        except OSError:
            return

        images_dir = temp_path.parent
        final_path = images_dir / f"{timestamp}.jpg"
        counter = 1
        while final_path.exists():
            final_path = images_dir / f"{timestamp}_{counter}.jpg"
            counter += 1

        saved = False
        try:
            from PIL import Image

            img = Image.open(str(temp_path))
            if img.mode in ("RGBA", "P", "LA"):
                img = img.convert("RGB")

            exif = img.getexif()
            exif[0x010E] = "Service: Perchance"
            exif[0x0131] = "Perchance AI"
            img.save(str(final_path), "JPEG", quality=95, exif=exif.tobytes())
            saved = True
        except Exception as e:
            _log(f"PIL conversion failed: {e}")

        if not saved:
            try:
                temp_path.rename(final_path)
                saved = True
            except OSError:
                pass

        if temp_path.exists():
            try:
                temp_path.unlink(missing_ok=True)
            except OSError:
                pass

        if saved:
            _log(f"Manual download saved: {final_path.name}")
            self._emit_status(f"Image saved: {final_path.name}")

    # â”€â”€ Ad-hide JavaScript (Layer 2) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    def get_ad_hide_script(self) -> str:
        selectors = self._get_hidden_selectors()
        if not selectors:
            return ""

        selectors_js = ", ".join(f'"{s}"' for s in selectors)
        return f"""
(function() {{
    if (window._perchanceAdblockActive) return;
    window._perchanceAdblockActive = true;

    var selectors = [{selectors_js}];

    function hide() {{
        selectors.forEach(function(s) {{
            document.querySelectorAll(s).forEach(function(el) {{
                el.style.setProperty('display', 'none', 'important');
                el.style.setProperty('visibility', 'hidden', 'important');
                el.style.position = 'absolute';
                el.style.left = '-9999px';
            }});
        }});
        try {{
            document.documentElement.style.setProperty('--menu-bar-height', '0px');
        }} catch(e) {{}}
    }}

    hide();
    setTimeout(hide, 500);
    setTimeout(hide, 1500);
    setTimeout(hide, 4000);

    var obs = new MutationObserver(function() {{ hide(); }});
    if (document.body) {{
        obs.observe(document.body, {{ childList: true, subtree: true }});
    }} else {{
        document.addEventListener('DOMContentLoaded', function() {{
            hide();
            obs.observe(document.body, {{ childList: true, subtree: true }});
        }});
    }}
}})();
"""

    # â”€â”€ Auto-download injection script â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    def get_auto_download_script(self) -> str:
        """
        Return JavaScript that auto-captures generated images via postMessage
        interception.  Designed to run in all frames (main + sub-frames):

        * **Generator frame** (has ``#promptInput``): listens for ``finished``
          messages from image-generation iframes, extracts metadata from iframe
          URL hashes, and forwards everything to ``window.top``.
        * **Top frame**: maintains ``window._perchanceImageQueue`` that Python
          polls via ``runJavaScript``.
        """
        return r"""
(function() {
    if (window._perchanceAutoDownloadActive) return;
    window._perchanceAutoDownloadActive = true;

    var isTopFrame = false;
    try { isTopFrame = (window === window.top); } catch(e) {}

    var hasPromptInput = !!document.getElementById('promptInput');

    // --- Diagnostic: announce injection from every frame ---
    var diagInfo = {
        isTop: isTopFrame,
        hasPrompt: hasPromptInput,
        href: window.location.href.substring(0, 120)
    };

    if (isTopFrame) {
        console.log('[Perchance-AD] INJECTED into TOP frame. hasPromptInput=' + hasPromptInput);
    } else {
        // Sub-frame: send diagnostic to top via postMessage (console may not be captured)
        try {
            window.top.postMessage({_perchanceDiag: diagInfo}, '*');
        } catch(e) {}
    }

    // --- Top frame: queue + diagnostic listener ---
    if (isTopFrame) {
        if (!window._perchanceImageQueue) window._perchanceImageQueue = [];

        window.addEventListener('message', function(event) {
            try {
                var d = event.data;
                if (!d) return;

                // Diagnostic from sub-frames
                if (d._perchanceDiag) {
                    console.log('[Perchance-AD] DIAG from sub-frame: isTop=' + d._perchanceDiag.isTop + ' hasPrompt=' + d._perchanceDiag.hasPrompt + ' href=' + d._perchanceDiag.href);
                    return;
                }

                // Queued image from generator frame
                if (d._perchanceAutoSave) {
                    window._perchanceImageQueue.push(d._perchanceAutoSave);
                    console.log('[Perchance-AD] TOP: Queued image #' + window._perchanceImageQueue.length + ' seed=' + d._perchanceAutoSave.seedUsed);
                }
            } catch(e) {
                console.log('[Perchance-AD] TOP listener error: ' + e);
            }
        });
        console.log('[Perchance-AD] TOP: Queue + diag listener registered');
    }

    // --- Any non-top frame: listen for finished images and forward ---
    if (!isTopFrame) {
        var processedIds = {};

        window.addEventListener('message', function(event) {
            try {
                var data = event.data;
                if (!data || data.type !== 'finished' || !data.dataUrl || !data.id) return;
                if (processedIds[data.id]) return;
                processedIds[data.id] = true;

                // Extract metadata from matching iframe URL hash
                var meta = {};
                try {
                    var iframe = document.querySelector('iframe.' + CSS.escape(data.id));
                    if (iframe) {
                        var hashStr = (iframe.src || iframe.getAttribute('data-src') || '').split('#')[1] || '';
                        if (hashStr) meta = JSON.parse(decodeURIComponent(hashStr));
                    }
                } catch(e) {}

                // Forward to top frame
                var payload = {
                    _perchanceAutoSave: {
                        dataUrl: data.dataUrl,
                        seedUsed: data.seedUsed,
                        prompt: meta.prompt || '',
                        negativePrompt: meta.negativePrompt || '',
                        resolution: meta.resolution || '',
                        guidanceScale: meta.guidanceScale,
                        userPrompt: (document.getElementById('promptInput') || {}).value || '',
                        userNegative: (document.getElementById('negativeInput') || {}).value || ''
                    }
                };
                window.top.postMessage(payload, '*');
            } catch(e) {}
        });
    }
})();
"""

    # â”€â”€ Queue polling (called from PerchancePage) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    def poll_image_queue(self):
        """Run JavaScript to splice the image queue and process results."""
        if not self._page:
            return
        js = """
(function() {
    if (!window._perchanceImageQueue || window._perchanceImageQueue.length === 0) return '[]';
    var items = window._perchanceImageQueue.splice(0);
    var result = [];
    for (var i = 0; i < items.length; i++) {
        result.push({
            dataUrl: items[i].dataUrl,
            seedUsed: items[i].seedUsed,
            prompt: items[i].prompt || '',
            negativePrompt: items[i].negativePrompt || '',
            resolution: items[i].resolution || '',
            guidanceScale: items[i].guidanceScale,
            userPrompt: items[i].userPrompt || '',
            userNegative: items[i].userNegative || ''
        });
    }
    return JSON.stringify(result);
})();
"""
        self._page.runJavaScript(js, self._process_queue_result)

    def _process_queue_result(self, result):
        """Handle the JSON string returned by the queue-polling JavaScript."""
        if not result or result == "[]":
            return

        import json

        _log(f"Queue result received: {len(str(result))} chars")

        try:
            items = json.loads(result)
        except (json.JSONDecodeError, TypeError) as e:
            _log(f"Failed to parse queue JSON: {e} â€” raw: {str(result)[:200]}")
            return

        _log(f"Processing {len(items)} queued images")

        saved_count = 0
        for item in items:
            try:
                data_url = item.get("dataUrl", "")
                if not data_url or "," not in data_url:
                    continue

                raw_b64 = data_url.split(",", 1)[1]
                image_bytes = base64.b64decode(raw_b64)
                if len(image_bytes) < 1000:
                    continue

                path = self._save_image(
                    image_bytes=image_bytes,
                    prompt=item.get("prompt", ""),
                    negative_prompt=item.get("negativePrompt", ""),
                    resolution=item.get("resolution", ""),
                    seed=item.get("seedUsed", -1),
                    guidance_scale=item.get("guidanceScale", ""),
                    user_prompt=item.get("userPrompt", ""),
                    user_negative=item.get("userNegative", ""),
                )
                if path:
                    saved_count += 1
            except Exception as e:
                _log(f"Auto-save error: {e}")
                self._emit_status(f"Auto-save error: {e}")

        if saved_count:
            label = "image" if saved_count == 1 else "images"
            self._emit_status(f"Auto-saved {saved_count} Perchance {label}")

    # â”€â”€ Image saving with EXIF â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    def _save_image(
        self,
        image_bytes: bytes,
        prompt: str,
        negative_prompt: str,
        resolution: str,
        seed,
        guidance_scale,
        user_prompt: str = "",
        user_negative: str = "",
    ) -> Optional[str]:
        """
        Save image bytes as a JPEG with comprehensive EXIF metadata.

        Returns the saved file path, or None on failure.
        """
        images_dir = Path("images")
        images_dir.mkdir(exist_ok=True)

        timestamp = datetime.now().strftime("%Y-%m-%d_%H-%M-%S")
        final_path = images_dir / f"{timestamp}.jpg"
        counter = 1
        while final_path.exists():
            final_path = images_dir / f"{timestamp}_{counter}.jpg"
            counter += 1

        # Determine image dimensions from bytes if resolution not provided
        actual_size = resolution
        try:
            from PIL import Image

            img = Image.open(io.BytesIO(image_bytes))
            if not actual_size:
                actual_size = f"{img.width}x{img.height}"
            if img.mode in ("RGBA", "P", "LA"):
                img = img.convert("RGB")

            # Build metadata string
            parts = []
            if prompt:
                parts.append(f"Prompt: {prompt}")
            if negative_prompt:
                parts.append(f"Negative: {negative_prompt}")
            parts.append(f"Size: {actual_size}")
            parts.append(f"Seed: {seed}")
            if guidance_scale is not None:
                parts.append(f"GuidanceScale: {guidance_scale}")
            parts.append("Service: Perchance")
            metadata_str = " | ".join(parts)

            exif = img.getexif()
            exif[0x010E] = metadata_str       # ImageDescription
            exif[0x0131] = "Perchance AI"     # Software
            img.save(str(final_path), "JPEG", quality=95, exif=exif.tobytes())
            return str(final_path)

        except ImportError:
            pass
        except Exception as e:
            self._emit_status(f"Image conversion note: {e}")

        # Fallback: write raw bytes
        try:
            with open(final_path, "wb") as f:
                f.write(image_bytes)
            return str(final_path)
        except OSError:
            return None

    # â”€â”€ Config helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    def _get_blocked_domains(self) -> list:
        if self.config_manager:
            ab = getattr(self.config_manager, "adblocker", {})
            if isinstance(ab, dict) and ab.get("blocked_domains"):
                return ab["blocked_domains"]
        return self.DEFAULT_BLOCKED_DOMAINS

    def _get_hidden_selectors(self) -> list:
        if self.config_manager:
            ab = getattr(self.config_manager, "adblocker", {})
            if isinstance(ab, dict) and ab.get("hidden_selectors"):
                return ab["hidden_selectors"]
        return self.DEFAULT_HIDDEN_SELECTORS
```

```perchance_page.py
# gui/widgets/perchance_page.py
"""
Perchance Page â€“ Embeds a Perchance image generator in a QWebEngineView
with ad-blocking, auto-download, and persistent login / cookie storage.
"""

from PyQt6.QtWidgets import QWidget, QVBoxLayout, QLabel, QSizePolicy
from PyQt6.QtCore import pyqtSignal, Qt, QTimer

from core.services.perchance_service import PerchanceService, is_webengine_available

PERCHANCE_URL = "https://perchance.org/a1481832-0a06-414f-baa6-616052e5f61d"

_LOG_PREFIX = "[Perchance]"


def _log(msg):
    print(f"{_LOG_PREFIX} {msg}", flush=True)


# â”€â”€ QWebEnginePage subclass for JS console capture â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

_PerchanceWebPage = None

if is_webengine_available():
    from PyQt6.QtWebEngineCore import QWebEnginePage as _QWebEnginePage

    class _PerchancePageImpl(_QWebEnginePage):
        """Subclass that captures JavaScript console messages."""

        def javaScriptConsoleMessage(self, level, message, lineNumber, sourceID):
            if '[Perchance-AD]' in message:
                _log(f"JS: {message}")
            elif level == _QWebEnginePage.JavaScriptConsoleMessageLevel.ErrorMessageLevel:
                # Only log errors that aren't noise
                if 'Permissions-Policy' not in message and 'ERR_BLOCKED' not in message:
                    _log(f"JS-ERR: {message} [{sourceID}:{lineNumber}]")

    _PerchanceWebPage = _PerchancePageImpl


class PerchancePage(QWidget):
    """
    Perchance image generation page.

    Loads the Perchance generator URL inside a QWebEngineView with:

    * Persistent cookie / login profile
    * Two-layer ad blocking (request interception + DOM hiding)
    * Menu bar hiding (#menuBarEl)
    * Automatic image capture via postMessage interception
    * Full EXIF metadata embedding (prompt, negative, size, seed, guidance)
    """

    status_updated = pyqtSignal(str)

    def __init__(self, config_manager=None, parent=None):
        super().__init__(parent)
        self.config_manager = config_manager
        self.service = PerchanceService(config_manager)
        self.service.set_status_callback(self.status_updated.emit)

        self._webview = None
        self._page = None
        self._url_loaded = False
        self._poll_timer = None

        self.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Expanding)
        self._build_ui()

    # â”€â”€ UI construction â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    def _build_ui(self):
        layout = QVBoxLayout(self)
        layout.setContentsMargins(0, 0, 0, 0)
        layout.setSpacing(0)

        if not is_webengine_available():
            self._build_fallback(layout)
            return

        try:
            from PyQt6.QtWebEngineWidgets import QWebEngineView

            profile = self.service.create_profile(self)
            if not profile:
                _log("ERROR: Profile creation failed")
                self._build_fallback(layout)
                return

            self._webview = QWebEngineView()
            self._page = _PerchanceWebPage(profile, self._webview)
            self._webview.setPage(self._page)

            self.service.set_page(self._page)
            _log("Page and profile initialized")

            # Inject auto-download script into ALL frames (profile-level)
            from PyQt6.QtWebEngineCore import QWebEngineScript
            auto_dl_script = QWebEngineScript()
            auto_dl_script.setName("perchance_auto_download")
            auto_dl_script.setSourceCode(self.service.get_auto_download_script())
            auto_dl_script.setInjectionPoint(
                QWebEngineScript.InjectionPoint.DocumentCreation
            )
            auto_dl_script.setWorldId(QWebEngineScript.ScriptWorldId.MainWorld)
            auto_dl_script.setRunsOnSubFrames(True)

            # Register on PROFILE (not page) for broader sub-frame coverage
            profile.scripts().insert(auto_dl_script)

            # Verify registration
            registered = profile.scripts().find("perchance_auto_download")
            _log(f"Auto-download script registered on profile. Found={len(registered)} scripts, runsOnSubFrames={auto_dl_script.runsOnSubFrames()}")

            # Ad-hide + menu-bar-hide after page load
            self._webview.loadFinished.connect(self._on_load_finished)

            # Poll timer for auto-download queue
            self._poll_timer = QTimer(self)
            self._poll_timer.setInterval(1000)
            self._poll_timer.timeout.connect(self._poll_images)

            layout.addWidget(self._webview, 1)

        except Exception as e:
            _log(f"ERROR in _build_ui: {e}")
            self._build_fallback(layout, str(e))

    def _build_fallback(self, layout, error_msg=None):
        container = QWidget()
        cl = QVBoxLayout(container)
        cl.setAlignment(Qt.AlignmentFlag.AlignCenter)

        icon = QLabel("\U0001f3b2")
        icon.setStyleSheet("font-size: 32pt;")
        icon.setAlignment(Qt.AlignmentFlag.AlignCenter)
        cl.addWidget(icon)

        title = QLabel("Perchance")
        title.setStyleSheet("color: #666; font-size: 14pt; font-weight: bold;")
        title.setAlignment(Qt.AlignmentFlag.AlignCenter)
        cl.addWidget(title)

        lines = ["PyQt6-WebEngine is required for Perchance integration."]
        if error_msg:
            lines.append(f"\n{error_msg}")
        lines.append("\nInstall:  pip install PyQt6-WebEngine")
        lines.append(f"\nOr visit directly:\n{PERCHANCE_URL}")

        desc = QLabel("\n".join(lines))
        desc.setStyleSheet("color: #888; font-size: 9pt;")
        desc.setAlignment(Qt.AlignmentFlag.AlignCenter)
        desc.setWordWrap(True)
        desc.setTextInteractionFlags(Qt.TextInteractionFlag.TextSelectableByMouse)
        cl.addWidget(desc)

        layout.addWidget(container)

    # â”€â”€ Events â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    def showEvent(self, event):
        super().showEvent(event)
        if self._webview and not self._url_loaded:
            self._url_loaded = True
            from PyQt6.QtCore import QUrl

            url = PERCHANCE_URL
            if self.config_manager:
                url = getattr(self.config_manager, "perchance_url", url) or url
            _log(f"Loading URL: {url}")
            self._webview.setUrl(QUrl(url))

    def _on_load_finished(self, ok: bool):
        _log(f"loadFinished: ok={ok}")
        if not ok or not self._page:
            return

        # Inject ad/menu-bar hiding CSS overrides
        script = self.service.get_ad_hide_script()
        if script:
            self._page.runJavaScript(script)
            _log("Ad-hide script injected")

        # Start polling for auto-downloaded images
        if self._poll_timer and not self._poll_timer.isActive():
            self._poll_timer.start()
            _log("Poll timer started (1s interval)")

    # â”€â”€ Auto-download polling â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    def _poll_images(self):
        if self._page:
            self.service.poll_image_queue()
```

```gallery_service.py
# core/services/gallery_service.py
"""
Gallery Service - Reads and caches image metadata from the generated images directory.
"""

from pathlib import Path
from dataclasses import dataclass
from typing import List, Dict

@dataclass
class ImageMetadata:
    filepath: str
    prompt: str
    service: str
    model: str
    timestamp: str
    negative_prompt: str = ""
    size: str = ""
    seed: str = ""
    guidance_scale: str = ""


class GalleryService:
    def __init__(self):
        self._cache: Dict[str, tuple[float, ImageMetadata]] = {}
        self.images_dir = Path("images")
        self.images_dir.mkdir(exist_ok=True)
        
    def get_images(self, filter_service: str = "All") -> List[ImageMetadata]:
        images = []
        if not self.images_dir.exists():
            return images
            
        for p in self.images_dir.glob("*.jpg"):
            try:
                mtime = p.stat().st_mtime
                filepath_str = str(p)
                
                # Check cache mapping via modified time
                if filepath_str in self._cache and self._cache[filepath_str][0] == mtime:
                    meta = self._cache[filepath_str][1]
                else:
                    meta = self._parse_metadata(p)
                    self._cache[filepath_str] = (mtime, meta)
                    
                if filter_service == "All" or meta.service.lower() == filter_service.lower():
                    images.append(meta)
            except Exception:
                continue
                
        # Sort by filepath descending (newest timestamp first)
        images.sort(key=lambda x: x.filepath, reverse=True)
        return images
        
    def _parse_metadata(self, filepath: Path) -> ImageMetadata:
        prompt = ""
        service = "Unknown"
        model = "Unknown"
        timestamp = filepath.stem
        negative_prompt = ""
        size = ""
        seed = ""
        guidance_scale = ""

        try:
            from PIL import Image
            with Image.open(filepath) as img:
                exif = img.getexif()
                if exif and 0x010E in exif:
                    meta_str = exif[0x010E]
                    parts = [p.strip() for p in meta_str.split("|")]
                    for part in parts:
                        if part.startswith("Prompt:"):
                            prompt = part[7:].strip()
                        elif part.startswith("Service:"):
                            service = part[8:].strip()
                        elif part.startswith("Model:"):
                            model = part[6:].strip()
                        elif part.startswith("Negative:"):
                            negative_prompt = part[9:].strip()
                        elif part.startswith("Size:"):
                            size = part[5:].strip()
                        elif part.startswith("Seed:"):
                            seed = part[5:].strip()
                        elif part.startswith("GuidanceScale:"):
                            guidance_scale = part[14:].strip()
        except Exception:
            pass

        return ImageMetadata(
            str(filepath), prompt, service, model, timestamp,
            negative_prompt, size, seed, guidance_scale,
        )
```

```config.py
"""Configuration Manager for PyQt6 GUI Framework."""
import os
import json

_DEFAULTS = {
    "window_width": 1200,
    "window_height": 800,
    "theme": "dark",
    "current_service": "Gemini",
    "current_model": "Flash",
    "default_system_prompt": "You are a helpful AI assistant.",
    "splitter_sizes": [780, 420],
    "media_active_tab": 0,
    "gallery_page": 1,
    "gallery_filter": "All",
    "pollinations_positive_prompt": "",
    "pollinations_negative_prompt": "",
    "pollinations_model": "zimage",
    "pollinations_size": "1024x1024",
    "pollinations_seed": -1,
    "pollinations_last_image": "",
    "airforce_positive_prompt": "",
    "airforce_negative_prompt": "",
    "airforce_model": "grok-imagine",
    "airforce_last_image": "",
    "perchance_url": "https://perchance.org/a1481832-0a06-414f-baa6-616052e5f61d",
    "adblocker": {
        "blocked_domains": [
            "a.pub.network",
            "d.pub.network",
            "cdn.snigelweb.com",
            "googletagmanager.com",
            "cloudflareinsights.com",
            "static.criteo.net",
            "secure.quantserve.com",
            "fundingchoicesmessages.google.com"
        ],
        "hidden_selectors": [
            ".ad-providers-ctn-el",
            "#adCtn",
            "#pmLink",
            "#menuBarEl",
            "#minimalModeMenuBtn"
        ]
    },
    "display_fields": {
        "core": True,
        "composition": True,
        "lighting": True,
        "style": True,
        "technical": True,
        "post_processing": True,
        "special_elements": True,
        "detailed_prompt": True,
        "grok_imagine_optimized": True,
        "gemini_optimized": True,
        "flux_optimized": True,
        "stable_diffusion_optimized": True,
        "video_optimized": True
    }
}

class ConfigManager:
    """Manages GUI configuration values and local gui_config.json persistence."""

    def __init__(self, config_file: str = "gui_config.json"):
        self.config_file = config_file
        self.__dict__.update(_DEFAULTS)
        self._load_config()

    def _load_config(self) -> None:
        if not os.path.exists(self.config_file):
            return
        try:
            with open(self.config_file, 'r') as f:
                config = json.load(f)
                for k in _DEFAULTS:
                    val = config.get(k, getattr(self, k))
                    if isinstance(val, dict) and isinstance(_DEFAULTS[k], dict):
                        merged = _DEFAULTS[k].copy()
                        merged.update(val)
                        setattr(self, k, merged)
                    else:
                        setattr(self, k, val)
                if "default_service" in config and "current_service" not in config:
                    self.current_service = config["default_service"]
                if "service_models" in config and "current_model" not in config:
                    self.current_model = config.get("service_models", {}).get(self.current_service, self.current_model)
        except Exception:
            pass

    def save(self) -> None:
        try:
            with open(self.config_file, 'w') as f:
                json.dump({k: getattr(self, k) for k in _DEFAULTS}, f, indent=2)
        except Exception:
            pass

```

### CONTEXT

## ðŸŽ¯ Focused Context (Agent-Selected)

**Project Root:** `image-prompter/`
**Files Included:** 6

---

### File Index

1. `core/services/perchance_service.py`
2. `gui/widgets/perchance_page.py`
3. `core/utils.py`
4. `core/services/gallery_service.py`
5. `gui/widgets/media_panel.py`
6. `core/config.py`

---

### `core/services/perchance_service.py`

```python
# core/services/perchance_service.py
"""
Perchance Service â€“ WebEngine profile management, ad blocking, and image
download handling for the embedded Perchance image generator.
"""

import os
from datetime import datetime
from pathlib import Path

_WEBENGINE_AVAILABLE = False
try:
    from PyQt6.QtWebEngineCore import (
        QWebEngineProfile,
        QWebEnginePage,
        QWebEngineUrlRequestInterceptor,
    )
    _WEBENGINE_AVAILABLE = True
except ImportError:
    QWebEngineUrlRequestInterceptor = None


def is_webengine_available() -> bool:
    """Return *True* if PyQt6-WebEngine is installed and importable."""
    return _WEBENGINE_AVAILABLE


# â”€â”€ Ad-block request interceptor â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

if _WEBENGINE_AVAILABLE:

    class AdBlockInterceptor(QWebEngineUrlRequestInterceptor):
        """Block network requests whose URL contains a blocked-domain substring."""

        def __init__(self, blocked_domains: list, parent=None):
            super().__init__(parent)
            self.blocked_domains = blocked_domains or []

        def interceptRequest(self, info):
            url = info.requestUrl().toString()
            for domain in self.blocked_domains:
                if domain in url:
                    info.block(True)
                    return


# â”€â”€ Service class â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

class PerchanceService:
    """
    Creates a persistent WebEngine profile with ad-blocking and handles
    image downloads from the embedded Perchance page.
    """

    DEFAULT_BLOCKED_DOMAINS = [
        "a.pub.network",
        "d.pub.network",
        "cdn.snigelweb.com",
        "googletagmanager.com",
        "cloudflareinsights.com",
        "static.criteo.net",
        "secure.quantserve.com",
        "fundingchoicesmessages.google.com",
    ]

    DEFAULT_HIDDEN_SELECTORS = [
        ".ad-providers-ctn-el",
        "#adCtn",
        "#pmLink",
    ]

    def __init__(self, config_manager=None):
        self.config_manager = config_manager
        self._profile = None
        self._interceptor = None
        self._page = None
        self._status_callback = None

    # -- External setters ------------------------------------------------

    def set_page(self, page):
        """Store a reference to the active QWebEnginePage for JS access."""
        self._page = page

    def set_status_callback(self, callback):
        """Register a callable for status messages (e.g. a pyqtSignal emit)."""
        self._status_callback = callback

    def _emit_status(self, msg: str):
        if self._status_callback:
            self._status_callback(msg)

    # â”€â”€ Profile creation â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    def create_profile(self, parent=None):
        """
        Build a *persistent* QWebEngineProfile:

        * Disk-backed cookies (login survives restarts)
        * Ad-blocking request interceptor
        * Download-requested handler for saving images

        Returns the profile, or ``None`` when WebEngine is unavailable.
        """
        if not _WEBENGINE_AVAILABLE:
            return None

        from PyQt6.QtCore import QStandardPaths

        base = QStandardPaths.writableLocation(
            QStandardPaths.StandardLocation.AppDataLocation
        )
        storage_root = os.path.join(base, "webengine", "perchance")
        os.makedirs(storage_root, exist_ok=True)

        profile = QWebEngineProfile("perchance", parent)
        profile.setPersistentStoragePath(os.path.join(storage_root, "storage"))
        profile.setCachePath(os.path.join(storage_root, "cache"))
        profile.setHttpCacheType(QWebEngineProfile.HttpCacheType.DiskHttpCache)

        try:
            profile.setPersistentCookiesPolicy(
                QWebEngineProfile.PersistentCookiesPolicy.ForcePersistentCookies
            )
        except AttributeError:
            pass  # older PyQt6 build without this enum

        # Layer 1 â€“ network-level ad blocking
        blocked = self._get_blocked_domains()
        if blocked:
            self._interceptor = AdBlockInterceptor(blocked, parent)
            profile.setUrlRequestInterceptor(self._interceptor)

        # Image download handling
        profile.downloadRequested.connect(self._on_download_requested)

        self._profile = profile
        return profile

    # â”€â”€ Ad-hide JavaScript (Layer 2) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    def get_ad_hide_script(self) -> str:
        """
        Return a JavaScript snippet that hides ad-related DOM elements and
        watches for dynamically inserted ones via MutationObserver.
        """
        selectors = self._get_hidden_selectors()
        if not selectors:
            return ""

        selectors_js = ", ".join(f'"{s}"' for s in selectors)
        return f"""
(function() {{
    if (window._perchanceAdblockActive) return;
    window._perchanceAdblockActive = true;

    var selectors = [{selectors_js}];

    function hide() {{
        selectors.forEach(function(s) {{
            document.querySelectorAll(s).forEach(function(el) {{
                el.style.setProperty('display', 'none', 'important');
                el.style.setProperty('visibility', 'hidden', 'important');
                el.style.position = 'absolute';
                el.style.left = '-9999px';
            }});
        }});
    }}

    hide();
    setTimeout(hide, 1000);
    setTimeout(hide, 3000);

    var obs = new MutationObserver(function() {{ hide(); }});
    if (document.body) {{
        obs.observe(document.body, {{ childList: true, subtree: true }});
    }} else {{
        document.addEventListener('DOMContentLoaded', function() {{
            hide();
            obs.observe(document.body, {{ childList: true, subtree: true }});
        }});
    }}
}})();
"""

    # â”€â”€ Download handling â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    def _on_download_requested(self, download):
        """
        Accept image downloads and redirect them to ``images/`` with a
        timestamp-based temporary filename.  Non-image downloads are
        silently ignored.
        """
        try:
            mime_type = (download.mimeType() or "").lower()
            dl_name = (download.downloadFileName() or "").lower()
            is_image = mime_type.startswith("image/") or dl_name.endswith(
                (".png", ".jpg", ".jpeg", ".webp", ".gif")
            )
            if not is_image:
                return

            images_dir = Path("images")
            images_dir.mkdir(exist_ok=True)

            timestamp = datetime.now().strftime("%Y-%m-%d_%H-%M-%S")
            orig_ext = Path(download.downloadFileName() or "image.png").suffix or ".png"
            temp_name = f"_perchance_tmp_{timestamp}{orig_ext}"

            download.setDownloadDirectory(str(images_dir.resolve()))
            download.setDownloadFileName(temp_name)

            # Best-effort prompt capture via async JS callback
            captured = {"prompt": ""}
            if self._page:
                self._page.runJavaScript(
                    "(function(){var e=document.querySelector('textarea');"
                    "return e?e.value:'';})()",
                    lambda result, c=captured: c.update({"prompt": result or ""}),
                )

            temp_path = images_dir / temp_name

            download.isFinishedChanged.connect(
                lambda tp=temp_path, ts=timestamp, cap=captured: self._finalize_download(
                    tp, ts, cap
                )
            )

            download.accept()
            self._emit_status("Downloading image from Perchance\u2026")

        except Exception as e:
            self._emit_status(f"Download error: {e}")

    def _finalize_download(self, temp_path: Path, timestamp: str, captured: dict):
        """
        Post-process a completed download:

        1. Open with Pillow (if available)
        2. Convert to RGB JPEG
        3. Embed EXIF metadata (prompt + service)
        4. Remove the temporary file

        Falls back to a simple rename when Pillow is absent.
        """
        if not temp_path.exists():
            return
        try:
            if temp_path.stat().st_size == 0:
                temp_path.unlink(missing_ok=True)
                return
        except OSError:
            return

        images_dir = temp_path.parent
        prompt = captured.get("prompt", "")

        # Determine unique final path
        final_path = images_dir / f"{timestamp}.jpg"
        counter = 1
        while final_path.exists():
            final_path = images_dir / f"{timestamp}_{counter}.jpg"
            counter += 1

        saved = False
        try:
            from PIL import Image

            img = Image.open(str(temp_path))
            if img.mode in ("RGBA", "P", "LA"):
                img = img.convert("RGB")

            parts = []
            if prompt:
                parts.append(f"Prompt: {prompt}")
            parts.append("Service: Perchance")
            metadata_str = " | ".join(parts)

            exif = img.getexif()
            exif[0x010E] = metadata_str      # ImageDescription
            exif[0x0131] = "Perchance AI"    # Software
            img.save(str(final_path), "JPEG", quality=95, exif=exif.tobytes())
            saved = True
        except ImportError:
            pass
        except Exception as e:
            self._emit_status(f"Image conversion note: {e}")

        if not saved:
            # Fallback: rename temp file directly
            try:
                temp_path.rename(final_path)
                saved = True
            except OSError:
                pass

        # Clean up temp file (Pillow path leaves it behind)
        if temp_path.exists():
            try:
                temp_path.unlink(missing_ok=True)
            except OSError:
                pass

        if saved:
            self._emit_status(f"Image saved: {final_path.name}")

    # â”€â”€ Config helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    def _get_blocked_domains(self) -> list:
        if self.config_manager:
            ab = getattr(self.config_manager, "adblocker", {})
            if isinstance(ab, dict) and ab.get("blocked_domains"):
                return ab["blocked_domains"]
        return self.DEFAULT_BLOCKED_DOMAINS

    def _get_hidden_selectors(self) -> list:
        if self.config_manager:
            ab = getattr(self.config_manager, "adblocker", {})
            if isinstance(ab, dict) and ab.get("hidden_selectors"):
                return ab["hidden_selectors"]
        return self.DEFAULT_HIDDEN_SELECTORS
```

### `gui/widgets/perchance_page.py`

```python
# gui/widgets/perchance_page.py
"""
Perchance Page â€“ Embeds a Perchance image generator in a QWebEngineView
with ad-blocking and persistent login / cookie storage.
"""

from PyQt6.QtWidgets import QWidget, QVBoxLayout, QLabel, QSizePolicy
from PyQt6.QtCore import pyqtSignal, Qt

from core.services.perchance_service import PerchanceService, is_webengine_available

PERCHANCE_URL = "https://perchance.org/a1481832-0a06-414f-baa6-616052e5f61d"


class PerchancePage(QWidget):
    """
    Perchance image generation page.

    Loads the Perchance generator URL inside a QWebEngineView with:

    * Persistent cookie / login profile
    * Two-layer ad blocking (request interception + DOM hiding)
    * Automatic image-download handling to ``images/``

    Falls back to a static label when PyQt6-WebEngine is not installed.
    """

    status_updated = pyqtSignal(str)

    def __init__(self, config_manager=None, parent=None):
        super().__init__(parent)
        self.config_manager = config_manager
        self.service = PerchanceService(config_manager)
        self.service.set_status_callback(self.status_updated.emit)

        self._webview = None
        self._page = None
        self._url_loaded = False

        self.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Expanding)
        self._build_ui()

    # â”€â”€ UI construction â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    def _build_ui(self):
        layout = QVBoxLayout(self)
        layout.setContentsMargins(0, 0, 0, 0)
        layout.setSpacing(0)

        if not is_webengine_available():
            self._build_fallback(layout)
            return

        try:
            from PyQt6.QtWebEngineWidgets import QWebEngineView
            from PyQt6.QtWebEngineCore import QWebEnginePage

            # Persistent profile (cookies, ad-blocking, download handling)
            profile = self.service.create_profile(self)
            if not profile:
                self._build_fallback(layout)
                return

            self._webview = QWebEngineView()
            self._page = QWebEnginePage(profile, self._webview)
            self._webview.setPage(self._page)

            # Give service access to the page for JS prompt extraction
            self.service.set_page(self._page)

            # Inject ad-hiding JS after each page load
            self._webview.loadFinished.connect(self._on_load_finished)

            layout.addWidget(self._webview, 1)

        except Exception as e:
            self._build_fallback(layout, str(e))

    def _build_fallback(self, layout, error_msg=None):
        """Display an informational placeholder when WebEngine is unavailable."""
        container = QWidget()
        cl = QVBoxLayout(container)
        cl.setAlignment(Qt.AlignmentFlag.AlignCenter)

        icon = QLabel("\U0001f3b2")  # ðŸŽ²
        icon.setStyleSheet("font-size: 32pt;")
        icon.setAlignment(Qt.AlignmentFlag.AlignCenter)
        cl.addWidget(icon)

        title = QLabel("Perchance")
        title.setStyleSheet("color: #666; font-size: 14pt; font-weight: bold;")
        title.setAlignment(Qt.AlignmentFlag.AlignCenter)
        cl.addWidget(title)

        lines = ["PyQt6-WebEngine is required for Perchance integration."]
        if error_msg:
            lines.append(f"\n{error_msg}")
        lines.append("\nInstall:  pip install PyQt6-WebEngine")
        lines.append(f"\nOr visit directly:\n{PERCHANCE_URL}")

        desc = QLabel("\n".join(lines))
        desc.setStyleSheet("color: #888; font-size: 9pt;")
        desc.setAlignment(Qt.AlignmentFlag.AlignCenter)
        desc.setWordWrap(True)
        desc.setTextInteractionFlags(Qt.TextInteractionFlag.TextSelectableByMouse)
        cl.addWidget(desc)

        layout.addWidget(container)

    # â”€â”€ Events â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    def showEvent(self, event):
        """Lazy-load the URL on first show to avoid heavy init at startup."""
        super().showEvent(event)
        if self._webview and not self._url_loaded:
            self._url_loaded = True
            from PyQt6.QtCore import QUrl

            url = PERCHANCE_URL
            if self.config_manager:
                url = getattr(self.config_manager, "perchance_url", url) or url
            self._webview.setUrl(QUrl(url))

    def _on_load_finished(self, ok: bool):
        """Inject ad-hiding JavaScript after the page finishes loading."""
        if not ok or not self._page:
            return
        script = self.service.get_ad_hide_script()
        if script:
            self._page.runJavaScript(script)
```

### `core/utils.py`

```python
# core/utils.py
"""Shared utility functions for the application."""

import os
import sys
import subprocess
from datetime import datetime
from pathlib import Path


def reveal_file_in_explorer(filepath: str) -> bool:
    """
    Open the system file explorer and select/highlight the given file.

    Platform behavior:
        Windows: explorer /select,<path>
        macOS:   open -R <path>
        Linux:   xdg-open <parent directory>

    Returns True if the command was launched, False on error or missing file.
    """
    filepath = os.path.normpath(os.path.abspath(filepath))
    if not os.path.exists(filepath):
        return False
    try:
        if sys.platform == "win32":
            subprocess.Popen(["explorer", f"/select,{filepath}"])
        elif sys.platform == "darwin":
            subprocess.Popen(["open", "-R", filepath])
        else:
            subprocess.Popen(["xdg-open", os.path.dirname(filepath)])
        return True
    except Exception:
        return False


def open_file(filepath: str) -> bool:
    """
    Open a file with the system's default application.

    Returns True if the command was launched, False on error or missing file.
    """
    filepath = os.path.normpath(os.path.abspath(filepath))
    if not os.path.exists(filepath):
        return False
    try:
        if sys.platform == "win32":
            os.startfile(filepath)
        elif sys.platform == "darwin":
            subprocess.Popen(["open", filepath])
        else:
            subprocess.Popen(["xdg-open", filepath])
        return True
    except Exception:
        return False


def save_generated_image(
    image_data: bytes,
    prompt: str,
    negative_prompt: str,
    model: str,
    size: str,
    seed: int,
    service: str,
) -> str:
    """Save generated image to the images/ directory with embedded EXIF metadata.

    Uses a timestamp-based filename (``YYYY-MM-DD_HH-MM-SS.jpg``) and embeds
    prompt / generation metadata into the EXIF ImageDescription tag when
    Pillow is available.

    Args:
        image_data:      Raw image bytes (any format Pillow can open).
        prompt:          Positive prompt text.
        negative_prompt: Negative prompt text (may be empty).
        model:           Model identifier string.
        size:            Size string, e.g. ``"1024x1024"``.
        seed:            Seed value used for generation.
        service:         Service name (e.g. ``"Pollinations"``, ``"Airforce"``).

    Returns:
        The absolute-ish path to the saved file as a string.
    """
    images_dir = Path("images")
    images_dir.mkdir(exist_ok=True)

    timestamp = datetime.now().strftime("%Y-%m-%d_%H-%M-%S")
    filepath = images_dir / f"{timestamp}.jpg"
    counter = 1
    while filepath.exists():
        filepath = images_dir / f"{timestamp}_{counter}.jpg"
        counter += 1

    metadata_str = (
        f"Prompt: {prompt} | "
        f"Negative: {negative_prompt or 'None'} | "
        f"Model: {model} | "
        f"Size: {size} | "
        f"Seed: {seed} | "
        f"Service: {service}"
    )

    saved_with_meta = False
    try:
        from PIL import Image
        import io

        img = Image.open(io.BytesIO(image_data))
        if img.mode in ("RGBA", "P", "LA"):
            img = img.convert("RGB")

        exif = img.getexif()
        exif[0x010E] = metadata_str        # ImageDescription
        exif[0x0131] = f"{service} AI"     # Software
        img.save(str(filepath), "JPEG", quality=95, exif=exif.tobytes())
        saved_with_meta = True
    except Exception:
        pass

    if not saved_with_meta:
        with open(filepath, "wb") as f:
            f.write(image_data)

    return str(filepath)
```

### `core/services/gallery_service.py`

```python
# core/services/gallery_service.py
"""
Gallery Service - Reads and caches image metadata from the generated images directory.
"""

from pathlib import Path
from dataclasses import dataclass
from typing import List, Dict

@dataclass
class ImageMetadata:
    filepath: str
    prompt: str
    service: str
    model: str
    timestamp: str


class GalleryService:
    def __init__(self):
        self._cache: Dict[str, tuple[float, ImageMetadata]] = {}
        self.images_dir = Path("images")
        self.images_dir.mkdir(exist_ok=True)
        
    def get_images(self, filter_service: str = "All") -> List[ImageMetadata]:
        images = []
        if not self.images_dir.exists():
            return images
            
        for p in self.images_dir.glob("*.jpg"):
            try:
                mtime = p.stat().st_mtime
                filepath_str = str(p)
                
                # Check cache mapping via modified time
                if filepath_str in self._cache and self._cache[filepath_str][0] == mtime:
                    meta = self._cache[filepath_str][1]
                else:
                    meta = self._parse_metadata(p)
                    self._cache[filepath_str] = (mtime, meta)
                    
                if filter_service == "All" or meta.service.lower() == filter_service.lower():
                    images.append(meta)
            except Exception:
                continue
                
        # Sort by filepath descending (newest timestamp first)
        images.sort(key=lambda x: x.filepath, reverse=True)
        return images
        
    def _parse_metadata(self, filepath: Path) -> ImageMetadata:
        prompt = ""
        service = "Unknown"
        model = "Unknown"
        timestamp = filepath.stem
        
        try:
            from PIL import Image
            with Image.open(filepath) as img:
                exif = img.getexif()
                if exif and 0x010E in exif:
                    meta_str = exif[0x010E]
                    parts = [p.strip() for p in meta_str.split("|")]
                    for part in parts:
                        if part.startswith("Prompt:"):
                            prompt = part[7:].strip()
                        elif part.startswith("Service:"):
                            service = part[8:].strip()
                        elif part.startswith("Model:"):
                            model = part[6:].strip()
        except Exception:
            pass
            
        return ImageMetadata(str(filepath), prompt, service, model, timestamp)
```

### `gui/widgets/media_panel.py`

```python
# gui/widgets/media_panel.py
"""
Media Panel - Secondary pane for generative imaging interfacing.
Provides tabbed navigation for different image generation APIs.
"""

from PyQt6.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, QPushButton,
    QStackedWidget, QLabel, QSizePolicy
)
from PyQt6.QtCore import Qt, pyqtSignal
from PyQt6.QtGui import QCursor
from gui.widgets.pollinations_page import PollinationsPage
from gui.widgets.airforce_page import AirforcePage
from gui.widgets.perchance_page import PerchancePage


class MediaPanel(QWidget):
    """Secondary pane with tabbed navigation for image generation API interfaces."""

    status_updated = pyqtSignal(str)

    TAB_NAMES = ["Gallery", "Pollinations", "Airforce", "Perchance"]

    ACTIVE_BG = "#1E88E5"
    ACTIVE_HOVER = "#2A9BF8"
    INACTIVE_BG = "#2a2a2a"
    INACTIVE_HOVER = "#3d3d3d"

    _TAB_ICONS = {"Gallery": "ðŸ–¼ï¸", "Pollinations": "ðŸŒ¸", "Airforce": "âœˆï¸", "Perchance": "ðŸŽ²"}
    _TAB_DESCS = {
        "Gallery": "Generated images will appear here",
        "Pollinations": "Pollinations AI image generation",
        "Airforce": "Airforce image generation API",
        "Perchance": "Perchance image generation",
    }

    def __init__(self, config_manager=None, parent=None):
        super().__init__(parent)
        self.config_manager = config_manager
        self.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Expanding)
        self._current_tab = 0
        self._tabs = []
        self._build_ui()
        self._load_active_tab()

    def _build_ui(self):
        layout = QVBoxLayout(self)
        layout.setContentsMargins(0, 0, 0, 0)
        layout.setSpacing(0)

        # --- Tab bar ---
        tab_bar = QWidget()
        tab_bar.setFixedHeight(34)
        tab_bar.setStyleSheet("background-color: #1a1a1a;")
        tab_layout = QHBoxLayout(tab_bar)
        tab_layout.setContentsMargins(0, 0, 0, 0)
        tab_layout.setSpacing(1)

        for i, name in enumerate(self.TAB_NAMES):
            btn = QPushButton(name)
            btn.setCursor(QCursor(Qt.CursorShape.PointingHandCursor))
            btn.setFocusPolicy(Qt.FocusPolicy.NoFocus)
            btn.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Expanding)
            btn.clicked.connect(lambda _, idx=i: self._switch_tab(idx))
            self._tabs.append(btn)
            tab_layout.addWidget(btn)

        layout.addWidget(tab_bar)

        # --- Stacked content area ---
        self._stack = QStackedWidget()
        self._stack.setStyleSheet("background-color: #2a2a2a; border: 1px solid #333;")

        from gui.widgets.gallery_page import GalleryPage
        for name in self.TAB_NAMES:
            if name == "Gallery":
                self.gallery_page = GalleryPage(self.config_manager)
                self.gallery_page.status_updated.connect(self.status_updated.emit)
                self._stack.addWidget(self.gallery_page)
            elif name == "Pollinations":
                self.pollinations_page = PollinationsPage(self.config_manager)
                self.pollinations_page.status_updated.connect(self.status_updated.emit)
                self._stack.addWidget(self.pollinations_page)
            elif name == "Airforce":
                self.airforce_page = AirforcePage(self.config_manager)
                self.airforce_page.status_updated.connect(self.status_updated.emit)
                self._stack.addWidget(self.airforce_page)
            elif name == "Perchance":
                self.perchance_page = PerchancePage(self.config_manager)
                self.perchance_page.status_updated.connect(self.status_updated.emit)
                self._stack.addWidget(self.perchance_page)
            else:
                self._stack.addWidget(self._create_page(name))

        layout.addWidget(self._stack, 1)
        self._update_tab_styles()

    def _create_page(self, name: str) -> QWidget:
        """Create a placeholder page for a tab."""
        page = QWidget()
        page_layout = QVBoxLayout(page)
        page_layout.setAlignment(Qt.AlignmentFlag.AlignCenter)

        icon = QLabel(self._TAB_ICONS.get(name, "ðŸ“„"))
        icon.setStyleSheet("font-size: 32pt;")
        icon.setAlignment(Qt.AlignmentFlag.AlignCenter)
        page_layout.addWidget(icon)

        title = QLabel(name)
        title.setStyleSheet("color: #666; font-size: 14pt; font-weight: bold;")
        title.setAlignment(Qt.AlignmentFlag.AlignCenter)
        page_layout.addWidget(title)

        desc = QLabel(self._TAB_DESCS.get(name, ""))
        desc.setStyleSheet("color: #444; font-size: 9pt;")
        desc.setAlignment(Qt.AlignmentFlag.AlignCenter)
        desc.setWordWrap(True)
        page_layout.addWidget(desc)

        return page

    def _switch_tab(self, index: int):
        """Switch to the specified tab index."""
        if index == self._current_tab:
            return
        self._current_tab = index
        self._stack.setCurrentIndex(index)
        self._update_tab_styles()
        
        current_widget = self._stack.widget(index)
        if hasattr(current_widget, "refresh"):
            current_widget.refresh()
            
        if self.config_manager:
            self.config_manager.media_active_tab = index
            self.config_manager.save()

    def _load_active_tab(self):
        """Restore the last active tab from config."""
        if self.config_manager:
            tab = getattr(self.config_manager, 'media_active_tab', 0)
            if 0 <= tab < len(self.TAB_NAMES):
                self._current_tab = tab
                self._stack.setCurrentIndex(tab)
                self._update_tab_styles()

    def _update_tab_styles(self):
        """Update tab button visual styles based on active selection."""
        for i, btn in enumerate(self._tabs):
            if i == self._current_tab:
                btn.setStyleSheet(f"""
                    QPushButton {{
                        background-color: {self.ACTIVE_BG};
                        color: #ffffff;
                        font-weight: bold;
                        font-size: 9pt;
                        border: none;
                        border-radius: 0px;
                        padding: 4px 8px;
                    }}
                    QPushButton:hover {{
                        background-color: {self.ACTIVE_HOVER};
                    }}
                """)
            else:
                btn.setStyleSheet(f"""
                    QPushButton {{
                        background-color: {self.INACTIVE_BG};
                        color: #888;
                        font-size: 9pt;
                        border: none;
                        border-radius: 0px;
                        padding: 4px 8px;
                    }}
                    QPushButton:hover {{
                        background-color: {self.INACTIVE_HOVER};
                        color: #fff;
                    }}
                """)
```

### `core/config.py`

```python
"""Configuration Manager for PyQt6 GUI Framework."""
import os
import json

_DEFAULTS = {
    "window_width": 1200,
    "window_height": 800,
    "theme": "dark",
    "current_service": "Gemini",
    "current_model": "Flash",
    "default_system_prompt": "You are a helpful AI assistant.",
    "splitter_sizes": [780, 420],
    "media_active_tab": 0,
    "gallery_page": 1,
    "gallery_filter": "All",
    "pollinations_positive_prompt": "",
    "pollinations_negative_prompt": "",
    "pollinations_model": "zimage",
    "pollinations_size": "1024x1024",
    "pollinations_seed": -1,
    "pollinations_last_image": "",
    "airforce_positive_prompt": "",
    "airforce_negative_prompt": "",
    "airforce_model": "grok-imagine",
    "airforce_last_image": "",
    "perchance_url": "https://perchance.org/a1481832-0a06-414f-baa6-616052e5f61d",
    "adblocker": {
        "blocked_domains": [
            "a.pub.network",
            "d.pub.network",
            "cdn.snigelweb.com",
            "googletagmanager.com",
            "cloudflareinsights.com",
            "static.criteo.net",
            "secure.quantserve.com",
            "fundingchoicesmessages.google.com"
        ],
        "hidden_selectors": [
            ".ad-providers-ctn-el",
            "#adCtn",
            "#pmLink"
        ]
    },
    "display_fields": {
        "core": True,
        "composition": True,
        "lighting": True,
        "style": True,
        "technical": True,
        "post_processing": True,
        "special_elements": True,
        "detailed_prompt": True,
        "grok_imagine_optimized": True,
        "gemini_optimized": True,
        "flux_optimized": True,
        "stable_diffusion_optimized": True,
        "video_optimized": True
    }
}

class ConfigManager:
    """Manages GUI configuration values and local gui_config.json persistence."""

    def __init__(self, config_file: str = "gui_config.json"):
        self.config_file = config_file
        self.__dict__.update(_DEFAULTS)
        self._load_config()

    def _load_config(self) -> None:
        if not os.path.exists(self.config_file):
            return
        try:
            with open(self.config_file, 'r') as f:
                config = json.load(f)
                for k in _DEFAULTS:
                    val = config.get(k, getattr(self, k))
                    if isinstance(val, dict) and isinstance(_DEFAULTS[k], dict):
                        merged = _DEFAULTS[k].copy()
                        merged.update(val)
                        setattr(self, k, merged)
                    else:
                        setattr(self, k, val)
                if "default_service" in config and "current_service" not in config:
                    self.current_service = config["default_service"]
                if "service_models" in config and "current_model" not in config:
                    self.current_model = config.get("service_models", {}).get(self.current_service, self.current_model)
        except Exception:
            pass

    def save(self) -> None:
        try:
            with open(self.config_file, 'w') as f:
                json.dump({k: getattr(self, k) for k in _DEFAULTS}, f, indent=2)
        except Exception:
            pass
```