### TASKS

We're moving the project to the next phase, which is an introduction to integration with various image generation APIs (the models themselves which generate the images).

## CURRENT PHASE TASK:

You have full creative liberty to design and implement any system which covers these goals:

1. Complete implementation of the Pollinations image generator in the media panel. Use env `POLLINATIONS_API_KEY`.

2. The Pollinations inline page has a row of buttons at the top (under the navigation tabs). These control the parameters for the API request the user will make to generate the image. These are the buttons:
[Generate]|[Positive Prompt][Negative Prompt][Model][Size][Seed]

Generate makes the call.
Positive/negative prompt are input fields where the user can write to. 
Model and Size use a dropdown selector that opens on hover, similar to our custom service/model selector button which opens on hover in the chat response panel. (specifically this code is in the `action_buttons_panel.py` file in CONTEXT)
Size sets both the width and height.

Here are the defaults to use, and the ranges:
Positive/Negative are empty, with placeholder text "Positive Prompt..." & "Negative Prompt..."
Models:
`flux`, `zimage`, `klein`, `klein-large`, `gptimage`. Use `zimage` as default.
Size: `1024x1024`, `1344x768`, `768x1344`. Use `1024x1024` as default.
Seed `-1` as default.

3. After the generation, the image is recieved and downloaded to a folder `images`. Use a similar naming convention for the filenames as we do chats e.g. `2026-02-20_15-41-48`. If possible, embed the prompt data and the service used into the metadata of the image file. Save as `.jpg`.

4. The image is displayed on the page, fully contained (never cropped) and using all available spacing.

5. Proper updates to the status bar (generating, errors, etc).

### NON-GOALS

These are OUT OF PHASE TASK:

1. API integration or service creations for "Airforce" or "Perchance"
2. Gallery image work
3. No image-to-image support, this is text-to-image integration

### STYLING REFERENCE

For consistent UI styling, I am going to be providing a reference of a future implementation which is for Perchance. Perchance is unique in that it will be loaded inside an iframe from an external website - irrelevant to your task.

What is relevant, is how the top bar and page looks. Please examine this css snippet, and from it, extrapolate the visual design for the Pollinations page, while omitting everything else not relevant to the visual design:

```reference
<!-- Flash-free dark-mode Perchance generator built for tight iframe embeds -->
<style>
  html, body {
    background-color: #121212 !important;
    color: #eee !important;
    margin: 0;
    padding: 0;
    font-family: Arial, sans-serif;
  }

  body * {
    background-color: inherit;
    color: inherit;
  }

  input, select, button {
    background-color: #1e1e1e !important;
    color: #eee !important;
    border: 1px solid #333 !important;
    border-radius: 3px;
    font-size: 12px;
    padding: 6px;
  }

  button {
    cursor: pointer;
    padding: 6px 8px;
  }

  #outputContainer {
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    gap: 4px;
    margin-top: 4px;
  }

  #outputContainer img {
    background-color: #121212 !important;
  }
</style>

<div style="max-width:100%; margin:0; padding:2px; font-size:12px;">

  <!-- Controls: All on one line -->
  <div style="padding:2px 0; margin:0; display:flex; gap:6px; align-items:center;">
    <button onclick="window.generate()">Generate</button>
    <!-- Added onkeydown event to trigger generate() on Enter press -->
    <input id="promptInput" placeholder="Positive Prompt..." style="flex:1;" onkeydown="if(event.key === 'Enter'){event.preventDefault(); window.generate();}">
    <input id="negativeInput" placeholder="Negative Prompt..." style="flex:1;" onkeydown="if(event.key === 'Enter'){event.preventDefault(); window.generate();}">
    <input id="focusInput" placeholder="Focus..." style="flex:1;" onkeydown="if(event.key === 'Enter'){event.preventDefault(); window.generate();}">
    <select id="styleSelect" style="min-width:82px;">
      <option value="None" [userStyle == "None" ? "selected"]>None</option>
      <option value="Cinematic" [userStyle == "Cinematic" ? "selected"]>Cinematic</option>
      <option value="Realistic" [userStyle == "Realistic" ? "selected"]>Realistic</option>
      <option value="Anime" [userStyle == "Anime" ? "selected"]>Anime</option>
      <option value="Sketch" [userStyle == "Sketch" ? "selected"]>Sketch</option>
    </select>
    <select id="resolutionSelect" style="min-width:82px;">
      <option value="768x768" [userResolution == "768x768" ? "selected"]>768x768</option>
      <option value="512x768" [userResolution == "512x768" ? "selected"]>512x768</option>
      <option value="768x512" [userResolution == "768x512" ? "selected"]>768x512</option>
    </select>
    <input id="seedInput" type="number" value="[userSeed]" title="Use -1 for random" style="width:64px; text-align:center;">
    <input id="guidanceInput" type="number" min="1" max="30" step="0.5" value="[userGuidanceScale]" title="Guidance Scale" style="width:56px; text-align:center;">
  </div>

  <!-- Output -->
  <div id="outputContainer">
    [output]
  </div>

</div>
```

### POLLINATIONS DEVELOPER GUIDE

# Pollinations.ai Image Generation API

**Base URL:** `https://gen.pollinations.ai`

## Authentication

Authentication is performed via API Key. Keys can be obtained from the dashboard.

*   **Secret Keys (`sk_`)**: Server-side only. No rate limits.
*   **Publishable Keys (`pk_`)**: Client-side. IP rate-limited (1 pollen/IP/hour).

**Methods:**
1.  **Header:** `Authorization: Bearer YOUR_API_KEY`
2.  **Query Parameter:** `?key=YOUR_API_KEY`

---

## Generate Image (GET)

Directly generates an image (or video) based on a prompt and streams the binary data back.

**Endpoint:** `GET /image/{prompt}`

### Path Parameters

| Parameter | Type | Required | Description |
| :--- | :--- | :--- | :--- |
| `prompt` | string | Yes | Text description of the image to generate. URL encoded. |

### Query Parameters

| Parameter | Type | Default | Description |
| :--- | :--- | :--- | :--- |
| `model` | string | `zimage` | The generation model. See **Available Models** below. |
| `width` | integer | `1024` | Image width in pixels. |
| `height` | integer | `1024` | Image height in pixels. |
| `seed` | integer | `-1` | Random seed for reproducibility. Set to `-1` for random. |
| `nologo` | boolean | `false` | *Implicit in logic, often available to remove watermarks if supported.* |
| `enhance` | boolean | `false` | Uses AI to improve the prompt before generation. |
| `negative_prompt` | string | "worst quality, blurry" | Elements to exclude from the generation. |
| `safe` | boolean | `false` | Enables safety content filters. |
| `image` | string | - | **Image-to-Image:** Reference image URL. Multiple URLs can be comma/pipe separated. |
| `quality` | string | `medium` | **`gptimage` only**. Options: `low`, `medium`, `high`, `hd`. |
| `transparent` | boolean | `false` | **`gptimage` only**. Generate with a transparent background. |

### Video Specific Query Parameters
*These apply only when using video models (`veo`, `seedance`).*

| Parameter | Type | Description |
| :--- | :--- | :--- |
| `duration` | integer | Seconds. `veo`: 4, 6, 8. `seedance`: 2-10. |
| `aspectRatio` | string | `16:9` or `9:16`. |
| `audio` | boolean | `veo` only. Generates accompanying audio. |

### Response
Returns the raw binary file:
*   `image/jpeg`
*   `image/png`
*   `video/mp4`

---

## Available Models

Use the `GET /image/models` endpoint for a programmatic list of current capabilities and pricing.

**Standard Image Models:**
*   `flux` (Default high quality)
*   `turbo`
*   `zimage`
*   `gptimage` (DALL-E 3 equivalent capabilities)
*   `gptimage-large`
*   `kontext`
*   `seedream` / `seedream-pro`
*   `nanobanana` / `nanobanana-pro`
*   `wan`
*   `klein` / `klein-large`
*   `ltx-2`

**Video Models:**
*   `veo` (Text-to-video)
*   `seedance` / `seedance-pro` (Text-to-video & Image-to-video)

---

## Usage Examples

### 1. Basic Generation
```bash
curl "https://gen.pollinations.ai/image/a%20futuristic%20cityscape?model=flux" \
  -H "Authorization: Bearer YOUR_API_KEY" \
  -o city.jpg
```

### 2. Advanced Configuration
Generate a 1280x720 image using a specific seed and prompt enhancement.

```bash
curl "https://gen.pollinations.ai/image/cyberpunk%20detective?model=flux&width=1280&height=720&seed=42&enhance=true" \
  -H "Authorization: Bearer YOUR_API_KEY" \
  -o detective.jpg
```

### 3. Image-to-Image (Vision)
Using an existing URL as a reference point.

```bash
curl "https://gen.pollinations.ai/image/make%20it%20watercolor?model=flux&image=https://example.com/original.jpg" \
  -H "Authorization: Bearer YOUR_API_KEY" \
  -o watercolor.jpg
```

---

### PROJECT 

A sophisticated desktop application that enhances image generation prompts using AI models and provides seamless integration with various image generation APIs with a modern PyQt6 GUI.

### DELIVERABLES

Please output a brief summary including any design choices, and the updated or new files where applicable. You may create new services or modules. If only small changes to existing files are required, please output them in

SEARCH: 

```
...stuff...
``` 

REPLACE:

```
...stuff...
``` 

style blocks.

### CONTEXT

## üéØ Focused Context (Agent-Selected)

**Project Root:** `image-prompter/`
**Files Included:** 7

---

### File Index

1. `gui/widgets/media_panel.py`
2. `gui/widgets/action_buttons_panel.py`
3. `core/services/base_service.py`
4. `gui/main_window.py`
5. `app/controller.py`
6. `core/services/nvidia_nim_service.py`
7. `core/config.py`

---

### `gui/widgets/media_panel.py`

```python
# gui/widgets/media_panel.py
"""
Media Panel - Secondary pane for generative imaging interfacing.
Provides tabbed navigation for different image generation APIs.
"""

from PyQt6.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, QPushButton,
    QStackedWidget, QLabel, QSizePolicy
)
from PyQt6.QtCore import Qt
from PyQt6.QtGui import QCursor


class MediaPanel(QWidget):
    """Secondary pane with tabbed navigation for image generation API interfaces."""

    TAB_NAMES = ["Gallery", "Pollinations", "Airforce", "Perchance"]

    ACTIVE_BG = "#1E88E5"
    ACTIVE_HOVER = "#2A9BF8"
    INACTIVE_BG = "#2a2a2a"
    INACTIVE_HOVER = "#3d3d3d"

    _TAB_ICONS = {"Gallery": "üñºÔ∏è", "Pollinations": "üå∏", "Airforce": "‚úàÔ∏è", "Perchance": "üé≤"}
    _TAB_DESCS = {
        "Gallery": "Generated images will appear here",
        "Pollinations": "Pollinations AI image generation",
        "Airforce": "Airforce image generation API",
        "Perchance": "Perchance image generation",
    }

    def __init__(self, parent=None):
        super().__init__(parent)
        self.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Expanding)
        self._current_tab = 0
        self._tabs = []
        self._build_ui()

    def _build_ui(self):
        layout = QVBoxLayout(self)
        layout.setContentsMargins(0, 0, 0, 0)
        layout.setSpacing(0)

        # --- Tab bar ---
        tab_bar = QWidget()
        tab_bar.setFixedHeight(34)
        tab_bar.setStyleSheet("background-color: #1a1a1a;")
        tab_layout = QHBoxLayout(tab_bar)
        tab_layout.setContentsMargins(0, 0, 0, 0)
        tab_layout.setSpacing(1)

        for i, name in enumerate(self.TAB_NAMES):
            btn = QPushButton(name)
            btn.setCursor(QCursor(Qt.CursorShape.PointingHandCursor))
            btn.setFocusPolicy(Qt.FocusPolicy.NoFocus)
            btn.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Expanding)
            btn.clicked.connect(lambda _, idx=i: self._switch_tab(idx))
            self._tabs.append(btn)
            tab_layout.addWidget(btn)

        layout.addWidget(tab_bar)

        # --- Stacked content area ---
        self._stack = QStackedWidget()
        self._stack.setStyleSheet("background-color: #2a2a2a; border: 1px solid #333;")

        for name in self.TAB_NAMES:
            self._stack.addWidget(self._create_page(name))

        layout.addWidget(self._stack, 1)
        self._update_tab_styles()

    def _create_page(self, name: str) -> QWidget:
        """Create a placeholder page for a tab."""
        page = QWidget()
        page_layout = QVBoxLayout(page)
        page_layout.setAlignment(Qt.AlignmentFlag.AlignCenter)

        icon = QLabel(self._TAB_ICONS.get(name, "üìÑ"))
        icon.setStyleSheet("font-size: 32pt;")
        icon.setAlignment(Qt.AlignmentFlag.AlignCenter)
        page_layout.addWidget(icon)

        title = QLabel(name)
        title.setStyleSheet("color: #666; font-size: 14pt; font-weight: bold;")
        title.setAlignment(Qt.AlignmentFlag.AlignCenter)
        page_layout.addWidget(title)

        desc = QLabel(self._TAB_DESCS.get(name, ""))
        desc.setStyleSheet("color: #444; font-size: 9pt;")
        desc.setAlignment(Qt.AlignmentFlag.AlignCenter)
        desc.setWordWrap(True)
        page_layout.addWidget(desc)

        return page

    def _switch_tab(self, index: int):
        """Switch to the specified tab index."""
        if index == self._current_tab:
            return
        self._current_tab = index
        self._stack.setCurrentIndex(index)
        self._update_tab_styles()

    def _update_tab_styles(self):
        """Update tab button visual styles based on active selection."""
        for i, btn in enumerate(self._tabs):
            if i == self._current_tab:
                btn.setStyleSheet(f"""
                    QPushButton {{
                        background-color: {self.ACTIVE_BG};
                        color: #ffffff;
                        font-weight: bold;
                        font-size: 9pt;
                        border: none;
                        border-radius: 0px;
                        padding: 4px 8px;
                    }}
                    QPushButton:hover {{
                        background-color: {self.ACTIVE_HOVER};
                    }}
                """)
            else:
                btn.setStyleSheet(f"""
                    QPushButton {{
                        background-color: {self.INACTIVE_BG};
                        color: #888;
                        font-size: 9pt;
                        border: none;
                        border-radius: 0px;
                        padding: 4px 8px;
                    }}
                    QPushButton:hover {{
                        background-color: {self.INACTIVE_HOVER};
                        color: #fff;
                    }}
                """)
```

### `gui/widgets/action_buttons_panel.py`

```python
# gui/widgets/action_buttons_panel.py
"""
Action Buttons Panel - Contains action buttons for the chat framework GUI.
"""

from PyQt6.QtWidgets import QWidget, QHBoxLayout, QPushButton, QSizePolicy, QFileDialog, QVBoxLayout, QGridLayout
from PyQt6.QtCore import pyqtSignal, Qt, QBuffer, QIODevice, QTimer, QEvent
from PyQt6.QtGui import QCursor



class ActionButtonsPanel(QWidget):
    """A panel containing all action buttons for the chat framework."""

    # Signals
    interrupt_signal = pyqtSignal()
    service_model_selected_signal = pyqtSignal(str, str)  # service, model
    select_file_signal = pyqtSignal(str, str)  # base64, filename
    send_signal = pyqtSignal()
    new_chat_signal = pyqtSignal()
    delete_chat_signal = pyqtSignal()
    delete_all_chats_signal = pyqtSignal()
    navigate_left_signal = pyqtSignal()
    navigate_right_signal = pyqtSignal()
    display_toggled_signal = pyqtSignal(dict)

    # Service to available models mapping
    SERVICE_MODELS = {
        "Gemini": ["Flash", "Pro"],
        "NVIDIA NIM": ["DeepSeek V3.2", "Kimi K2", "Kimi K2.5", "GLM-4.7", "GLM-5", "Qwen3.5-397B-A17B"]
    }

    # NVIDIA NIM models that support image/vision input
    NIM_VISION_MODELS = {"Kimi K2.5", "Qwen3.5-397B-A17B"}

    SERVICE_MODEL_OPTIONS = [(s, m) for s, models in SERVICE_MODELS.items() for m in models]

    def __init__(self, file_service, parent=None):
        super().__init__(parent)
        self.file_service = file_service
        self.file_service.files_updated.connect(self._update_file_controls_state)
        self.file_service.files_cleared.connect(self._update_file_controls_state)
        
        self._is_generating = False

        # Hover menu state
        self.active_dropdown = None
        self.hide_timer = QTimer()
        self.hide_timer.setInterval(250)
        self.hide_timer.timeout.connect(self._hide_dropdown)

        self.layout = QHBoxLayout(self)
        self.layout.setContentsMargins(0, 0, 0, 0)

        # Current selections
        self.current_service = "Gemini"
        self.current_model = "Flash"

        self._create_buttons()

    BLUE = ("#1E88E5", "#2A9BF8", "#1966C2")
    GREEN = ("#4CAF50", "#5CBF60", "#45A049")
    RED = ("#F44336", "#EF5350", "#D32F2F")
    GREY = ("#9E9E9E", "#BDBDBD", "#757575")
    ORANGE = ("#FF6B35", "#FF8C5A", "#E5562A")

    @staticmethod
    def _btn_style(colors, padding="8px"):
        bg, hover, pressed = colors
        return f"""
            QPushButton {{ background-color: {bg}; color: white; font-weight: bold; font-size: 10pt; border: 2px solid {bg}; border-radius: 4px; padding: {padding}; }}
            QPushButton:hover {{ background-color: {hover}; border-color: {hover}; }}
            QPushButton:pressed {{ background-color: {pressed}; border-color: {pressed}; }}
            QPushButton:disabled {{ background-color: #CCCCCC; color: #666666; border-color: #CCCCCC; }}
        """

    def _create_buttons(self):
        def make_btn(text, style, tooltip=""):
            btn = QPushButton(text)
            btn.setStyleSheet(style)
            btn.setCursor(QCursor(Qt.CursorShape.PointingHandCursor))
            btn.setFocusPolicy(Qt.FocusPolicy.NoFocus)
            if tooltip: btn.setToolTip(tooltip)
            return btn

        self.service_model_btn = make_btn(f"{self.current_service}:{self.current_model}", self._btn_style(self.BLUE))
        self.service_model_btn.installEventFilter(self)
        self.layout.addWidget(self.service_model_btn, stretch=2)

        self.display_btn = make_btn("Display", self._btn_style(self.GREY))
        self.display_btn.installEventFilter(self)
        self.layout.addWidget(self.display_btn, stretch=1)

        chat_mgmt_widget = QWidget()
        chat_mgmt_layout = QGridLayout(chat_mgmt_widget)
        chat_mgmt_layout.setContentsMargins(0, 0, 0, 0)
        chat_mgmt_layout.setSpacing(2)

        self.new_chat_btn = make_btn("üÜï", self._btn_style(self.GREEN, "4px"), tooltip="New Chat")
        self.new_chat_btn.clicked.connect(self.new_chat_signal.emit)
        chat_mgmt_layout.addWidget(self.new_chat_btn, 0, 0)

        self.delete_chat_btn = make_btn("üóëÔ∏è", self._btn_style(self.RED, "4px"), tooltip="Delete Chat")
        self.delete_chat_btn.clicked.connect(self.delete_chat_signal.emit)
        chat_mgmt_layout.addWidget(self.delete_chat_btn, 0, 1)

        self.nav_left_btn = make_btn("‚óÄ", "", tooltip="Previous Chat")
        self.nav_left_btn.clicked.connect(self.navigate_left_signal.emit)
        chat_mgmt_layout.addWidget(self.nav_left_btn, 1, 0)

        self.nav_right_btn = make_btn("‚ñ∂", "", tooltip="Next Chat")
        self.nav_right_btn.clicked.connect(self.navigate_right_signal.emit)
        chat_mgmt_layout.addWidget(self.nav_right_btn, 1, 1)
        
        self.update_navigation_buttons(False, False)

        chat_mgmt_widget.setSizePolicy(QSizePolicy.Policy.Preferred, QSizePolicy.Policy.Preferred)
        chat_mgmt_widget.setMaximumHeight(40)
        for btn in [self.new_chat_btn, self.delete_chat_btn, self.nav_left_btn, self.nav_right_btn]:
            btn.setSizePolicy(QSizePolicy.Policy.Preferred, QSizePolicy.Policy.Preferred)
        
        self.layout.addWidget(chat_mgmt_widget, stretch=1)

        select_file_container = QWidget()
        select_file_container.setSizePolicy(QSizePolicy.Policy.Preferred, QSizePolicy.Policy.Preferred)
        select_file_container_layout = QHBoxLayout(select_file_container)
        select_file_container_layout.setContentsMargins(0, 0, 0, 0)
        select_file_container_layout.setSpacing(0)
        
        self.select_file_btn = make_btn("Attach", self._btn_style(self.ORANGE))
        self.select_file_btn.setAcceptDrops(True)
        self.select_file_btn.dragEnterEvent = self._upload_drag_enter
        self.select_file_btn.dropEvent = self._upload_drop
        self.select_file_btn.clicked.connect(self._on_select_file_clicked)
        select_file_container_layout.addWidget(self.select_file_btn)
        
        self.clear_files_btn = make_btn("√ó", self._btn_style(self.RED, "2px 6px"), tooltip="Clear all files")
        self.clear_files_btn.setStyleSheet(self.clear_files_btn.styleSheet() + "QPushButton { min-width: 20px; max-width: 20px; min-height: 20px; max-height: 20px; font-size: 12pt; }")
        self.clear_files_btn.clicked.connect(self._on_clear_files_clicked)
        self.clear_files_btn.hide()
        self.clear_files_btn.setParent(select_file_container)
        self.clear_files_btn.raise_()
        
        self.select_file_btn.installEventFilter(self)
        self.layout.addWidget(select_file_container, stretch=2)

        self.send_btn = make_btn("Send", self._btn_style(self.GREEN))
        self.send_btn.clicked.connect(self._on_send_btn_clicked)
        self.send_btn.setEnabled(False)
        self.layout.addWidget(self.send_btn, stretch=2)

        # Set size policies
        for btn in [self.service_model_btn, self.display_btn, self.select_file_btn, self.send_btn]:
            btn.setSizePolicy(QSizePolicy.Policy.Preferred, QSizePolicy.Policy.Preferred)

        # Create unified dropdowns
        self._create_dropdowns()

    def _create_dropdowns(self):
        self._create_unified_dropdown()
        self._create_display_dropdown()

    def _create_unified_dropdown(self):
        """Create unified dropdown for service:model selection."""
        parent_window = self.window() or None
        dropdown = QWidget(parent_window)
        dropdown.setWindowFlags(Qt.WindowType.FramelessWindowHint | Qt.WindowType.Tool)
        dropdown.setAttribute(Qt.WidgetAttribute.WA_ShowWithoutActivating)
        dropdown.setStyleSheet("QWidget { background-color: #2a2a2a; border: 1px solid #555; border-radius: 4px; }")
        layout = QVBoxLayout(dropdown)
        layout.setContentsMargins(4, 4, 4, 4)
        layout.setSpacing(2)

        for service, model in self.SERVICE_MODEL_OPTIONS:
            option_btn = QPushButton(f"{service}:{model}")
            option_btn.setStyleSheet("""
                QPushButton { background-color: transparent; color: white; border: none; text-align: left; padding: 6px 12px; font-size: 9pt; }
                QPushButton:hover { background-color: #3d3d3d; }
            """)
            option_btn.clicked.connect(lambda checked, s=service, m=model: self._on_service_model_selected(s, m))
            layout.addWidget(option_btn)

        dropdown.adjustSize()
        dropdown.hide()
        dropdown.installEventFilter(self)
        self.unified_dropdown = dropdown

    def _create_display_dropdown(self):
        """Create dropdown for display field toggling."""
        parent_window = self.window() or None
        dropdown = QWidget(parent_window)
        dropdown.setWindowFlags(Qt.WindowType.FramelessWindowHint | Qt.WindowType.Tool)
        dropdown.setAttribute(Qt.WidgetAttribute.WA_ShowWithoutActivating)
        dropdown.setStyleSheet("QWidget { background-color: #2a2a2a; border: 1px solid #555; border-radius: 4px; }")
        layout = QVBoxLayout(dropdown)
        layout.setContentsMargins(4, 4, 4, 4)
        layout.setSpacing(2)

        self.display_checkboxes = {}
        fields = [
            "core", "composition", "lighting", "style", "technical", 
            "post_processing", "special_elements", "detailed_prompt",
            "grok_imagine_optimized", "gemini_optimized", "flux_optimized", 
            "stable_diffusion_optimized", "video_optimized", "ooc_note"
        ]
        
        self.display_fields = {}
        
        for field in fields:
            btn = QPushButton(f"‚òë {field}")
            btn.setStyleSheet("""
                QPushButton { background-color: transparent; color: white; border: none; text-align: left; padding: 4px 12px; font-size: 9pt; }
                QPushButton:hover { background-color: #3d3d3d; }
            """)
            btn.clicked.connect(lambda checked, f=field: self._on_display_toggle(f))
            layout.addWidget(btn)
            self.display_checkboxes[field] = btn

        dropdown.adjustSize()
        dropdown.hide()
        dropdown.installEventFilter(self)
        self.display_dropdown = dropdown

    def set_display_fields(self, fields: dict):
        self.display_fields = fields.copy()
        if hasattr(self, 'display_checkboxes'):
            for field, btn in self.display_checkboxes.items():
                is_checked = self.display_fields.get(field, True)
                btn.setText(f"{'‚òë' if is_checked else '‚òê'} {field}")

    def _on_display_toggle(self, field: str):
        current = self.display_fields.get(field, True)
        self.display_fields[field] = not current
        self.set_display_fields(self.display_fields)
        self.display_toggled_signal.emit(self.display_fields)


    def eventFilter(self, obj, event):
        """Handle hover events for dropdown menus and clear button positioning."""
        et = event.type()

        # Handle select_file_btn resize to reposition clear button
        if hasattr(self, 'select_file_btn') and obj == self.select_file_btn and et == QEvent.Type.Resize:
            self._update_clear_button_position()

        # Enter events
        if et == QEvent.Type.Enter:
            if obj == self.service_model_btn:
                self._show_dropdown("unified")
            elif obj == self.display_btn:
                self._show_dropdown("display")
            elif obj in [self.unified_dropdown, self.display_dropdown]:
                self.hide_timer.stop()

        # Leave events
        elif et == QEvent.Type.Leave:
            if obj in [self.service_model_btn, self.unified_dropdown, self.display_btn, self.display_dropdown]:
                self.hide_timer.start()

        return super().eventFilter(obj, event)
    
    def _update_clear_button_position(self):
        """Update clear button position to top-right of select_file_btn."""
        if not self.clear_files_btn.isVisible():
            return
        btn_rect = self.select_file_btn.geometry()
        clear_btn_size = 20
        # Position at top-right with small offset
        x = btn_rect.right() - clear_btn_size - 4
        y = btn_rect.top() + 4
        self.clear_files_btn.setGeometry(x, y, clear_btn_size, clear_btn_size)

    def _show_dropdown(self, dropdown_type):
        if self._is_generating: return
        self.hide_timer.stop()
        
        target_dropdown = self.unified_dropdown if dropdown_type == "unified" else self.display_dropdown
        target_btn = self.service_model_btn if dropdown_type == "unified" else self.display_btn
        
        if self.active_dropdown and self.active_dropdown != target_dropdown:
            self.active_dropdown.hide()
        if self.active_dropdown == target_dropdown: return

        self.active_dropdown = target_dropdown
        btn_global_pos = target_btn.mapToGlobal(target_btn.rect().topLeft())
        target_dropdown.move(btn_global_pos.x(), btn_global_pos.y() - target_dropdown.height() - 2)
        target_dropdown.show()
        target_dropdown.raise_()

    def _hide_dropdown(self):
        if self.active_dropdown:
            self.active_dropdown.hide()
            self.active_dropdown = None
            self.active_button = None

    def _on_service_model_selected(self, service: str, model: str):
        """Handle unified service:model selection."""
        self.current_service = service
        self.current_model = model
        self.service_model_btn.setText(f"{service}:{model}")
        self._update_file_controls_state()
        
        self.service_model_selected_signal.emit(service, model)
        self._hide_dropdown()

    def _update_file_controls_state(self):
        """Update state of file controls based on current service and file selection."""
        # Disable file selection for NVIDIA NIM models that don't support vision
        no_file_support = (self.current_service == "NVIDIA NIM"
                           and self.current_model not in self.NIM_VISION_MODELS)
        has_files = self.file_service.has_files()
        
        self.select_file_btn.setEnabled(not no_file_support and not self._is_generating)
        
        if self._is_generating:
            # During generation, this is the Cancel button, so keep it enabled
            self.send_btn.setEnabled(True)
        elif has_files:
            # Disable Send button if files attached and model doesn't support them
            self.send_btn.setEnabled(not no_file_support)
        
        # Show/hide clear button based on file state
        self.clear_files_btn.setVisible(has_files)
        self.clear_files_btn.setEnabled(not self._is_generating)
        if has_files:
            self._update_clear_button_position()

    def _on_send_btn_clicked(self):
        if self._is_generating:
            self.interrupt_signal.emit()
        else:
            self.send_signal.emit()

    def set_generating_state(self, state: bool):
        """Enable or disable actions based on whether AI is currently generating."""
        self._is_generating = state
        self.new_chat_btn.setEnabled(not state)
        self.delete_chat_btn.setEnabled(not state)
        self.service_model_btn.setEnabled(not state)
        self.display_btn.setEnabled(not state)
        
        if state:
            self._hide_dropdown()
            self.update_navigation_buttons(False, False)
            self.send_btn.setText("Cancel")
            self.send_btn.setStyleSheet(self._btn_style(self.RED))
            grey_style = self._btn_style(self.GREY, "4px")
            self.new_chat_btn.setStyleSheet(grey_style)
            self.delete_chat_btn.setStyleSheet(grey_style)
        else:
            self.send_btn.setText("Send")
            self.send_btn.setStyleSheet(self._btn_style(self.GREEN))
            self.new_chat_btn.setStyleSheet(self._btn_style(self.GREEN, "4px"))
            self.delete_chat_btn.setStyleSheet(self._btn_style(self.RED, "4px"))
            
        self._update_file_controls_state()

    def update_text_action_buttons(self, has_content: bool):
        """
        Update Send button enabled state based on input text content.

        Args:
            has_content: True if input field has non-whitespace text, False otherwise
        """
        if self._is_generating:
            self.send_btn.setEnabled(True)
            return

        # Only update if no files attached - files take precedence
        if not self.file_service.has_files():
            self.send_btn.setEnabled(has_content)

    def _on_select_file_clicked(self):
        paths, _ = QFileDialog.getOpenFileNames(self, "Select file(s)", "", "All Files (*)")
        for path in paths: self.file_service.load_file_from_path(path)
        if files := self.file_service.get_files():
            self.select_file_signal.emit(files[0][0] or "", "")
    
    def _on_clear_files_clicked(self):
        """Handle clear files button click."""
        self.file_service.clear_files()
        self.select_file_signal.emit("", "")

    def _upload_drag_enter(self, event):
        """Handle drag enter event for select file button."""
        md = event.mimeData()
        if md.hasUrls():
            for url in md.urls():
                if url.isLocalFile():
                    event.acceptProposedAction()
                    return
        if md.hasImage():
            event.acceptProposedAction()
            return
        event.ignore()

    def _upload_drop(self, event):
        """Handle drop event for upload button - supports multiple files."""
        try:
            md = event.mimeData()
            if md.hasUrls():
                files_loaded = False
                for url in md.urls():
                    if url.isLocalFile():
                        path = url.toLocalFile()
                        if self.file_service.load_file_from_path(path):
                            files_loaded = True
                if files_loaded:
                    # Emit signal with first file's data for backward compatibility
                    files = self.file_service.get_files()
                    if files:
                        b64, _ = files[0]
                        self.select_file_signal.emit(b64 or "", "")
                    event.acceptProposedAction()
                    return
            elif md.hasImage():
                img = md.imageData()
                if img:
                    buf = QBuffer()
                    buf.open(QIODevice.OpenModeFlag.WriteOnly)
                    img.save(buf, "PNG")
                    if self.file_service.load_file_from_data(bytes(buf.data()), "clipboard"):
                        if files := self.file_service.get_files():
                            self.select_file_signal.emit(files[0][0] or "", "")
                        event.acceptProposedAction()
                        return
        except Exception:
            pass
        event.ignore()

    def set_service_model_text(self, service: str, model: str):
        """Set the text of the unified service:model button."""
        self.current_service = service
        self.current_model = model
        self.service_model_btn.setText(f"{service}:{model}")
        self._update_file_controls_state()

    def update_navigation_buttons(self, can_go_left: bool, can_go_right: bool):
        for btn, enabled in [(self.nav_left_btn, can_go_left), (self.nav_right_btn, can_go_right)]:
            btn.setEnabled(enabled)
            btn.setStyleSheet(self._btn_style(self.BLUE if enabled else self.GREY, "4px"))
```

### `core/services/base_service.py`

```python
# core/services/base_service.py
from PyQt6.QtCore import QObject, pyqtSignal, QThread

class BaseAIWorker(QThread):
    finished = pyqtSignal(str)
    error = pyqtSignal(str)
    chunk = pyqtSignal(str)
    thinking_chunk = pyqtSignal(str)

    def __init__(self):
        super().__init__()
        self._is_cancelled = False

    def cancel(self):
        self._is_cancelled = True

    def _emit_result(self, full_response: str, full_thinking: str):
        """Emit combined thinking+response result or error if empty."""
        if full_response or full_thinking:
            combined = f"<thinking>\n{full_thinking}\n</thinking>\n\n" if full_thinking else ""
            self.finished.emit(combined + full_response)
        else:
            self.error.emit("API returned empty response.")

class BaseAIService(QObject):
    """Abstract base class establishing the interface for AI Services."""
    response_generated = pyqtSignal(str)
    status_updated = pyqtSignal(str)
    error_occurred = pyqtSignal(str)
    chunk_received = pyqtSignal(str)
    thinking_chunk_received = pyqtSignal(str)
    stream_complete = pyqtSignal(str)

    def generate_response(self, system_prompt: str, user_input: str, model_name: str, conversation_history: list = None, **kwargs):
        raise NotImplementedError("generate_response must be implemented by subclasses.")

    def _start_worker(self, worker: BaseAIWorker):
        self.worker = worker
        self.worker.finished.connect(self._handle_success)
        self.worker.finished.connect(self.stream_complete.emit)
        self.worker.error.connect(self._handle_error)
        self.worker.chunk.connect(self.chunk_received.emit)
        self.worker.thinking_chunk.connect(self.thinking_chunk_received.emit)
        self.worker.finished.connect(self.worker.deleteLater)
        self.worker.error.connect(self.worker.deleteLater)
        if hasattr(self.worker, 'retry_with_new_key'):
            self.worker.retry_with_new_key.connect(getattr(self, '_handle_retry', lambda e, c: None))
            self.worker.retry_with_new_key.connect(self.worker.deleteLater)
        self.worker.start()

    def _handle_success(self, response_text: str):
        self.response_generated.emit(response_text)
        self.status_updated.emit("Response received.")

    def _handle_error(self, error_message: str):
        self.status_updated.emit(f"API Error: {error_message}")
        self.error_occurred.emit(error_message)

    def cancel_generation(self):
        if hasattr(self, 'worker') and self.worker and self.worker.isRunning():
            self.worker.cancel()
```

### `gui/main_window.py`

```python
# gui/main_window.py
"""
Main Window GUI - Constructs the main application window with a split-pane layout.
Primary chat pane (left) with scoped footer, secondary media pane (right) with tabs.
"""
from PyQt6.QtWidgets import QApplication, QMainWindow, QWidget, QVBoxLayout, QLabel, QSplitter
from PyQt6.QtCore import pyqtSignal, Qt
from PyQt6.QtGui import QIcon, QShortcut, QKeySequence
from gui.widgets.action_buttons_panel import ActionButtonsPanel
from gui.widgets.input_panel import InputPanel
from gui.widgets.response_panel import ResponsePanel
from gui.widgets.media_panel import MediaPanel


class MainWindow(QMainWindow):
    """Main application window with asymmetrical split-pane layout."""

    status_signal = pyqtSignal(str)

    def __init__(self, file_service):
        super().__init__()
        self.file_service = file_service
        self.file_service.files_updated.connect(self._on_files_updated)
        self.file_service.status_updated.connect(self.status_signal.emit)
        self.file_service.files_cleared.connect(self._on_files_cleared)
        self.setWindowTitle("PyQt6 Chat Framework")
        self.setWindowIcon(QIcon("assets/icons/app_icon.ico"))
        self.setStyleSheet("""
            QMainWindow, QStatusBar { background-color: #1a1a1a; }
            QLabel { color: #ffffff; font-family: Arial; }
            QPushButton { background-color: #3d3d3d; color: #ffffff; border: 1px solid #333; padding: 8px; font-family: Arial; font-size: 9pt; border-radius: 4px; }
            QPushButton:hover { background-color: #4d4d4d; }
            QPushButton:pressed { background-color: #2d2d2d; }
            QTextEdit { background-color: #1e1e1e; color: #ffffff; border: 1px solid #333; font-family: Consolas; font-size: 9pt; }
            QStatusBar { color: #888888; font-size: 8pt; }
            QSplitter::handle {
                background-color: #333333;
            }
            QSplitter::handle:hover {
                background-color: #4d4d4d;
            }
            QSplitter::handle:pressed {
                background-color: #1E88E5;
            }
        """)

        central = QWidget()
        self.setCentralWidget(central)
        main_layout = QVBoxLayout(central)
        main_layout.setContentsMargins(10, 10, 10, 5)
        main_layout.setSpacing(5)

        # --- Horizontal splitter: chat pane | media pane ---
        self.splitter = QSplitter(Qt.Orientation.Horizontal)
        self.splitter.setHandleWidth(5)
        self.splitter.setChildrenCollapsible(False)

        # Left pane: Chat (response + input + action buttons)
        chat_pane = QWidget()
        chat_pane.setMinimumWidth(400)
        chat_pane_layout = QVBoxLayout(chat_pane)
        chat_pane_layout.setContentsMargins(0, 0, 0, 0)
        chat_pane_layout.setSpacing(10)
        self._build_chat_pane(chat_pane_layout)
        self.splitter.addWidget(chat_pane)

        # Right pane: Media (tabbed image generation interface)
        self.media_panel = MediaPanel()
        self.media_panel.setMinimumWidth(280)
        self.splitter.addWidget(self.media_panel)

        # Default asymmetric split ~65/35, stretch ratio 3:2
        self.splitter.setSizes([780, 420])
        self.splitter.setStretchFactor(0, 3)
        self.splitter.setStretchFactor(1, 2)

        main_layout.addWidget(self.splitter, 1)

        # --- Status bar ---
        self.status_label = QLabel("Ready")
        self.status_label.setStyleSheet("color: #888; font-size: 8pt;")
        self.status_signal.connect(self.status_label.setText)
        main_layout.addWidget(self.status_label, 0, Qt.AlignmentFlag.AlignLeft)

        self.status_signal.emit("Ready")
        self._setup_shortcuts()

    def _setup_shortcuts(self):
        """Set up global keyboard shortcuts."""
        search_shortcut = QShortcut(QKeySequence.StandardKey.Find, self)
        search_shortcut.activated.connect(self.response_panel.show_search)

        nav_left_shortcut = QShortcut(QKeySequence("Ctrl+Left"), self)
        nav_left_shortcut.activated.connect(lambda: self.action_buttons_panel.navigate_left_signal.emit())

        nav_right_shortcut = QShortcut(QKeySequence("Ctrl+Right"), self)
        nav_right_shortcut.activated.connect(lambda: self.action_buttons_panel.navigate_right_signal.emit())

        delete_all_shortcut = QShortcut(QKeySequence("Ctrl+D"), self)
        delete_all_shortcut.activated.connect(lambda: self.action_buttons_panel.delete_all_chats_signal.emit())

    def _build_chat_pane(self, layout):
        """Build the primary chat pane with response, input, and action buttons."""
        self.main_panel_layout = layout

        # Response panel (takes all available vertical space)
        self.response_panel = ResponsePanel()
        layout.addWidget(self.response_panel)

        # Input panel (scoped footer - dynamic height)
        self.input_panel = InputPanel()
        layout.addWidget(self.input_panel)

        # Action buttons panel (scoped footer - fixed height)
        self.action_buttons_panel = ActionButtonsPanel(self.file_service)
        layout.addWidget(self.action_buttons_panel)

        self.input_panel.text_content_changed_signal.connect(self.action_buttons_panel.update_text_action_buttons)

        layout.setStretchFactor(self.response_panel, 1)
        layout.setStretchFactor(self.input_panel, 0)
        layout.setStretchFactor(self.action_buttons_panel, 0)

    def _on_files_cleared(self):
        self.action_buttons_panel.select_file_signal.emit("", "")

    def _on_files_updated(self, filenames):
        """Handle files updated signal - update status bar with file list."""
        if not filenames:
            self.status_signal.emit("No files selected.")
            return
        if len(filenames) == 1:
            self.status_signal.emit(f"File ready: {filenames[0]}")
        elif len(filenames) <= 3:
            self.status_signal.emit(f"Files ready: {', '.join(filenames)}")
        else:
            self.status_signal.emit(f"Files ready: {', '.join(filenames[:3])}... ({len(filenames)} total)")

    def keyPressEvent(self, event):
        """Handle keyboard events - Ctrl+V for clipboard paste."""
        modifiers = event.modifiers()
        if (modifiers & Qt.KeyboardModifier.ControlModifier) and event.key() == Qt.Key.Key_V:
            clipboard = QApplication.clipboard()
            mime_data = clipboard.mimeData()
            if mime_data.hasImage():
                img = clipboard.image()
                if not img.isNull():
                    from PyQt6.QtCore import QBuffer, QIODevice
                    buf = QBuffer()
                    buf.open(QIODevice.OpenModeFlag.WriteOnly)
                    img.save(buf, "PNG")
                    self.file_service.load_file_from_data(bytes(buf.data()), "clipboard.png")
                    return
        super().keyPressEvent(event)

    def get_input_text(self) -> str:
        """Get the text from the input text edit."""
        return self.input_panel.get_input_text()

    def closeEvent(self, event):
        """Handle window close event to save window size and splitter state."""
        if getattr(self, 'config_manager', None):
            self.config_manager.window_width = self.width()
            self.config_manager.window_height = self.height()
            self.config_manager.splitter_sizes = self.splitter.sizes()
            self.config_manager.save()
        event.accept()
```

### `app/controller.py`

```python
# app/controller.py
"""Application Controller - Orchestrates application logic and connects GUI to services."""
import sys
import base64
from pathlib import Path
from PyQt6.QtWidgets import QApplication, QMessageBox
from PyQt6.QtCore import pyqtSignal, QObject, QTimer

from gui.main_window import MainWindow
from core.config import ConfigManager
from core.prompt_manager import PromptManager
from core.services.file_service import FileService
from core.services.gemini_service import GeminiService
from core.services.nvidia_nim_service import NvidiaNimService
from core.services.chat_history_service import ChatHistoryService

DARK_MSGBOX_STYLE = """
    QMessageBox, QLabel { background-color: #1a1a1a; color: #ffffff; }
    QPushButton { background-color: #3d3d3d; color: #ffffff; border: 1px solid #333; padding: 8px; border-radius: 4px; }
    QPushButton:hover { background-color: #4d4d4d; }
"""


class ApplicationController(QObject):
    """Orchestrates the application logic, connecting GUI signals to backend services."""
    append_user_message_signal = pyqtSignal(str, object)
    clear_input_signal = pyqtSignal()
    clear_response_signal = pyqtSignal()

    def __init__(self, app: QApplication):
        super().__init__()
        self.app = app
        self.config_manager = ConfigManager()
        self.prompt_manager = PromptManager()

        self.file_service = FileService()
        self.services = {"Gemini": GeminiService(), "NVIDIA NIM": NvidiaNimService()}
        self.chat_history_service = ChatHistoryService()

        self.selected_service = getattr(self.config_manager, "current_service", "Gemini")
        self.selected_model = getattr(self.config_manager, "current_model", "Flash")

        self.main_window = MainWindow(self.file_service)
        self.main_window.config_manager = self.config_manager

        for service in self.services.values():
            service.response_generated.connect(self._handle_ai_response)
            service.status_updated.connect(self.main_window.status_signal.emit)
            service.chunk_received.connect(self._handle_stream_chunk)
            service.thinking_chunk_received.connect(self._handle_thinking_chunk)
            service.stream_complete.connect(self._handle_stream_complete)
            service.error_occurred.connect(self._handle_generation_error)

        self._is_streaming = False
        self._is_generating = False

        self.chat_history_service.chat_loaded.connect(self._handle_chat_loaded)
        self._connect_signals()
        self._initialize_ui()

    def handle_display_toggled(self, new_fields: dict):
        self.config_manager.display_fields = new_fields.copy()
        self.config_manager.save()
        self.main_window.response_panel.display_fields = new_fields.copy()
        
        # Re-render chat natively so UI instantly updates based on new toggles
        current_chat_id = self.chat_history_service.get_current_chat_id()
        if current_chat_id:
            chat_data = {"messages": self.chat_history_service.get_current_messages()}
            self._handle_chat_loaded(chat_data)

    def _connect_signals(self):
        abp = self.main_window.action_buttons_panel
        ip = self.main_window.input_panel

        abp.select_file_signal.connect(self.handle_select_file)
        abp.send_signal.connect(self.handle_send)
        abp.display_toggled_signal.connect(self.handle_display_toggled)
        abp.interrupt_signal.connect(self.handle_interrupt)
        abp.service_model_selected_signal.connect(self.handle_service_model_selected)
        abp.new_chat_signal.connect(self.handle_new_chat)
        abp.delete_chat_signal.connect(self.handle_delete_chat)
        abp.delete_all_chats_signal.connect(self.handle_delete_all_chats)
        abp.navigate_left_signal.connect(self.handle_navigate_left)
        abp.navigate_right_signal.connect(self.handle_navigate_right)

        ip.send_signal.connect(self.handle_send)
        ip.navigate_left_signal.connect(self.handle_navigate_left)
        ip.navigate_right_signal.connect(self.handle_navigate_right)

        self.append_user_message_signal.connect(self.main_window.response_panel.append_user_message)
        self.clear_input_signal.connect(lambda: ip.set_input_text(""))
        self.clear_response_signal.connect(self.main_window.response_panel.clear)

    def _initialize_ui(self):
        self._update_service_model_button_label()
        
        # Init display fields explicitly
        if hasattr(self.config_manager, "display_fields"):
            self.main_window.action_buttons_panel.set_display_fields(self.config_manager.display_fields)
            self.main_window.response_panel.display_fields = self.config_manager.display_fields
            
        self.chat_history_service.create_new_chat()
        self._update_navigation_buttons()

    def run(self):
        self.main_window.resize(self.config_manager.window_width, self.config_manager.window_height)
        if hasattr(self.config_manager, 'splitter_sizes'):
            self.main_window.splitter.setSizes(self.config_manager.splitter_sizes)
        self.main_window.show()
        sys.exit(self.app.exec())

    # --- Action Handlers ---

    def handle_select_file(self, b64_data: str, filename: str):
        if not self.file_service.has_files():
            self.update_status("No files selected.")

    def handle_interrupt(self):
        if self._is_generating:
            self.update_status("Interrupting generation...")
            active_service = self._get_active_service()
            if hasattr(active_service, 'cancel_generation'):
                active_service.cancel_generation()

    def handle_send(self):
        user_input = self.get_input_text()
        if not user_input.strip() and not self.file_service.has_files():
            return self.update_status("Error: Input cannot be empty.")
        self._process_message(user_input)

    def handle_service_model_selected(self, service: str, model: str):
        self.selected_service = service
        self.selected_model = model
        self.config_manager.current_service = service
        self.config_manager.current_model = model
        self.config_manager.save()
        self._update_service_model_button_label()
        self.update_status(f"Selected: {service} - {model}")

    def handle_new_chat(self):
        if self._is_generating:
            return self.update_status("Cannot create a new chat while generating.")
        if self.chat_history_service.get_current_messages():
            self.chat_history_service.save_current_chat()
        self.chat_history_service.create_new_chat()
        self.clear_response_signal.emit()
        self.clear_input_signal.emit()
        self.update_status("New chat created.")
        self._update_navigation_buttons()

    def handle_delete_chat(self):
        if self._is_generating:
            return self.update_status("Cannot delete chat while generating.")
        current_chat_id = self.chat_history_service.get_current_chat_id()
        if not current_chat_id:
            return self.update_status("No chat to delete.")
        if not self._confirm_dialog("Delete Chat", "Are you sure you want to delete this chat?"):
            return

        if self.chat_history_service.delete_chat(current_chat_id):
            adjacent_id = (self.chat_history_service.get_adjacent_chat_id("left") or
                           self.chat_history_service.get_adjacent_chat_id("right"))
            if adjacent_id:
                self.chat_history_service.load_chat(adjacent_id)
                self.update_status(f"Chat deleted. Loaded chat: {adjacent_id}")
            else:
                self.chat_history_service.create_new_chat()
                self.clear_response_signal.emit()
                self.update_status("Chat deleted. New chat created.")
        else:
            self.update_status("Failed to delete chat.")
        self._update_navigation_buttons()

    def handle_delete_all_chats(self):
        if self._is_generating:
            return self.update_status("Cannot delete all chats while generating.")
        chat_files = self.chat_history_service.get_chat_files()
        if not chat_files:
            return self.update_status("No chats to delete.")
        if not self._confirm_dialog("Delete All Chats", f"Are you sure you want to delete all {len(chat_files)} chats?"):
            return

        if self.chat_history_service.delete_all_chats():
            self.chat_history_service.clear_current_chat()
            self.chat_history_service.create_new_chat()
            self.clear_response_signal.emit()
            self.update_status("All chats deleted. New chat created.")
        else:
            self.update_status("Failed to delete some chats.")
        self._update_navigation_buttons()

    def handle_navigate_left(self):
        self._handle_navigation("left")

    def handle_navigate_right(self):
        self._handle_navigation("right")

    # --- Internal Logic ---

    def _process_message(self, user_input: str):
        if self._is_generating:
            return self.update_status("Please wait for the current response to finish.")

        has_files = self.file_service.has_files()
        if not self.chat_history_service.get_current_chat_id():
            self.chat_history_service.create_new_chat()

        file_data_list, filenames_list = [], None
        if has_files:
            for file_b64, filename in self.file_service.get_files():
                file_data_list.append({
                    'base64': file_b64, 'filename': filename,
                    'mime_type': self._get_mime_type(filename),
                    'file_size': len(base64.b64decode(file_b64))
                })
            if file_data_list:
                filenames_list = [f['filename'] for f in file_data_list]

        display_text = user_input or (
            f"Process file{'s' if len(file_data_list) > 1 else ''}: {', '.join(filenames_list)}"
            if filenames_list else ""
        )

        self.append_user_message_signal.emit(display_text, filenames_list)
        self.chat_history_service.add_message("user", display_text, filenames_list)
        self.clear_input_signal.emit()

        active_service = self._get_active_service()
        self._set_generating_state(True)

        kwargs = {}
        if file_data_list:
            kwargs['files_data'] = file_data_list
            
        has_image = False
        if file_data_list:
            has_image = any(f['mime_type'].startswith('image/') for f in file_data_list)
            
        system_prompt = self.prompt_manager.get_prompt(self.selected_service, self.selected_model, has_image)

        active_service.generate_response(
            system_prompt, user_input,
            self.selected_model, self.chat_history_service.get_current_messages()[:-1], **kwargs
        )

        if has_files:
            self.file_service.clear_files()

    def _handle_ai_response(self, response_text: str):
        if not self._is_streaming:
            self.main_window.response_panel.append_assistant_message(response_text)
        self.chat_history_service.add_message("assistant", response_text)
        if chat_id := self.chat_history_service.save_current_chat():
            self.update_status(f"Chat saved: {chat_id}")
        self._is_streaming = False
        self._set_generating_state(False)

    def _handle_generation_error(self, error_message: str):
        self._set_generating_state(False)
        if self._is_streaming:
            self._is_streaming = False
            self.main_window.response_panel.end_stream()

    def _set_generating_state(self, state: bool):
        self._is_generating = state
        self.main_window.action_buttons_panel.set_generating_state(state)
        if not state:
            self._update_navigation_buttons()
            self.main_window.action_buttons_panel.update_text_action_buttons(bool(self.get_input_text().strip()))

    def _handle_stream_chunk(self, chunk: str):
        if not self._is_streaming:
            self._is_streaming = True
            self.main_window.response_panel.start_stream()
        self.main_window.response_panel.append_stream_chunk(chunk)

    def _handle_thinking_chunk(self, chunk: str):
        if not self._is_streaming:
            self._is_streaming = True
            self.main_window.response_panel.start_stream()
        self.main_window.response_panel.append_thinking_chunk(chunk)

    def _handle_stream_complete(self, full_response: str):
        self.main_window.response_panel.end_stream()

    def _handle_navigation(self, direction: str):
        if self._is_generating:
            return self.update_status("Cannot navigate while generating.")

        current_chat_id = self.chat_history_service.get_current_chat_id()
        if current_chat_id and self.chat_history_service.get_current_messages():
            chat_file = Path("chats") / f"{current_chat_id}.json"
            if not chat_file.exists():
                self.chat_history_service.save_current_chat()

        adjacent_id = self.chat_history_service.get_adjacent_chat_id(direction)
        if adjacent_id:
            if self.chat_history_service.load_chat(adjacent_id):
                self.update_status(f"Loaded chat: {adjacent_id}")
            else:
                self.update_status(f"Failed to load chat: {adjacent_id}")
        elif direction == "left":
            self.update_status("No previous chat.")
        else:
            self.handle_new_chat()
        self._update_navigation_buttons()

    def _handle_chat_loaded(self, chat_data: dict):
        self.main_window.response_panel.clear()
        for message in chat_data.get("messages", []):
            role = message.get("role", "")
            content = message.get("content", "")
            filenames = message.get("filenames") or ([message["filename"]] if message.get("filename") else None)

            if role == "user":
                self.append_user_message_signal.emit(content, filenames)
            elif role == "assistant":
                self.main_window.response_panel.append_assistant_message(content)

        self._update_navigation_buttons()
        QTimer.singleShot(0, self.main_window.response_panel.scroll_to_bottom)

    def _update_navigation_buttons(self):
        can_go_left = self.chat_history_service.get_adjacent_chat_id("left") is not None
        can_go_right = self.chat_history_service.get_adjacent_chat_id("right") is not None
        self.main_window.action_buttons_panel.update_navigation_buttons(can_go_left, can_go_right)

    def _update_service_model_button_label(self):
        self.main_window.action_buttons_panel.set_service_model_text(self.selected_service, self.selected_model)

    def _get_active_service(self):
        return self.services.get(self.selected_service, self.services["Gemini"])

    def _confirm_dialog(self, title: str, text: str) -> bool:
        """Show a dark-themed confirmation dialog. Returns True if user confirmed."""
        msg_box = QMessageBox(self.main_window)
        msg_box.setWindowTitle(title)
        msg_box.setText(text)
        msg_box.setStandardButtons(QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No)
        msg_box.setDefaultButton(QMessageBox.StandardButton.No)
        msg_box.setStyleSheet(DARK_MSGBOX_STYLE)
        return msg_box.exec() == QMessageBox.StandardButton.Yes

    def get_input_text(self) -> str:
        return self.main_window.get_input_text()

    def update_status(self, message: str):
        self.main_window.status_signal.emit(message)

    @staticmethod
    def _get_mime_type(filename: str) -> str:
        import mimetypes
        return mimetypes.guess_type(filename)[0] or "application/octet-stream"
```

### `core/services/nvidia_nim_service.py`

```python
# nvidia_nim_service.py
import os
from openai import OpenAI
from core.services.base_service import BaseAIService, BaseAIWorker

class NvidiaNimWorker(BaseAIWorker):
    """
    Worker thread to handle streaming API calls to NVIDIA NIM via OpenAI SDK.
    """
    # Model-specific thinking configurations
    # Different models use different parameter names for thinking/reasoning
    THINKING_CONFIGS = {
        "deepseek-ai/deepseek-v3.2": {"thinking": True},
        "moonshotai/kimi-k2-thinking": None,  # Thinking built into model
        "moonshotai/kimi-k2.5": {"thinking": True},
        "z-ai/glm4.7": {"enable_thinking": True, "clear_thinking": False},
        "z-ai/glm5": {"enable_thinking": True, "clear_thinking": False},
        "qwen/qwen3.5-397b-a17b": {"enable_thinking": True},
    }

    def __init__(self, client, model_name, messages):
        super().__init__()
        self.client = client
        self.model_name = model_name
        self.messages = messages

    def run(self):
        try:
            # Build request parameters
            request_params = {
                "model": self.model_name,
                "messages": self.messages,
                "stream": True
            }
            
            # Add model-specific thinking parameter if supported
            thinking_config = self.THINKING_CONFIGS.get(self.model_name)
            if thinking_config:
                request_params["extra_body"] = {"chat_template_kwargs": thinking_config}
            
            # Use streaming API
            response_stream = self.client.chat.completions.create(**request_params)
            
            full_response = ""
            full_thinking = ""
            
            for chunk in response_stream:
                if self._is_cancelled:
                    break
                if chunk.choices and len(chunk.choices) > 0:
                    delta = chunk.choices[0].delta
                    
                    # Check for reasoning content (DeepSeek, Kimi K2 format)
                    if hasattr(delta, 'reasoning_content') and delta.reasoning_content:
                        self.thinking_chunk.emit(delta.reasoning_content)
                        full_thinking += delta.reasoning_content
                    
                    # Regular content
                    if hasattr(delta, 'content') and delta.content:
                        self.chunk.emit(delta.content)
                        full_response += delta.content
            
            if self._is_cancelled:
                self.error.emit("Generation interrupted by user.")
                return

            self._emit_result(full_response, full_thinking)

        except Exception as e:
            self.error.emit(str(e))

class NvidiaNimService(BaseAIService):
    """Service for interacting with NVIDIA NIM API using OpenAI SDK."""

    # Model mapping: GUI friendly name -> API model ID
    MODEL_MAP = {
        "DeepSeek V3.2": "deepseek-ai/deepseek-v3.2",
        "Kimi K2": "moonshotai/kimi-k2-thinking",
        "Kimi K2.5": "moonshotai/kimi-k2.5",
        "GLM-4.7": "z-ai/glm4.7",
        "GLM-5": "z-ai/glm5",
        "Qwen3.5-397B-A17B": "qwen/qwen3.5-397b-a17b",
    }

    # Models that support image/vision input
    VISION_MODELS = {"Kimi K2.5", "Qwen3.5-397B-A17B"}

    def __init__(self):
        super().__init__()
        self.api_key = os.environ.get("NVIDIA_NIM_API_KEY")
        self.client = None

        if self.api_key:
            try:
                # Initialize OpenAI client with NVIDIA NIM base URL
                self.client = OpenAI(
                    api_key=self.api_key,
                    base_url="https://integrate.api.nvidia.com/v1"
                )
            except Exception as e:
                print(f"Failed to initialize NVIDIA NIM Client: {e}")
        else:
            print("Warning: NVIDIA_NIM_API_KEY environment variable not set.")
            print("NVIDIA NIM service will be unavailable until API key is configured.")

    def _emit_error(self, message: str):
        self.status_updated.emit(f"Error: {message}")
        self.error_occurred.emit(message)

    def generate_response(self, system_prompt: str, user_input: str, model_name: str = "DeepSeek V3.2", conversation_history: list = None, **kwargs):
        """Generates a response using the NVIDIA NIM API in a background thread."""
        if not self.client:
            return self._emit_error("NVIDIA_NIM_API_KEY not found.")

        files_data = kwargs.get('files_data', [])
        is_vision = model_name in self.VISION_MODELS
        has_images = is_vision and any(
            f.get('mime_type', '').startswith('image/') for f in files_data
        )

        if not user_input.strip() and not has_images:
            return self._emit_error("Input cannot be empty.")

        api_model = self.MODEL_MAP.get(model_name, "deepseek-ai/deepseek-v3.2")
        self.status_updated.emit(f"Generating response using NVIDIA NIM {model_name}...")

        messages = []
        if system_prompt:
            messages.append({"role": "system", "content": system_prompt})
        if conversation_history:
            messages.extend([
                {"role": m.get("role", ""), "content": m.get("content", "")}
                for m in conversation_history if m.get("content")
            ])

        # Build user message: multipart content for vision models with images,
        # plain text otherwise
        if has_images:
            content_parts = []
            if user_input.strip():
                content_parts.append({"type": "text", "text": user_input})
            for file_data in files_data:
                mime = file_data.get('mime_type', '')
                if mime.startswith('image/'):
                    content_parts.append({
                        "type": "image_url",
                        "image_url": {
                            "url": f"data:{mime};base64,{file_data['base64']}"
                        }
                    })
            messages.append({"role": "user", "content": content_parts})
        else:
            messages.append({"role": "user", "content": user_input})

        worker = NvidiaNimWorker(self.client, api_model, messages)
        self._start_worker(worker)
```

### `core/config.py`

```python
"""Configuration Manager for PyQt6 GUI Framework."""
import os
import json

_DEFAULTS = {
    "window_width": 1200,
    "window_height": 800,
    "theme": "dark",
    "current_service": "Gemini",
    "current_model": "Flash",
    "default_system_prompt": "You are a helpful AI assistant.",
    "splitter_sizes": [780, 420],
    "display_fields": {
        "core": True,
        "composition": True,
        "lighting": True,
        "style": True,
        "technical": True,
        "post_processing": True,
        "special_elements": True,
        "detailed_prompt": True,
        "grok_imagine_optimized": True,
        "gemini_optimized": True,
        "flux_optimized": True,
        "stable_diffusion_optimized": True,
        "video_optimized": True
    }
}

class ConfigManager:
    """Manages GUI configuration values and local gui_config.json persistence."""

    def __init__(self, config_file: str = "gui_config.json"):
        self.config_file = config_file
        self.__dict__.update(_DEFAULTS)
        self._load_config()

    def _load_config(self) -> None:
        if not os.path.exists(self.config_file):
            return
        try:
            with open(self.config_file, 'r') as f:
                config = json.load(f)
                for k in _DEFAULTS:
                    val = config.get(k, getattr(self, k))
                    if isinstance(val, dict) and isinstance(_DEFAULTS[k], dict):
                        merged = _DEFAULTS[k].copy()
                        merged.update(val)
                        setattr(self, k, merged)
                    else:
                        setattr(self, k, val)
                if "default_service" in config and "current_service" not in config:
                    self.current_service = config["default_service"]
                if "service_models" in config and "current_model" not in config:
                    self.current_model = config.get("service_models", {}).get(self.current_service, self.current_model)
        except Exception:
            pass

    def save(self) -> None:
        try:
            with open(self.config_file, 'w') as f:
                json.dump({k: getattr(self, k) for k in _DEFAULTS}, f, indent=2)
        except Exception:
            pass
```
