### TASK

Perform an investigation for opportunities on refactoring the app.

### GOALS

In order of priority:

1. Fewer lines of project code (literal character count / token count)
2. Better foundation (measurement of how easy it is to build on top of or make modifications without breaking things)

### PROJECT 

Image Assistant is a PyQt6 desktop application that transforms user concepts into optimized image generation prompts via AI services (Gemini, NVIDIA NIM), with integrated text-to-image synthesis through Pollinations, Airforce, and Perchance APIs.

### DELIVERABLES

Please output a brief summary including any design choices, and the updated or new files where applicable. You have authority to create, delete, or consolidate services or modules. If only small changes to existing files are required, please output them in

SEARCH: 

```
...stuff...
``` 

REPLACE:

```
...stuff...
``` 

style blocks. If no significant improvements can be made, you are free to make that judgment.

### CONTEXT

## ðŸ“¦ Full Project Context Dump

**Project Root:** `image-prompter/`
**Files Included:** 25

---

### File Index

1. `app/controller.py`
2. `app/main.py`
3. `core/config.py`
4. `core/json_helper.py`
5. `core/prompt_manager.py`
6. `core/services/airforce_service.py`
7. `core/services/base_service.py`
8. `core/services/chat_history_service.py`
9. `core/services/file_service.py`
10. `core/services/gallery_service.py`
11. `core/services/gemini_service.py`
12. `core/services/nvidia_nim_service.py`
13. `core/services/perchance_service.py`
14. `core/services/pollinations_service.py`
15. `core/utils.py`
16. `gui/main_window.py`
17. `gui/widgets/action_buttons_panel.py`
18. `gui/widgets/airforce_page.py`
19. `gui/widgets/gallery_page.py`
20. `gui/widgets/image_gen_common.py`
21. `gui/widgets/input_panel.py`
22. `gui/widgets/media_panel.py`
23. `gui/widgets/perchance_page.py`
24. `gui/widgets/pollinations_page.py`
25. `gui/widgets/response_panel.py`

---

### `app/controller.py`

```python
# app/controller.py
"""Application Controller - Orchestrates application logic and connects GUI to services."""
import sys
import base64
from pathlib import Path
from PyQt6.QtWidgets import QApplication, QMessageBox
from PyQt6.QtCore import pyqtSignal, QObject, QTimer

from gui.main_window import MainWindow
from core.config import ConfigManager
from core.prompt_manager import PromptManager
from core.services.file_service import FileService
from core.services.gemini_service import GeminiService
from core.services.nvidia_nim_service import NvidiaNimService
from core.services.chat_history_service import ChatHistoryService

DARK_MSGBOX_STYLE = """
    QMessageBox, QLabel { background-color: #1a1a1a; color: #ffffff; }
    QPushButton { background-color: #3d3d3d; color: #ffffff; border: 1px solid #333; padding: 8px; border-radius: 4px; }
    QPushButton:hover { background-color: #4d4d4d; }
"""


class ApplicationController(QObject):
    """Orchestrates the application logic, connecting GUI signals to backend services."""
    append_user_message_signal = pyqtSignal(str, object)
    clear_input_signal = pyqtSignal()
    clear_response_signal = pyqtSignal()

    def __init__(self, app: QApplication):
        super().__init__()
        self.app = app
        self.config_manager = ConfigManager()
        self.prompt_manager = PromptManager()

        self.file_service = FileService()
        self.services = {"Gemini": GeminiService(), "NVIDIA NIM": NvidiaNimService()}
        self.chat_history_service = ChatHistoryService()

        self.selected_service = getattr(self.config_manager, "current_service", "Gemini")
        self.selected_model = getattr(self.config_manager, "current_model", "Flash")

        self.main_window = MainWindow(self.file_service, self.config_manager)

        for service in self.services.values():
            service.response_generated.connect(self._handle_ai_response)
            service.status_updated.connect(self.main_window.status_signal.emit)
            service.chunk_received.connect(self._handle_stream_chunk)
            service.thinking_chunk_received.connect(self._handle_thinking_chunk)
            service.stream_complete.connect(self._handle_stream_complete)
            service.error_occurred.connect(self._handle_generation_error)

        self._is_streaming = False
        self._is_generating = False

        self.chat_history_service.chat_loaded.connect(self._handle_chat_loaded)
        self._connect_signals()
        self._initialize_ui()

    def handle_display_toggled(self, new_fields: dict):
        self.config_manager.display_fields = new_fields.copy()
        self.config_manager.save()
        self.main_window.response_panel.display_fields = new_fields.copy()
        
        # Re-render chat natively so UI instantly updates based on new toggles
        current_chat_id = self.chat_history_service.get_current_chat_id()
        if current_chat_id:
            chat_data = {"messages": self.chat_history_service.get_current_messages()}
            self._handle_chat_loaded(chat_data)

    def _connect_signals(self):
        abp = self.main_window.action_buttons_panel
        ip = self.main_window.input_panel

        # Media panel status â†’ main status bar
        self.main_window.media_panel.status_updated.connect(self.main_window.status_signal.emit)

        abp.select_file_signal.connect(self.handle_select_file)
        abp.send_signal.connect(self.handle_send)
        abp.display_toggled_signal.connect(self.handle_display_toggled)
        abp.interrupt_signal.connect(self.handle_interrupt)
        abp.service_model_selected_signal.connect(self.handle_service_model_selected)
        abp.new_chat_signal.connect(self.handle_new_chat)
        abp.delete_chat_signal.connect(self.handle_delete_chat)
        abp.delete_all_chats_signal.connect(self.handle_delete_all_chats)
        abp.navigate_left_signal.connect(self.handle_navigate_left)
        abp.navigate_right_signal.connect(self.handle_navigate_right)

        ip.send_signal.connect(self.handle_send)
        ip.navigate_left_signal.connect(self.handle_navigate_left)
        ip.navigate_right_signal.connect(self.handle_navigate_right)

        self.append_user_message_signal.connect(self.main_window.response_panel.append_user_message)
        self.clear_input_signal.connect(lambda: ip.set_input_text(""))
        self.clear_response_signal.connect(self.main_window.response_panel.clear)

    def _initialize_ui(self):
        self._update_service_model_button_label()
        
        # Init display fields explicitly
        if hasattr(self.config_manager, "display_fields"):
            self.main_window.action_buttons_panel.set_display_fields(self.config_manager.display_fields)
            self.main_window.response_panel.display_fields = self.config_manager.display_fields
            
        self.chat_history_service.create_new_chat()
        self._update_navigation_buttons()

    def run(self):
        self.main_window.resize(self.config_manager.window_width, self.config_manager.window_height)
        if hasattr(self.config_manager, 'splitter_sizes'):
            self.main_window.splitter.setSizes(self.config_manager.splitter_sizes)
        self.main_window.show()
        sys.exit(self.app.exec())

    # --- Action Handlers ---

    def handle_select_file(self, b64_data: str, filename: str):
        if not self.file_service.has_files():
            self.update_status("No files selected.")

    def handle_interrupt(self):
        if self._is_generating:
            self.update_status("Interrupting generation...")
            active_service = self._get_active_service()
            if hasattr(active_service, 'cancel_generation'):
                active_service.cancel_generation()

    def handle_send(self):
        user_input = self.get_input_text()
        if not user_input.strip() and not self.file_service.has_files():
            return self.update_status("Error: Input cannot be empty.")
        self._process_message(user_input)

    def handle_service_model_selected(self, service: str, model: str):
        self.selected_service = service
        self.selected_model = model
        self.config_manager.current_service = service
        self.config_manager.current_model = model
        self.config_manager.save()
        self._update_service_model_button_label()
        self.update_status(f"Selected: {service} - {model}")

    def handle_new_chat(self):
        if self._is_generating:
            return self.update_status("Cannot create a new chat while generating.")
        if self.chat_history_service.get_current_messages():
            self.chat_history_service.save_current_chat()
        self.chat_history_service.create_new_chat()
        self.clear_response_signal.emit()
        self.clear_input_signal.emit()
        self.update_status("New chat created.")
        self._update_navigation_buttons()

    def handle_delete_chat(self):
        if self._is_generating:
            return self.update_status("Cannot delete chat while generating.")
        current_chat_id = self.chat_history_service.get_current_chat_id()
        if not current_chat_id:
            return self.update_status("No chat to delete.")
        if not self._confirm_dialog("Delete Chat", "Are you sure you want to delete this chat?"):
            return

        if self.chat_history_service.delete_chat(current_chat_id):
            adjacent_id = (self.chat_history_service.get_adjacent_chat_id("left") or
                           self.chat_history_service.get_adjacent_chat_id("right"))
            if adjacent_id:
                self.chat_history_service.load_chat(adjacent_id)
                self.update_status(f"Chat deleted. Loaded chat: {adjacent_id}")
            else:
                self.chat_history_service.create_new_chat()
                self.clear_response_signal.emit()
                self.update_status("Chat deleted. New chat created.")
        else:
            self.update_status("Failed to delete chat.")
        self._update_navigation_buttons()

    def handle_delete_all_chats(self):
        if self._is_generating:
            return self.update_status("Cannot delete all chats while generating.")
        chat_files = self.chat_history_service.get_chat_files()
        if not chat_files:
            return self.update_status("No chats to delete.")
        if not self._confirm_dialog("Delete All Chats", f"Are you sure you want to delete all {len(chat_files)} chats?"):
            return

        if self.chat_history_service.delete_all_chats():
            self.chat_history_service.clear_current_chat()
            self.chat_history_service.create_new_chat()
            self.clear_response_signal.emit()
            self.update_status("All chats deleted. New chat created.")
        else:
            self.update_status("Failed to delete some chats.")
        self._update_navigation_buttons()

    def handle_navigate_left(self):
        self._handle_navigation("left")

    def handle_navigate_right(self):
        self._handle_navigation("right")

    # --- Internal Logic ---

    def _process_message(self, user_input: str):
        if self._is_generating:
            return self.update_status("Please wait for the current response to finish.")

        has_files = self.file_service.has_files()
        if not self.chat_history_service.get_current_chat_id():
            self.chat_history_service.create_new_chat()

        file_data_list, filenames_list = [], None
        if has_files:
            for file_b64, filename in self.file_service.get_files():
                file_data_list.append({
                    'base64': file_b64, 'filename': filename,
                    'mime_type': self._get_mime_type(filename),
                    'file_size': len(base64.b64decode(file_b64))
                })
            if file_data_list:
                filenames_list = [f['filename'] for f in file_data_list]

        display_text = user_input or (
            f"Process file{'s' if len(file_data_list) > 1 else ''}: {', '.join(filenames_list)}"
            if filenames_list else ""
        )

        self.append_user_message_signal.emit(display_text, filenames_list)
        self.chat_history_service.add_message("user", display_text, filenames_list)
        self.clear_input_signal.emit()

        active_service = self._get_active_service()
        self._set_generating_state(True)

        kwargs = {}
        if file_data_list:
            kwargs['files_data'] = file_data_list
            
        has_image = False
        if file_data_list:
            has_image = any(f['mime_type'].startswith('image/') for f in file_data_list)
            
        system_prompt = self.prompt_manager.get_prompt(self.selected_service, self.selected_model, has_image)

        active_service.generate_response(
            system_prompt, user_input,
            self.selected_model, self.chat_history_service.get_current_messages()[:-1], **kwargs
        )

        if has_files:
            self.file_service.clear_files()

    def _handle_ai_response(self, response_text: str):
        if not self._is_streaming:
            self.main_window.response_panel.append_assistant_message(response_text)
        self.chat_history_service.add_message("assistant", response_text)
        if chat_id := self.chat_history_service.save_current_chat():
            self.update_status(f"Chat saved: {chat_id}")
        self._is_streaming = False
        self._set_generating_state(False)

    def _handle_generation_error(self, error_message: str):
        self._set_generating_state(False)
        if self._is_streaming:
            self._is_streaming = False
            self.main_window.response_panel.end_stream()

    def _set_generating_state(self, state: bool):
        self._is_generating = state
        self.main_window.action_buttons_panel.set_generating_state(state)
        if not state:
            self._update_navigation_buttons()
            self.main_window.action_buttons_panel.update_text_action_buttons(bool(self.get_input_text().strip()))

    def _handle_stream_chunk(self, chunk: str):
        if not self._is_streaming:
            self._is_streaming = True
            self.main_window.response_panel.start_stream()
        self.main_window.response_panel.append_stream_chunk(chunk)

    def _handle_thinking_chunk(self, chunk: str):
        if not self._is_streaming:
            self._is_streaming = True
            self.main_window.response_panel.start_stream()
        self.main_window.response_panel.append_thinking_chunk(chunk)

    def _handle_stream_complete(self, full_response: str):
        self.main_window.response_panel.end_stream()

    def _handle_navigation(self, direction: str):
        if self._is_generating:
            return self.update_status("Cannot navigate while generating.")

        current_chat_id = self.chat_history_service.get_current_chat_id()
        if current_chat_id and self.chat_history_service.get_current_messages():
            chat_file = Path("chats") / f"{current_chat_id}.json"
            if not chat_file.exists():
                self.chat_history_service.save_current_chat()

        adjacent_id = self.chat_history_service.get_adjacent_chat_id(direction)
        if adjacent_id:
            if self.chat_history_service.load_chat(adjacent_id):
                self.update_status(f"Loaded chat: {adjacent_id}")
            else:
                self.update_status(f"Failed to load chat: {adjacent_id}")
        elif direction == "left":
            self.update_status("No previous chat.")
        else:
            self.handle_new_chat()
        self._update_navigation_buttons()

    def _handle_chat_loaded(self, chat_data: dict):
        self.main_window.response_panel.clear()
        for message in chat_data.get("messages", []):
            role = message.get("role", "")
            content = message.get("content", "")
            filenames = message.get("filenames") or ([message["filename"]] if message.get("filename") else None)

            if role == "user":
                self.append_user_message_signal.emit(content, filenames)
            elif role == "assistant":
                self.main_window.response_panel.append_assistant_message(content)

        self._update_navigation_buttons()
        QTimer.singleShot(0, self.main_window.response_panel.scroll_to_bottom)

    def _update_navigation_buttons(self):
        can_go_left = self.chat_history_service.get_adjacent_chat_id("left") is not None
        can_go_right = self.chat_history_service.get_adjacent_chat_id("right") is not None
        self.main_window.action_buttons_panel.update_navigation_buttons(can_go_left, can_go_right)

    def _update_service_model_button_label(self):
        self.main_window.action_buttons_panel.set_service_model_text(self.selected_service, self.selected_model)

    def _get_active_service(self):
        return self.services.get(self.selected_service, self.services["Gemini"])

    def _confirm_dialog(self, title: str, text: str) -> bool:
        """Show a dark-themed confirmation dialog. Returns True if user confirmed."""
        msg_box = QMessageBox(self.main_window)
        msg_box.setWindowTitle(title)
        msg_box.setText(text)
        msg_box.setStandardButtons(QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No)
        msg_box.setDefaultButton(QMessageBox.StandardButton.No)
        msg_box.setStyleSheet(DARK_MSGBOX_STYLE)
        return msg_box.exec() == QMessageBox.StandardButton.Yes

    def get_input_text(self) -> str:
        return self.main_window.get_input_text()

    def update_status(self, message: str):
        self.main_window.status_signal.emit(message)

    @staticmethod
    def _get_mime_type(filename: str) -> str:
        import mimetypes
        return mimetypes.guess_type(filename)[0] or "application/octet-stream"
```

### `app/main.py`

```python
# app/main.py
"""
Application Entry Point
"""
import sys
from PyQt6.QtWidgets import QApplication
from PyQt6.QtGui import QGuiApplication
from PyQt6.QtCore import Qt, qInstallMessageHandler, QtMsgType
from app.controller import ApplicationController


def qt_message_handler(mode, context, message):
    """
    Custom Qt message handler to suppress QPainter warnings.

    Args:
        mode: QtMsgType - The type of message
        context: QMessageLogContext - Context information
        message: str - The message content
    """
    # Suppress QPainter warnings as they are not from our code and can be safely ignored
    if "QPainter" in message:
        return

    # For all other messages, use default handling
    # We can't call the original handler directly, so we'll print to stderr for warnings/errors
    if mode in (QtMsgType.QtWarningMsg, QtMsgType.QtCriticalMsg, QtMsgType.QtFatalMsg):
        print(f"Qt {mode.name}: {message}", file=sys.stderr)
    elif mode == QtMsgType.QtInfoMsg:
        print(f"Qt Info: {message}", file=sys.stderr)
    # QtDebugMsg is typically not printed in release builds

if __name__ == "__main__":
    # Set high DPI policy for better scaling on modern displays (must be before QApplication)
    QGuiApplication.setHighDpiScaleFactorRoundingPolicy(Qt.HighDpiScaleFactorRoundingPolicy.PassThrough)
    QApplication.setAttribute(Qt.ApplicationAttribute.AA_ShareOpenGLContexts)

    try:
        # Install custom message handler to suppress QPainter warnings
        qInstallMessageHandler(qt_message_handler)

        # QApplication instance must be created first
        q_app = QApplication(sys.argv)
        
        # Initialize and run the main application controller
        controller = ApplicationController(q_app)
        controller.run()
        
    except Exception as e:
        print(f"FATAL APPLICATION ERROR: {e}", file=sys.stderr)
        sys.exit(1)
```

### `core/config.py`

```python
"""Configuration Manager for PyQt6 GUI Framework."""
import os
import json

_DEFAULTS = {
    "window_width": 1200,
    "window_height": 800,
    "theme": "dark",
    "current_service": "Gemini",
    "current_model": "Flash",
    "default_system_prompt": "You are a helpful AI assistant.",
    "splitter_sizes": [780, 420],
    "media_active_tab": 0,
    "gallery_page": 1,
    "gallery_filter": "All",
    "pollinations_positive_prompt": "",
    "pollinations_negative_prompt": "",
    "pollinations_model": "zimage",
    "pollinations_size": "1024x1024",
    "pollinations_seed": -1,
    "pollinations_last_image": "",
    "airforce_positive_prompt": "",
    "airforce_negative_prompt": "",
    "airforce_model": "grok-imagine",
    "airforce_size": "1024x1024",
    "airforce_seed": -1,
    "airforce_last_image": "",
    "perchance_url": "https://perchance.org/a1481832-0a06-414f-baa6-616052e5f61d",
    "adblocker": {
        "blocked_domains": [
            "a.pub.network",
            "d.pub.network",
            "cdn.snigelweb.com",
            "googletagmanager.com",
            "cloudflareinsights.com",
            "static.criteo.net",
            "secure.quantserve.com",
            "fundingchoicesmessages.google.com"
        ],
        "hidden_selectors": [
            ".ad-providers-ctn-el",
            "#adCtn",
            "#pmLink"
        ]
    },
    "display_fields": {
        "core": True,
        "composition": True,
        "lighting": True,
        "style": True,
        "technical": True,
        "post_processing": True,
        "special_elements": True,
        "detailed_prompt": True,
        "grok_imagine_optimized": True,
        "gemini_optimized": True,
        "flux_optimized": True,
        "stable_diffusion_optimized": True,
        "video_optimized": True
    }
}

class ConfigManager:
    """Manages GUI configuration values and local gui_config.json persistence."""

    def __init__(self, config_file: str = "gui_config.json"):
        self.config_file = config_file
        self.__dict__.update(_DEFAULTS)
        self._load_config()

    def _load_config(self) -> None:
        if not os.path.exists(self.config_file):
            return
        try:
            with open(self.config_file, 'r') as f:
                config = json.load(f)
                for k in _DEFAULTS:
                    val = config.get(k, getattr(self, k))
                    if isinstance(val, dict) and isinstance(_DEFAULTS[k], dict):
                        merged = _DEFAULTS[k].copy()
                        merged.update(val)
                        setattr(self, k, merged)
                    else:
                        setattr(self, k, val)
                if "default_service" in config and "current_service" not in config:
                    self.current_service = config["default_service"]
                if "service_models" in config and "current_model" not in config:
                    self.current_model = config.get("service_models", {}).get(self.current_service, self.current_model)
        except Exception:
            pass

    def save(self) -> None:
        try:
            with open(self.config_file, 'w') as f:
                json.dump({k: getattr(self, k) for k in _DEFAULTS}, f, indent=2)
        except Exception:
            pass
```

### `core/json_helper.py`

```python
# core/json_helper.py
import json
import re
from typing import Dict, Any

class JsonHelper:
    """Robust JSON extractor to capture badly formatted JSON outputs from lesser intelligent models."""

    @staticmethod
    def extract_and_parse_json(text: str) -> Dict[str, Any]:
        """
        Attempts to extract a JSON object from text and parse it.
        Handles missing closing braces, trailing commas, and escaped characters.
        """
        start_idx = text.find('{')
        end_idx = text.rfind('}')
        
        if start_idx == -1:
            return {}
            
        # If no closing brace, assume it goes to the end
        if end_idx == -1 or end_idx < start_idx:
            json_str = text[start_idx:] + '}'
        else:
            json_str = text[start_idx:end_idx+1]
            
        # Fix trailing commas before closing braces/brackets
        json_str = re.sub(r',\s*([}\]])', r'\1', json_str)
        
        try:
            return json.loads(json_str)
        except json.JSONDecodeError:
            # Fallback to an aggressive regex-based key-value extraction for broken JSON
            return JsonHelper._parse_bad_json(json_str)

    @staticmethod
    def _parse_bad_json(json_str: str) -> Dict[str, Any]:
        """Aggressive fallback to extract key-value pairs when standard parsing fails."""
        result = {}
        # Matches "key": "value" or "key": boolean/number/null
        # Allows for possible missing quotes around simple values, though standard JSON requires it
        pattern = r'(?:"([^"]+)"|([a-zA-Z0-9_]+))\s*:\s*(?:"((?:[^"\\]|\\.)*)"|([^,}\n]+))'
        matches = re.finditer(pattern, json_str)
        
        for match in matches:
            key = match.group(1) or match.group(2)
            val_str = match.group(3)
            val_other = match.group(4)
            
            if not key:
                continue
                
            if val_str is not None:
                # Handle basic escaped sequences
                val = val_str.replace('\\n', '\n').replace('\\"', '"').replace('\\\\', '\\')
                result[key] = val
            elif val_other is not None:
                val_other = val_other.strip()
                if val_other.lower() == 'true': 
                    result[key] = True
                elif val_other.lower() == 'false': 
                    result[key] = False
                elif val_other.lower() == 'null': 
                    result[key] = None
                else:
                    try:
                        if '.' in val_other:
                            result[key] = float(val_other)
                        else:
                            result[key] = int(val_other)
                    except ValueError:
                        # Fallback to saving it as a string
                        result[key] = val_other
                        
        return result
```

### `core/prompt_manager.py`

```python
# core/prompt_manager.py
import json
import os

class PromptManager:
    """Manages system prompts for different models and modalities."""
    
    def __init__(self, filepath: str = "prompts.json"):
        self.filepath = filepath
        self.prompts = {
            "default": {
                "text": "You are Image Assistant. Transform the user's idea into a detailed JSON prompt containing the mandated fields.",
                "vision": "You are Image Assistant. Analyze the attached image and the user's idea to generate a detailed JSON prompt containing the mandated fields."
            }
        }
        self.load()

    def load(self):
        if os.path.exists(self.filepath):
            try:
                with open(self.filepath, "r", encoding="utf-8") as f:
                    data = json.load(f)
                    self.prompts.update(data)
            except Exception:
                pass
        else:
            self.save()

    def save(self):
        try:
            with open(self.filepath, "w", encoding="utf-8") as f:
                json.dump(self.prompts, f, indent=4)
        except Exception:
            pass

    def get_prompt(self, service: str, model: str, has_image: bool) -> str:
        """Fetch the correct system prompt for the service/model and modality context."""
        key = f"{service}:{model}"
        ptype = "vision" if has_image else "text"
        
        if key in self.prompts and ptype in self.prompts[key]:
            return self.prompts[key][ptype]
        
        return self.prompts["default"].get(ptype, "")
```

### `core/services/airforce_service.py`

```python
# core/services/airforce_service.py
"""
Airforce AI Image Generation Service.
Handles API communication with Airforce for text-to-image generation via SSE.
"""

import os
import json
import base64
import urllib.request
import urllib.error
from typing import Optional

from PyQt6.QtCore import QObject, pyqtSignal, QThread

from core.utils import save_generated_image


class AirforceWorker(QThread):
    """Worker thread for Airforce API image generation."""

    finished = pyqtSignal(str)
    error = pyqtSignal(str)

    API_URL = "https://api.airforce/v1/images/generations"

    def __init__(self, prompt, negative_prompt, model, size, seed):
        super().__init__()
        self.prompt = prompt
        self.negative_prompt = negative_prompt
        self.model = model
        self.size = size
        self.seed = seed
        self._is_cancelled = False
        self.api_key = os.environ.get("AIRFORCE_API_KEY", "")

    def cancel(self):
        self._is_cancelled = True

    def run(self):
        try:
            if not self.api_key:
                self.error.emit("AIRFORCE_API_KEY environment variable not set.")
                return

            headers = {
                "Authorization": f"Bearer {self.api_key}",
                "Content-Type": "application/json",
                "User-Agent": "ImagePrompter/1.0",
            }

            payload = {
                "model": self.model,
                "prompt": self.prompt,
                "n": 1,
                "size": self.size,
                "response_format": "b64_json",
                "sse": True,
            }

            if self.negative_prompt:
                payload["negative_prompt"] = self.negative_prompt
            if self.seed != -1:
                payload["seed"] = self.seed

            data_bytes = json.dumps(payload).encode("utf-8")
            req = urllib.request.Request(
                self.API_URL, data=data_bytes, headers=headers, method="POST"
            )

            b64_data = None
            raw_body = b""

            with urllib.request.urlopen(req, timeout=180) as response:
                for raw_line in response:
                    if self._is_cancelled:
                        self.error.emit("Generation cancelled.")
                        return

                    raw_body += raw_line
                    line_str = raw_line.decode("utf-8").strip()

                    if not line_str:
                        continue
                    if line_str in ("data: [DONE]", "data: : keepalive"):
                        continue
                    if not line_str.startswith("data: "):
                        continue

                    try:
                        chunk = json.loads(line_str[6:])
                    except json.JSONDecodeError:
                        continue

                    b64_data = self._extract_b64(chunk)
                    if b64_data:
                        break

            if self._is_cancelled:
                self.error.emit("Generation cancelled.")
                return

            # Fallback: try parsing entire response body as JSON
            if not b64_data:
                try:
                    full_data = json.loads(raw_body.decode("utf-8"))
                    b64_data = self._extract_b64(full_data)
                except (json.JSONDecodeError, UnicodeDecodeError):
                    pass

            if not b64_data:
                self.error.emit("No image data received from API.")
                return

            image_bytes = base64.b64decode(b64_data)
            filepath = save_generated_image(
                image_bytes, self.prompt, self.negative_prompt,
                self.model, self.size, self.seed, "Airforce",
            )
            self.finished.emit(filepath)

        except urllib.error.HTTPError as e:
            if not self._is_cancelled:
                body = ""
                try:
                    body = e.read(500).decode("utf-8", errors="replace")
                except Exception:
                    pass
                self.error.emit(f"HTTP {e.code}: {body or e.reason}")
        except urllib.error.URLError as e:
            if not self._is_cancelled:
                self.error.emit(f"Connection error: {e.reason}")
        except Exception as e:
            if not self._is_cancelled:
                self.error.emit(str(e))

    @staticmethod
    def _extract_b64(data) -> Optional[str]:
        """Extract base64 image data from an API response dict."""
        if not isinstance(data, dict):
            return None
        # OpenAI-style: {"data": [{"b64_json": "..."}]}
        if "data" in data and isinstance(data["data"], list):
            for item in data["data"]:
                if isinstance(item, dict) and "b64_json" in item:
                    return item["b64_json"]
        # Flat: {"b64_json": "..."}
        if "b64_json" in data:
            return data["b64_json"]
        return None


class AirforceService(QObject):
    """Service for Airforce AI image generation."""

    image_generated = pyqtSignal(str)
    status_updated = pyqtSignal(str)
    error_occurred = pyqtSignal(str)

    def __init__(self):
        super().__init__()
        self.worker = None

    def generate_image(self, prompt, negative_prompt="", model="grok-imagine",
                       size="1024x1024", seed=-1):
        """Start image generation in a background thread."""
        if not prompt.strip():
            self.error_occurred.emit("Prompt cannot be empty.")
            self.status_updated.emit("Error: Prompt cannot be empty.")
            return

        self.status_updated.emit(f"Generating with {model} ({size})...")

        self.worker = AirforceWorker(prompt, negative_prompt, model, size, seed)
        self.worker.finished.connect(self._on_finished)
        self.worker.error.connect(self._on_error)
        self.worker.finished.connect(self.worker.deleteLater)
        self.worker.error.connect(self.worker.deleteLater)
        self.worker.start()

    def _on_finished(self, filepath):
        if self.sender() is not self.worker:
            return
        self.worker = None
        self.image_generated.emit(filepath)
        self.status_updated.emit(f"Image saved: {filepath}")

    def _on_error(self, msg):
        if self.sender() is not self.worker:
            return
        self.worker = None
        self.error_occurred.emit(msg)
        self.status_updated.emit(f"Error: {msg}")

    def cancel_generation(self):
        """Cancel the current generation if running."""
        if self.worker and self.worker.isRunning():
            self.worker.cancel()
```

### `core/services/base_service.py`

```python
# core/services/base_service.py
from PyQt6.QtCore import QObject, pyqtSignal, QThread

class BaseAIWorker(QThread):
    finished = pyqtSignal(str)
    error = pyqtSignal(str)
    chunk = pyqtSignal(str)
    thinking_chunk = pyqtSignal(str)

    def __init__(self):
        super().__init__()
        self._is_cancelled = False

    def cancel(self):
        self._is_cancelled = True

    def _emit_result(self, full_response: str, full_thinking: str):
        """Emit combined thinking+response result or error if empty."""
        if full_response or full_thinking:
            combined = f"<thinking>\n{full_thinking}\n</thinking>\n\n" if full_thinking else ""
            self.finished.emit(combined + full_response)
        else:
            self.error.emit("API returned empty response.")

class BaseAIService(QObject):
    """Abstract base class establishing the interface for AI Services."""
    response_generated = pyqtSignal(str)
    status_updated = pyqtSignal(str)
    error_occurred = pyqtSignal(str)
    chunk_received = pyqtSignal(str)
    thinking_chunk_received = pyqtSignal(str)
    stream_complete = pyqtSignal(str)

    def generate_response(self, system_prompt: str, user_input: str, model_name: str, conversation_history: list = None, **kwargs):
        raise NotImplementedError("generate_response must be implemented by subclasses.")

    def _start_worker(self, worker: BaseAIWorker):
        self.worker = worker
        self.worker.finished.connect(self._handle_success)
        self.worker.finished.connect(self.stream_complete.emit)
        self.worker.error.connect(self._handle_error)
        self.worker.chunk.connect(self.chunk_received.emit)
        self.worker.thinking_chunk.connect(self.thinking_chunk_received.emit)
        self.worker.finished.connect(self.worker.deleteLater)
        self.worker.error.connect(self.worker.deleteLater)
        if hasattr(self.worker, 'retry_with_new_key'):
            self.worker.retry_with_new_key.connect(getattr(self, '_handle_retry', lambda e, c: None))
            self.worker.retry_with_new_key.connect(self.worker.deleteLater)
        self.worker.start()

    def _handle_success(self, response_text: str):
        self.response_generated.emit(response_text)
        self.status_updated.emit("Response received.")

    def _handle_error(self, error_message: str):
        self.status_updated.emit(f"API Error: {error_message}")
        self.error_occurred.emit(error_message)

    def cancel_generation(self):
        if hasattr(self, 'worker') and self.worker and self.worker.isRunning():
            self.worker.cancel()
```

### `core/services/chat_history_service.py`

```python
# core/services/chat_history_service.py
"""
Chat History Service - Manages chat history persistence, loading, saving, and navigation.
"""
import os
import json
from datetime import datetime
from typing import Optional, List, Dict, Tuple
from pathlib import Path
from PyQt6.QtCore import QObject, pyqtSignal


class ChatHistoryService(QObject):
    """
    Service for managing chat history: saving, loading, and navigating between chats.
    """
    chat_loaded = pyqtSignal(dict)  # Emits chat data when a chat is loaded
    chat_saved = pyqtSignal(str)  # Emits chat ID when a chat is saved

    def __init__(self, chats_dir: str = "chats"):
        """
        Initialize ChatHistoryService.

        Args:
            chats_dir: Directory to store chat JSON files
        """
        super().__init__()
        self.chats_dir = Path(chats_dir)
        self.chats_dir.mkdir(exist_ok=True)
        self.current_chat_id: Optional[str] = None
        self.current_messages: List[Dict[str, str]] = []

    def get_chat_files(self) -> List[Tuple[str, str]]:
        """
        Scan chats directory for JSON files and return sorted list of (chat_id, filepath).

        Returns:
            List of tuples (chat_id, filepath) sorted by timestamp (oldest first)
        """
        chat_files = []
        if not self.chats_dir.exists():
            return chat_files

        for file_path in self.chats_dir.glob("*.json"):
            try:
                # Extract timestamp from filename (YYYY-MM-DD_HH-MM-SS.json)
                chat_id = file_path.stem
                # Validate format
                datetime.strptime(chat_id, "%Y-%m-%d_%H-%M-%S")
                chat_files.append((chat_id, str(file_path)))
            except (ValueError, AttributeError):
                # Skip files that don't match the expected format
                continue

        # Sort by chat_id (which is timestamp-based)
        chat_files.sort(key=lambda x: x[0])
        return chat_files

    def create_new_chat(self) -> str:
        """
        Create a new chat session. No file is created until first message is sent.

        Returns:
            str: New chat ID (timestamp-based)
        """
        self.current_chat_id = datetime.now().strftime("%Y-%m-%d_%H-%M-%S")
        self.current_messages = []
        return self.current_chat_id

    def add_message(self, role: str, content: str, filenames: Optional[List[str]] = None):
        """
        Add a message to the current chat.

        Args:
            role: "user" or "assistant"
            content: Message content
            filenames: Optional list of filenames if message includes file uploads
        """
        message = {
            "role": role,
            "content": content,
            "timestamp": datetime.now().isoformat()
        }
        if filenames:
            message["filenames"] = filenames
        self.current_messages.append(message)

    def save_current_chat(self) -> Optional[str]:
        """
        Save the current chat to a JSON file.

        Returns:
            str: Chat ID if saved successfully, None otherwise
        """
        if not self.current_chat_id or not self.current_messages:
            return None

        try:
            chat_data = {
                "chat_id": self.current_chat_id,
                "created_at": self.current_messages[0]["timestamp"] if self.current_messages else datetime.now().isoformat(),
                "messages": self.current_messages
            }

            file_path = self.chats_dir / f"{self.current_chat_id}.json"
            with open(file_path, 'w', encoding='utf-8') as f:
                json.dump(chat_data, f, indent=2, ensure_ascii=False)

            self.chat_saved.emit(self.current_chat_id)
            return self.current_chat_id
        except Exception as e:
            print(f"Error saving chat: {e}")
            return None

    def load_chat(self, chat_id: str) -> Optional[Dict]:
        """
        Load a chat from a JSON file.

        Args:
            chat_id: Chat ID (timestamp-based filename without .json)

        Returns:
            Dict with chat data if successful, None otherwise
        """
        try:
            file_path = self.chats_dir / f"{chat_id}.json"
            if not file_path.exists():
                return None

            with open(file_path, 'r', encoding='utf-8') as f:
                chat_data = json.load(f)

            self.current_chat_id = chat_id
            self.current_messages = chat_data.get("messages", [])
            self.chat_loaded.emit(chat_data)
            return chat_data
        except Exception as e:
            print(f"Error loading chat: {e}")
            return None

    def delete_chat(self, chat_id: str) -> bool:
        """
        Delete a chat file.

        Args:
            chat_id: Chat ID to delete

        Returns:
            bool: True if successful
        """
        try:
            file_path = self.chats_dir / f"{chat_id}.json"
            if file_path.exists():
                file_path.unlink()
                return True
            return False
        except Exception as e:
            print(f"Error deleting chat: {e}")
            return False

    def delete_all_chats(self) -> bool:
        """Delete all chat files."""
        results = [self.delete_chat(chat_id) for chat_id, _ in self.get_chat_files()]
        return all(results) if results else True

    def get_current_chat_id(self) -> Optional[str]:
        """Get the current chat ID."""
        return self.current_chat_id

    def get_current_messages(self) -> List[Dict[str, str]]:
        """Get the current messages list."""
        return self.current_messages.copy()

    def clear_current_chat(self):
        """Clear the current chat without saving."""
        self.current_chat_id = None
        self.current_messages = []

    def get_adjacent_chat_id(self, direction: str) -> Optional[str]:
        """Get the adjacent chat ID in the sorted list."""
        chat_files = self.get_chat_files()
        if not chat_files:
            return None

        if not self.current_chat_id:
            return chat_files[0][0] if direction == "left" else chat_files[-1][0]

        try:
            current_index = next(i for i, (cid, _) in enumerate(chat_files) if cid == self.current_chat_id)
        except StopIteration:
            # Not found, treat as newest
            return chat_files[-1][0] if direction == "left" else None

        if direction == "left" and current_index > 0:
            return chat_files[current_index - 1][0]
        elif direction == "right" and current_index < len(chat_files) - 1:
            return chat_files[current_index + 1][0]
        return None
```

### `core/services/file_service.py`

```python
# core/services/file_service.py
"""
File Service - Handles file loading, processing, and management for API transmission.
"""
import base64
from typing import Tuple, List
from PyQt6.QtCore import pyqtSignal, QObject


class FileService(QObject):
    """
    Service for handling file operations: loading, encoding for API transmission.
    Supports multiple files.
    """
    files_updated = pyqtSignal(list)  # list of filenames
    files_cleared = pyqtSignal()
    status_updated = pyqtSignal(str)

    def __init__(self):
        super().__init__()
        self.files_b64: List[str] = []
        self.filenames: List[str] = []

    def _add_file(self, b64: str, filename: str):
        """Add an encoded file and emit update signals."""
        self.files_b64.append(b64)
        self.filenames.append(filename)
        self.files_updated.emit(self.filenames.copy())
        count = len(self.filenames)
        self.status_updated.emit("File loaded." if count == 1 else f"File loaded. Total: {count} files.")

    def load_file_from_path(self, path: str) -> bool:
        """Load file from path and encode to base64. Appends to existing files list."""
        try:
            with open(path, "rb") as fh:
                b64 = base64.b64encode(fh.read()).decode("utf-8")
            self._add_file(b64, path.split('/')[-1].split('\\')[-1])
            return True
        except Exception as e:
            self.status_updated.emit(f"âŒ Failed to load file: {e}")
            return False

    def load_file_from_data(self, data: bytes, source: str = "") -> bool:
        """Load file from raw data and encode to base64. Appends to existing files list."""
        try:
            self._add_file(base64.b64encode(data).decode("utf-8"), source or "clipboard")
            return True
        except Exception as e:
            self.status_updated.emit(f"âŒ Error loading file: {e}")
            return False

    def clear_files(self):
        """Clear all files."""
        self.files_b64.clear()
        self.filenames.clear()
        self.files_cleared.emit()
        self.status_updated.emit("Files cleared.")

    def remove_file(self, index: int) -> bool:
        """
        Remove a specific file by index.

        Args:
            index: Index of file to remove

        Returns:
            bool: True if successful, False if index out of range
        """
        if 0 <= index < len(self.files_b64):
            self.files_b64.pop(index)
            removed_filename = self.filenames.pop(index)
            self.files_updated.emit(self.filenames.copy())
            self.status_updated.emit(f"Removed: {removed_filename}")
            return True
        return False

    def get_files(self) -> List[Tuple[str, str]]:
        """
        Get all file data.

        Returns:
            List of tuples (base64, filename)
        """
        return list(zip(self.files_b64, self.filenames))

    def has_files(self) -> bool:
        """Check if any files are currently loaded."""
        return len(self.files_b64) > 0
```

### `core/services/gallery_service.py`

```python
# core/services/gallery_service.py
"""
Gallery Service - Reads and caches image metadata from the generated images directory.
"""

from pathlib import Path
from dataclasses import dataclass
from typing import List, Dict

@dataclass
class ImageMetadata:
    filepath: str
    prompt: str
    service: str
    model: str
    timestamp: str


class GalleryService:
    def __init__(self):
        self._cache: Dict[str, tuple[float, ImageMetadata]] = {}
        self.images_dir = Path("images")
        self.images_dir.mkdir(exist_ok=True)
        
    def get_images(self, filter_service: str = "All") -> List[ImageMetadata]:
        images = []
        if not self.images_dir.exists():
            return images
            
        for p in self.images_dir.glob("*.jpg"):
            try:
                mtime = p.stat().st_mtime
                filepath_str = str(p)
                
                # Check cache mapping via modified time
                if filepath_str in self._cache and self._cache[filepath_str][0] == mtime:
                    meta = self._cache[filepath_str][1]
                else:
                    meta = self._parse_metadata(p)
                    self._cache[filepath_str] = (mtime, meta)
                    
                if filter_service == "All" or meta.service.lower() == filter_service.lower():
                    images.append(meta)
            except Exception:
                continue
                
        # Sort by filepath descending (newest timestamp first)
        images.sort(key=lambda x: x.filepath, reverse=True)
        return images
        
    def _parse_metadata(self, filepath: Path) -> ImageMetadata:
        prompt = ""
        service = "Unknown"
        model = "Unknown"
        timestamp = filepath.stem
        
        try:
            from PIL import Image
            with Image.open(filepath) as img:
                exif = img.getexif()
                if exif and 0x010E in exif:
                    meta_str = exif[0x010E]
                    parts = [p.strip() for p in meta_str.split("|")]
                    for part in parts:
                        if part.startswith("Prompt:"):
                            prompt = part[7:].strip()
                        elif part.startswith("Service:"):
                            service = part[8:].strip()
                        elif part.startswith("Model:"):
                            model = part[6:].strip()
        except Exception:
            pass
            
        return ImageMetadata(str(filepath), prompt, service, model, timestamp)
```

### `core/services/gemini_service.py`

```python
import os
import base64
from PyQt6.QtCore import pyqtSignal
from google import genai
from google.genai import types
from core.services.base_service import BaseAIService, BaseAIWorker

SAFETY_CATEGORIES = [
    "HARM_CATEGORY_HATE_SPEECH", "HARM_CATEGORY_DANGEROUS_CONTENT",
    "HARM_CATEGORY_SEXUALLY_EXPLICIT", "HARM_CATEGORY_HARASSMENT",
]


class GeminiWorker(BaseAIWorker):
    """Worker thread to handle streaming API calls to Google Gemini."""
    retry_with_new_key = pyqtSignal(str, int)

    def __init__(self, client, model_name, contents, config, attempt_count=0):
        super().__init__()
        self.client = client
        self.model_name = model_name
        self.contents = contents
        self.config = config
        self.attempt_count = attempt_count

    def run(self):
        try:
            response_stream = self.client.models.generate_content_stream(
                model=self.model_name, contents=self.contents, config=self.config
            )
            full_response, full_thinking = "", ""

            for chunk in response_stream:
                if self._is_cancelled:
                    break
                if hasattr(chunk, 'candidates') and chunk.candidates:
                    for candidate in chunk.candidates:
                        if hasattr(candidate, 'content') and candidate.content:
                            for part in candidate.content.parts:
                                if hasattr(part, 'thought') and part.thought and hasattr(part, 'text') and part.text:
                                    self.thinking_chunk.emit(part.text)
                                    full_thinking += part.text
                                elif hasattr(part, 'text') and part.text:
                                    self.chunk.emit(part.text)
                                    full_response += part.text
                elif hasattr(chunk, 'text') and chunk.text:
                    self.chunk.emit(chunk.text)
                    full_response += chunk.text

            if self._is_cancelled:
                self.error.emit("Generation interrupted by user.")
                return

            self._emit_result(full_response, full_thinking)

        except Exception as e:
            error_message = str(e)
            if "429" in error_message or "rate limit" in error_message.lower():
                self.retry_with_new_key.emit(error_message, self.attempt_count)
            else:
                self.error.emit(error_message)


class GeminiService(BaseAIService):
    """Service for interacting with Google Gemini API using google-genai SDK."""

    MODEL_MAP = {"Flash": "gemini-2.5-flash", "Pro": "gemini-2.5-pro"}
    MAX_FILE_SIZE = 15 * 1024 * 1024  # 15MB

    def __init__(self):
        super().__init__()
        self.api_keys = []
        self.current_key_index = 0
        self.rotation_attempts = 0
        self.client = None
        self._pending_request = None

        rotate_keys = os.environ.get("GEMINI_ROTATE_API_KEY")
        single_key = os.environ.get("GEMINI_API_KEY")
        if rotate_keys:
            self.api_keys = [k.strip() for k in rotate_keys.split(",") if k.strip()]
        elif single_key:
            self.api_keys = [single_key]

        if self.api_keys:
            try:
                self.client = genai.Client(api_key=self.api_keys[0])
            except Exception as e:
                print(f"Failed to initialize Gemini Client: {e}")

    def _emit_error(self, message: str):
        """Emit error to both status and error signals, clear pending request."""
        self.status_updated.emit(f"Error: {message}")
        self.error_occurred.emit(message)
        self._pending_request = None

    def _build_and_start(self):
        """Build request from pending parameters and start worker."""
        if not self._pending_request or not self.client:
            return

        params = self._pending_request
        files_data = params.get('files_data')
        user_input = params['user_input']

        if not user_input.strip() and not files_data:
            return self._emit_error("Input cannot be empty.")

        if files_data:
            for fd in files_data:
                if fd.get('file_size', 0) > self.MAX_FILE_SIZE:
                    return self._emit_error(f"File '{fd.get('filename', 'Unknown')}' too large. Maximum size: 15MB.")

        # Build conversation history
        contents = []
        for msg in (params.get('conversation_history') or []):
            role, content = msg.get("role", ""), msg.get("content", "")
            if not content:
                continue
            api_role = "model" if role == "assistant" else "user"
            try:
                contents.append(types.Content(role=api_role, parts=[types.Part.from_text(text=content)]))
            except Exception:
                contents.append({"role": api_role, "parts": [{"text": content}]})

        # Build current message parts
        current_parts = []
        if files_data:
            for fd in files_data:
                try:
                    if b64 := fd.get('base64'):
                        current_parts.append(types.Part.from_bytes(
                            data=base64.b64decode(b64),
                            mime_type=fd.get('mime_type', 'application/octet-stream')
                        ))
                except Exception as e:
                    return self._emit_error(f"Error processing file '{fd.get('filename', 'Unknown')}': {e}")

        if user_input.strip():
            current_parts.append(types.Part.from_text(text=user_input))
        if current_parts:
            contents.append(types.Content(role="user", parts=current_parts))

        config = types.GenerateContentConfig(
            system_instruction=params['system_prompt'],
            safety_settings=[types.SafetySetting(category=c, threshold="BLOCK_NONE") for c in SAFETY_CATEGORIES],
            thinking_config=types.ThinkingConfig(include_thoughts=True, thinking_budget=8192)
        )

        api_model = self.MODEL_MAP.get(params['model_name'], "gemini-2.5-flash")
        self._start_worker(GeminiWorker(self.client, api_model, contents, config, self.rotation_attempts))

    def generate_response(self, system_prompt, user_input, model_name="Flash",
                          conversation_history=None, files_data=None):
        """Generate a response using the Gemini API in a background thread."""
        self.rotation_attempts = 0
        if self.api_keys:
            self.current_key_index = 0

        if not self.client:
            msg = "No Gemini API keys configured." if not self.api_keys else "Failed to initialize Gemini client."
            return self._emit_error(msg)

        self._pending_request = {
            'system_prompt': system_prompt, 'user_input': user_input,
            'model_name': model_name, 'conversation_history': conversation_history,
            'files_data': files_data
        }
        self.status_updated.emit(f"Generating response using {model_name}...")
        self._build_and_start()

    def _handle_success(self, response_text: str):
        super()._handle_success(response_text)
        self._pending_request = None

    def _handle_error(self, error_message: str):
        super()._handle_error(error_message)
        self._pending_request = None

    def _handle_retry(self, error_message: str, attempt_count: int):
        """Handle retry on 429 errors by rotating API keys."""
        if not self._pending_request:
            return self._emit_error(error_message)

        if len(self.api_keys) <= 1:
            return self._emit_error("All API keys rate limited.")

        self.current_key_index = (self.current_key_index + 1) % len(self.api_keys)
        self.rotation_attempts += 1
        self.status_updated.emit(f"API Key Rate Limited. Rotating to next key (attempt {attempt_count + 1})...")

        try:
            self.client = genai.Client(api_key=self.api_keys[self.current_key_index])
        except Exception:
            return self._emit_error("Failed to recreate client with new API key.")

        self._build_and_start()
```

### `core/services/nvidia_nim_service.py`

```python
# nvidia_nim_service.py
import os
from openai import OpenAI
from core.services.base_service import BaseAIService, BaseAIWorker

class NvidiaNimWorker(BaseAIWorker):
    """
    Worker thread to handle streaming API calls to NVIDIA NIM via OpenAI SDK.
    """
    # Model-specific thinking configurations
    # Different models use different parameter names for thinking/reasoning
    THINKING_CONFIGS = {
        "deepseek-ai/deepseek-v3.2": {"thinking": True},
        "moonshotai/kimi-k2-thinking": None,  # Thinking built into model
        "moonshotai/kimi-k2.5": {"thinking": True},
        "z-ai/glm4.7": {"enable_thinking": True, "clear_thinking": False},
        "z-ai/glm5": {"enable_thinking": True, "clear_thinking": False},
        "qwen/qwen3.5-397b-a17b": {"enable_thinking": True},
    }

    def __init__(self, client, model_name, messages):
        super().__init__()
        self.client = client
        self.model_name = model_name
        self.messages = messages

    def run(self):
        try:
            # Build request parameters
            request_params = {
                "model": self.model_name,
                "messages": self.messages,
                "stream": True
            }
            
            # Add model-specific thinking parameter if supported
            thinking_config = self.THINKING_CONFIGS.get(self.model_name)
            if thinking_config:
                request_params["extra_body"] = {"chat_template_kwargs": thinking_config}
            
            # Use streaming API
            response_stream = self.client.chat.completions.create(**request_params)
            
            full_response = ""
            full_thinking = ""
            
            for chunk in response_stream:
                if self._is_cancelled:
                    break
                if chunk.choices and len(chunk.choices) > 0:
                    delta = chunk.choices[0].delta
                    
                    # Check for reasoning content (DeepSeek, Kimi K2 format)
                    if hasattr(delta, 'reasoning_content') and delta.reasoning_content:
                        self.thinking_chunk.emit(delta.reasoning_content)
                        full_thinking += delta.reasoning_content
                    
                    # Regular content
                    if hasattr(delta, 'content') and delta.content:
                        self.chunk.emit(delta.content)
                        full_response += delta.content
            
            if self._is_cancelled:
                self.error.emit("Generation interrupted by user.")
                return

            self._emit_result(full_response, full_thinking)

        except Exception as e:
            self.error.emit(str(e))

class NvidiaNimService(BaseAIService):
    """Service for interacting with NVIDIA NIM API using OpenAI SDK."""

    # Model mapping: GUI friendly name -> API model ID
    MODEL_MAP = {
        "DeepSeek V3.2": "deepseek-ai/deepseek-v3.2",
        "Kimi K2": "moonshotai/kimi-k2-thinking",
        "Kimi K2.5": "moonshotai/kimi-k2.5",
        "GLM-4.7": "z-ai/glm4.7",
        "GLM-5": "z-ai/glm5",
        "Qwen3.5-397B-A17B": "qwen/qwen3.5-397b-a17b",
    }

    # Models that support image/vision input
    VISION_MODELS = {"Kimi K2.5", "Qwen3.5-397B-A17B"}

    def __init__(self):
        super().__init__()
        self.api_key = os.environ.get("NVIDIA_NIM_API_KEY")
        self.client = None

        if self.api_key:
            try:
                # Initialize OpenAI client with NVIDIA NIM base URL
                self.client = OpenAI(
                    api_key=self.api_key,
                    base_url="https://integrate.api.nvidia.com/v1"
                )
            except Exception as e:
                print(f"Failed to initialize NVIDIA NIM Client: {e}")
        else:
            print("Warning: NVIDIA_NIM_API_KEY environment variable not set.")
            print("NVIDIA NIM service will be unavailable until API key is configured.")

    def _emit_error(self, message: str):
        self.status_updated.emit(f"Error: {message}")
        self.error_occurred.emit(message)

    def generate_response(self, system_prompt: str, user_input: str, model_name: str = "DeepSeek V3.2", conversation_history: list = None, **kwargs):
        """Generates a response using the NVIDIA NIM API in a background thread."""
        if not self.client:
            return self._emit_error("NVIDIA_NIM_API_KEY not found.")

        files_data = kwargs.get('files_data', [])
        is_vision = model_name in self.VISION_MODELS
        has_images = is_vision and any(
            f.get('mime_type', '').startswith('image/') for f in files_data
        )

        if not user_input.strip() and not has_images:
            return self._emit_error("Input cannot be empty.")

        api_model = self.MODEL_MAP.get(model_name, "deepseek-ai/deepseek-v3.2")
        self.status_updated.emit(f"Generating response using NVIDIA NIM {model_name}...")

        messages = []
        if system_prompt:
            messages.append({"role": "system", "content": system_prompt})
        if conversation_history:
            messages.extend([
                {"role": m.get("role", ""), "content": m.get("content", "")}
                for m in conversation_history if m.get("content")
            ])

        # Build user message: multipart content for vision models with images,
        # plain text otherwise
        if has_images:
            content_parts = []
            if user_input.strip():
                content_parts.append({"type": "text", "text": user_input})
            for file_data in files_data:
                mime = file_data.get('mime_type', '')
                if mime.startswith('image/'):
                    content_parts.append({
                        "type": "image_url",
                        "image_url": {
                            "url": f"data:{mime};base64,{file_data['base64']}"
                        }
                    })
            messages.append({"role": "user", "content": content_parts})
        else:
            messages.append({"role": "user", "content": user_input})

        worker = NvidiaNimWorker(self.client, api_model, messages)
        self._start_worker(worker)
```

### `core/services/perchance_service.py`

```python
# core/services/perchance_service.py
"""
Perchance Service â€“ WebEngine profile management, ad blocking, and image
download handling for the embedded Perchance image generator.
"""

import os
from datetime import datetime
from pathlib import Path

_WEBENGINE_AVAILABLE = False
try:
    from PyQt6.QtWebEngineCore import (
        QWebEngineProfile,
        QWebEnginePage,
        QWebEngineUrlRequestInterceptor,
    )
    _WEBENGINE_AVAILABLE = True
except ImportError:
    QWebEngineUrlRequestInterceptor = None


def is_webengine_available() -> bool:
    """Return *True* if PyQt6-WebEngine is installed and importable."""
    return _WEBENGINE_AVAILABLE


# â”€â”€ Ad-block request interceptor â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

if _WEBENGINE_AVAILABLE:

    class AdBlockInterceptor(QWebEngineUrlRequestInterceptor):
        """Block network requests whose URL contains a blocked-domain substring."""

        def __init__(self, blocked_domains: list, parent=None):
            super().__init__(parent)
            self.blocked_domains = blocked_domains or []

        def interceptRequest(self, info):
            url = info.requestUrl().toString()
            for domain in self.blocked_domains:
                if domain in url:
                    info.block(True)
                    return


# â”€â”€ Service class â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

class PerchanceService:
    """
    Creates a persistent WebEngine profile with ad-blocking and handles
    image downloads from the embedded Perchance page.
    """

    DEFAULT_BLOCKED_DOMAINS = [
        "a.pub.network",
        "d.pub.network",
        "cdn.snigelweb.com",
        "googletagmanager.com",
        "cloudflareinsights.com",
        "static.criteo.net",
        "secure.quantserve.com",
        "fundingchoicesmessages.google.com",
    ]

    DEFAULT_HIDDEN_SELECTORS = [
        ".ad-providers-ctn-el",
        "#adCtn",
        "#pmLink",
    ]

    def __init__(self, config_manager=None):
        self.config_manager = config_manager
        self._profile = None
        self._interceptor = None
        self._page = None
        self._status_callback = None

    # -- External setters ------------------------------------------------

    def set_page(self, page):
        """Store a reference to the active QWebEnginePage for JS access."""
        self._page = page

    def set_status_callback(self, callback):
        """Register a callable for status messages (e.g. a pyqtSignal emit)."""
        self._status_callback = callback

    def _emit_status(self, msg: str):
        if self._status_callback:
            self._status_callback(msg)

    # â”€â”€ Profile creation â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    def create_profile(self, parent=None):
        """
        Build a *persistent* QWebEngineProfile:

        * Disk-backed cookies (login survives restarts)
        * Ad-blocking request interceptor
        * Download-requested handler for saving images

        Returns the profile, or ``None`` when WebEngine is unavailable.
        """
        if not _WEBENGINE_AVAILABLE:
            return None

        from PyQt6.QtCore import QStandardPaths

        base = QStandardPaths.writableLocation(
            QStandardPaths.StandardLocation.AppDataLocation
        )
        storage_root = os.path.join(base, "webengine", "perchance")
        os.makedirs(storage_root, exist_ok=True)

        profile = QWebEngineProfile("perchance", parent)
        profile.setPersistentStoragePath(os.path.join(storage_root, "storage"))
        profile.setCachePath(os.path.join(storage_root, "cache"))
        profile.setHttpCacheType(QWebEngineProfile.HttpCacheType.DiskHttpCache)

        try:
            profile.setPersistentCookiesPolicy(
                QWebEngineProfile.PersistentCookiesPolicy.ForcePersistentCookies
            )
        except AttributeError:
            pass  # older PyQt6 build without this enum

        # Layer 1 â€“ network-level ad blocking
        blocked = self._get_blocked_domains()
        if blocked:
            self._interceptor = AdBlockInterceptor(blocked, parent)
            profile.setUrlRequestInterceptor(self._interceptor)

        # Image download handling
        profile.downloadRequested.connect(self._on_download_requested)

        self._profile = profile
        return profile

    # â”€â”€ Ad-hide JavaScript (Layer 2) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    def get_ad_hide_script(self) -> str:
        """
        Return a JavaScript snippet that hides ad-related DOM elements and
        watches for dynamically inserted ones via MutationObserver.
        """
        selectors = self._get_hidden_selectors()
        if not selectors:
            return ""

        selectors_js = ", ".join(f'"{s}"' for s in selectors)
        return f"""
(function() {{
    if (window._perchanceAdblockActive) return;
    window._perchanceAdblockActive = true;

    var selectors = [{selectors_js}];

    function hide() {{
        selectors.forEach(function(s) {{
            document.querySelectorAll(s).forEach(function(el) {{
                el.style.setProperty('display', 'none', 'important');
                el.style.setProperty('visibility', 'hidden', 'important');
                el.style.position = 'absolute';
                el.style.left = '-9999px';
            }});
        }});
    }}

    hide();
    setTimeout(hide, 1000);
    setTimeout(hide, 3000);

    var obs = new MutationObserver(function() {{ hide(); }});
    if (document.body) {{
        obs.observe(document.body, {{ childList: true, subtree: true }});
    }} else {{
        document.addEventListener('DOMContentLoaded', function() {{
            hide();
            obs.observe(document.body, {{ childList: true, subtree: true }});
        }});
    }}
}})();
"""

    # â”€â”€ Download handling â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    def _on_download_requested(self, download):
        """
        Accept image downloads and redirect them to ``images/`` with a
        timestamp-based temporary filename.  Non-image downloads are
        silently ignored.
        """
        try:
            mime_type = (download.mimeType() or "").lower()
            dl_name = (download.downloadFileName() or "").lower()
            is_image = mime_type.startswith("image/") or dl_name.endswith(
                (".png", ".jpg", ".jpeg", ".webp", ".gif")
            )
            if not is_image:
                return

            images_dir = Path("images")
            images_dir.mkdir(exist_ok=True)

            timestamp = datetime.now().strftime("%Y-%m-%d_%H-%M-%S")
            orig_ext = Path(download.downloadFileName() or "image.png").suffix or ".png"
            temp_name = f"_perchance_tmp_{timestamp}{orig_ext}"

            download.setDownloadDirectory(str(images_dir.resolve()))
            download.setDownloadFileName(temp_name)

            # Best-effort prompt capture via async JS callback
            captured = {"prompt": ""}
            if self._page:
                self._page.runJavaScript(
                    "(function(){var e=document.querySelector('textarea');"
                    "return e?e.value:'';})()",
                    lambda result, c=captured: c.update({"prompt": result or ""}),
                )

            temp_path = images_dir / temp_name

            download.isFinishedChanged.connect(
                lambda tp=temp_path, ts=timestamp, cap=captured: self._finalize_download(
                    tp, ts, cap
                )
            )

            download.accept()
            self._emit_status("Downloading image from Perchance\u2026")

        except Exception as e:
            self._emit_status(f"Download error: {e}")

    def _finalize_download(self, temp_path: Path, timestamp: str, captured: dict):
        """
        Post-process a completed download:

        1. Open with Pillow (if available)
        2. Convert to RGB JPEG
        3. Embed EXIF metadata (prompt + service)
        4. Remove the temporary file

        Falls back to a simple rename when Pillow is absent.
        """
        if not temp_path.exists():
            return
        try:
            if temp_path.stat().st_size == 0:
                temp_path.unlink(missing_ok=True)
                return
        except OSError:
            return

        images_dir = temp_path.parent
        prompt = captured.get("prompt", "")

        # Determine unique final path
        final_path = images_dir / f"{timestamp}.jpg"
        counter = 1
        while final_path.exists():
            final_path = images_dir / f"{timestamp}_{counter}.jpg"
            counter += 1

        saved = False
        try:
            from PIL import Image

            img = Image.open(str(temp_path))
            if img.mode in ("RGBA", "P", "LA"):
                img = img.convert("RGB")

            parts = []
            if prompt:
                parts.append(f"Prompt: {prompt}")
            parts.append("Service: Perchance")
            metadata_str = " | ".join(parts)

            exif = img.getexif()
            exif[0x010E] = metadata_str      # ImageDescription
            exif[0x0131] = "Perchance AI"    # Software
            img.save(str(final_path), "JPEG", quality=95, exif=exif.tobytes())
            saved = True
        except ImportError:
            pass
        except Exception as e:
            self._emit_status(f"Image conversion note: {e}")

        if not saved:
            # Fallback: rename temp file directly
            try:
                temp_path.rename(final_path)
                saved = True
            except OSError:
                pass

        # Clean up temp file (Pillow path leaves it behind)
        if temp_path.exists():
            try:
                temp_path.unlink(missing_ok=True)
            except OSError:
                pass

        if saved:
            self._emit_status(f"Image saved: {final_path.name}")

    # â”€â”€ Config helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    def _get_blocked_domains(self) -> list:
        if self.config_manager:
            ab = getattr(self.config_manager, "adblocker", {})
            if isinstance(ab, dict) and ab.get("blocked_domains"):
                return ab["blocked_domains"]
        return self.DEFAULT_BLOCKED_DOMAINS

    def _get_hidden_selectors(self) -> list:
        if self.config_manager:
            ab = getattr(self.config_manager, "adblocker", {})
            if isinstance(ab, dict) and ab.get("hidden_selectors"):
                return ab["hidden_selectors"]
        return self.DEFAULT_HIDDEN_SELECTORS
```

### `core/services/pollinations_service.py`

```python
# core/services/pollinations_service.py
"""
Pollinations AI Image Generation Service.
Handles API communication with Pollinations for text-to-image generation.
"""

import os
import urllib.request
import urllib.parse
import urllib.error

from PyQt6.QtCore import QObject, pyqtSignal, QThread

from core.utils import save_generated_image


class PollinationsWorker(QThread):
    """Worker thread for Pollinations API image generation."""
    finished = pyqtSignal(str)
    error = pyqtSignal(str)

    BASE_URL = "https://gen.pollinations.ai/image"

    def __init__(self, prompt, negative_prompt, model, width, height, seed):
        super().__init__()
        self.prompt = prompt
        self.negative_prompt = negative_prompt
        self.model = model
        self.width = width
        self.height = height
        self.seed = seed
        self._is_cancelled = False
        self.api_key = os.environ.get("POLLINATIONS_API_KEY", "")

    def cancel(self):
        self._is_cancelled = True

    def run(self):
        try:
            encoded_prompt = urllib.parse.quote(self.prompt, safe="")
            params = {
                "model": self.model,
                "width": self.width,
                "height": self.height,
                "seed": self.seed,
                "nologo": "true",
            }
            if self.negative_prompt:
                params["negative_prompt"] = self.negative_prompt

            query_string = urllib.parse.urlencode(params)
            full_url = f"{self.BASE_URL}/{encoded_prompt}?{query_string}"

            headers = {"User-Agent": "ImagePrompter/1.0"}
            if self.api_key:
                headers["Authorization"] = f"Bearer {self.api_key}"

            req = urllib.request.Request(full_url, headers=headers)
            response = urllib.request.urlopen(req, timeout=180)

            if self._is_cancelled:
                self.error.emit("Generation cancelled.")
                return

            content_type = response.headers.get("Content-Type", "")
            if "image" not in content_type:
                body = response.read(500).decode("utf-8", errors="replace")
                self.error.emit(f"Unexpected response ({content_type}): {body}")
                return

            image_data = response.read()

            if self._is_cancelled:
                self.error.emit("Generation cancelled.")
                return

            filepath = save_generated_image(
                image_data, self.prompt, self.negative_prompt,
                self.model, f"{self.width}x{self.height}", self.seed,
                "Pollinations",
            )
            self.finished.emit(filepath)

        except urllib.error.HTTPError as e:
            if not self._is_cancelled:
                body = ""
                try:
                    body = e.read(300).decode("utf-8", errors="replace")
                except Exception:
                    pass
                self.error.emit(f"HTTP {e.code}: {body or e.reason}")
        except urllib.error.URLError as e:
            if not self._is_cancelled:
                self.error.emit(f"Connection error: {e.reason}")
        except Exception as e:
            if not self._is_cancelled:
                self.error.emit(str(e))

class PollinationsService(QObject):
    """Service for Pollinations AI image generation."""
    image_generated = pyqtSignal(str)
    status_updated = pyqtSignal(str)
    error_occurred = pyqtSignal(str)

    def __init__(self):
        super().__init__()
        self.worker = None

    def generate_image(self, prompt, negative_prompt="", model="zimage",
                       width=1024, height=1024, seed=-1):
        """Start image generation in a background thread."""
        if not prompt.strip():
            self.error_occurred.emit("Prompt cannot be empty.")
            self.status_updated.emit("Error: Prompt cannot be empty.")
            return

        self.status_updated.emit(f"Generating with {model} ({width}x{height})...")

        self.worker = PollinationsWorker(
            prompt, negative_prompt, model, width, height, seed
        )
        self.worker.finished.connect(self._on_finished)
        self.worker.error.connect(self._on_error)
        self.worker.finished.connect(self.worker.deleteLater)
        self.worker.error.connect(self.worker.deleteLater)
        self.worker.start()

    def _on_finished(self, filepath):
        if self.sender() is not self.worker:
            return
        self.worker = None
        self.image_generated.emit(filepath)
        self.status_updated.emit(f"Image saved: {filepath}")

    def _on_error(self, msg):
        if self.sender() is not self.worker:
            return
        self.worker = None
        self.error_occurred.emit(msg)
        self.status_updated.emit(f"Error: {msg}")

    def cancel_generation(self):
        """Cancel the current generation if running."""
        if self.worker and self.worker.isRunning():
            self.worker.cancel()
```

### `core/utils.py`

```python
# core/utils.py
"""Shared utility functions for the application."""

import os
import sys
import subprocess
from datetime import datetime
from pathlib import Path


def reveal_file_in_explorer(filepath: str) -> bool:
    """
    Open the system file explorer and select/highlight the given file.

    Platform behavior:
        Windows: explorer /select,<path>
        macOS:   open -R <path>
        Linux:   xdg-open <parent directory>

    Returns True if the command was launched, False on error or missing file.
    """
    filepath = os.path.normpath(os.path.abspath(filepath))
    if not os.path.exists(filepath):
        return False
    try:
        if sys.platform == "win32":
            subprocess.Popen(["explorer", f"/select,{filepath}"])
        elif sys.platform == "darwin":
            subprocess.Popen(["open", "-R", filepath])
        else:
            subprocess.Popen(["xdg-open", os.path.dirname(filepath)])
        return True
    except Exception:
        return False


def open_file(filepath: str) -> bool:
    """
    Open a file with the system's default application.

    Returns True if the command was launched, False on error or missing file.
    """
    filepath = os.path.normpath(os.path.abspath(filepath))
    if not os.path.exists(filepath):
        return False
    try:
        if sys.platform == "win32":
            os.startfile(filepath)
        elif sys.platform == "darwin":
            subprocess.Popen(["open", filepath])
        else:
            subprocess.Popen(["xdg-open", filepath])
        return True
    except Exception:
        return False


def save_generated_image(
    image_data: bytes,
    prompt: str,
    negative_prompt: str,
    model: str,
    size: str,
    seed: int,
    service: str,
) -> str:
    """Save generated image to the images/ directory with embedded EXIF metadata.

    Uses a timestamp-based filename (``YYYY-MM-DD_HH-MM-SS.jpg``) and embeds
    prompt / generation metadata into the EXIF ImageDescription tag when
    Pillow is available.

    Args:
        image_data:      Raw image bytes (any format Pillow can open).
        prompt:          Positive prompt text.
        negative_prompt: Negative prompt text (may be empty).
        model:           Model identifier string.
        size:            Size string, e.g. ``"1024x1024"``.
        seed:            Seed value used for generation.
        service:         Service name (e.g. ``"Pollinations"``, ``"Airforce"``).

    Returns:
        The absolute-ish path to the saved file as a string.
    """
    images_dir = Path("images")
    images_dir.mkdir(exist_ok=True)

    timestamp = datetime.now().strftime("%Y-%m-%d_%H-%M-%S")
    filepath = images_dir / f"{timestamp}.jpg"
    counter = 1
    while filepath.exists():
        filepath = images_dir / f"{timestamp}_{counter}.jpg"
        counter += 1

    metadata_str = (
        f"Prompt: {prompt} | "
        f"Negative: {negative_prompt or 'None'} | "
        f"Model: {model} | "
        f"Size: {size} | "
        f"Seed: {seed} | "
        f"Service: {service}"
    )

    saved_with_meta = False
    try:
        from PIL import Image
        import io

        img = Image.open(io.BytesIO(image_data))
        if img.mode in ("RGBA", "P", "LA"):
            img = img.convert("RGB")

        exif = img.getexif()
        exif[0x010E] = metadata_str        # ImageDescription
        exif[0x0131] = f"{service} AI"     # Software
        img.save(str(filepath), "JPEG", quality=95, exif=exif.tobytes())
        saved_with_meta = True
    except Exception:
        pass

    if not saved_with_meta:
        with open(filepath, "wb") as f:
            f.write(image_data)

    return str(filepath)
```

### `gui/main_window.py`

```python
# gui/main_window.py
"""
Main Window GUI - Constructs the main application window with a split-pane layout.
Primary chat pane (left) with scoped footer, secondary media pane (right) with tabs.
"""
from PyQt6.QtWidgets import QApplication, QMainWindow, QWidget, QVBoxLayout, QLabel, QSplitter
from PyQt6.QtCore import pyqtSignal, Qt
from PyQt6.QtGui import QIcon, QShortcut, QKeySequence
from gui.widgets.action_buttons_panel import ActionButtonsPanel
from gui.widgets.input_panel import InputPanel
from gui.widgets.response_panel import ResponsePanel
from gui.widgets.media_panel import MediaPanel


class MainWindow(QMainWindow):
    """Main application window with asymmetrical split-pane layout."""

    status_signal = pyqtSignal(str)

    def __init__(self, file_service, config_manager=None):
        super().__init__()
        self.file_service = file_service
        self.config_manager = config_manager
        self.file_service.files_updated.connect(self._on_files_updated)
        self.file_service.status_updated.connect(self.status_signal.emit)
        self.file_service.files_cleared.connect(self._on_files_cleared)
        self.setWindowTitle("PyQt6 Chat Framework")
        self.setWindowIcon(QIcon("assets/icons/app_icon.ico"))
        self.setStyleSheet("""
            QMainWindow, QStatusBar { background-color: #1a1a1a; }
            QLabel { color: #ffffff; font-family: Arial; }
            QPushButton { background-color: #3d3d3d; color: #ffffff; border: 1px solid #333; padding: 8px; font-family: Arial; font-size: 9pt; border-radius: 4px; }
            QPushButton:hover { background-color: #4d4d4d; }
            QPushButton:pressed { background-color: #2d2d2d; }
            QTextEdit { background-color: #1e1e1e; color: #ffffff; border: 1px solid #333; font-family: Consolas; font-size: 9pt; }
            QStatusBar { color: #888888; font-size: 8pt; }
            QSplitter::handle {
                background-color: #333333;
            }
            QSplitter::handle:hover {
                background-color: #4d4d4d;
            }
            QSplitter::handle:pressed {
                background-color: #1E88E5;
            }
        """)

        central = QWidget()
        self.setCentralWidget(central)
        main_layout = QVBoxLayout(central)
        main_layout.setContentsMargins(10, 10, 10, 5)
        main_layout.setSpacing(5)

        # --- Horizontal splitter: chat pane | media pane ---
        self.splitter = QSplitter(Qt.Orientation.Horizontal)
        self.splitter.setHandleWidth(5)
        self.splitter.setChildrenCollapsible(False)

        # Left pane: Chat (response + input + action buttons)
        chat_pane = QWidget()
        chat_pane.setMinimumWidth(400)
        chat_pane_layout = QVBoxLayout(chat_pane)
        chat_pane_layout.setContentsMargins(0, 0, 0, 0)
        chat_pane_layout.setSpacing(10)
        self._build_chat_pane(chat_pane_layout)
        self.splitter.addWidget(chat_pane)

        # Right pane: Media (tabbed image generation interface)
        self.media_panel = MediaPanel(self.config_manager)
        self.media_panel.setMinimumWidth(280)
        self.splitter.addWidget(self.media_panel)

        # Default asymmetric split ~65/35, stretch ratio 3:2
        self.splitter.setSizes([780, 420])
        self.splitter.setStretchFactor(0, 3)
        self.splitter.setStretchFactor(1, 2)

        main_layout.addWidget(self.splitter, 1)

        # --- Status bar ---
        self.status_label = QLabel("Ready")
        self.status_label.setStyleSheet("color: #888; font-size: 8pt;")
        self.status_signal.connect(self.status_label.setText)
        main_layout.addWidget(self.status_label, 0, Qt.AlignmentFlag.AlignLeft)

        self.status_signal.emit("Ready")
        self._setup_shortcuts()

    def _setup_shortcuts(self):
        """Set up global keyboard shortcuts."""
        search_shortcut = QShortcut(QKeySequence.StandardKey.Find, self)
        search_shortcut.activated.connect(self.response_panel.show_search)

        nav_left_shortcut = QShortcut(QKeySequence("Ctrl+Left"), self)
        nav_left_shortcut.activated.connect(lambda: self.action_buttons_panel.navigate_left_signal.emit())

        nav_right_shortcut = QShortcut(QKeySequence("Ctrl+Right"), self)
        nav_right_shortcut.activated.connect(lambda: self.action_buttons_panel.navigate_right_signal.emit())

        delete_all_shortcut = QShortcut(QKeySequence("Ctrl+D"), self)
        delete_all_shortcut.activated.connect(lambda: self.action_buttons_panel.delete_all_chats_signal.emit())

    def _build_chat_pane(self, layout):
        """Build the primary chat pane with response, input, and action buttons."""
        self.main_panel_layout = layout

        # Response panel (takes all available vertical space)
        self.response_panel = ResponsePanel()
        layout.addWidget(self.response_panel)

        # Input panel (scoped footer - dynamic height)
        self.input_panel = InputPanel()
        layout.addWidget(self.input_panel)

        # Action buttons panel (scoped footer - fixed height)
        self.action_buttons_panel = ActionButtonsPanel(self.file_service)
        layout.addWidget(self.action_buttons_panel)

        self.input_panel.text_content_changed_signal.connect(self.action_buttons_panel.update_text_action_buttons)

        layout.setStretchFactor(self.response_panel, 1)
        layout.setStretchFactor(self.input_panel, 0)
        layout.setStretchFactor(self.action_buttons_panel, 0)

    def _on_files_cleared(self):
        self.action_buttons_panel.select_file_signal.emit("", "")

    def _on_files_updated(self, filenames):
        """Handle files updated signal - update status bar with file list."""
        if not filenames:
            self.status_signal.emit("No files selected.")
            return
        if len(filenames) == 1:
            self.status_signal.emit(f"File ready: {filenames[0]}")
        elif len(filenames) <= 3:
            self.status_signal.emit(f"Files ready: {', '.join(filenames)}")
        else:
            self.status_signal.emit(f"Files ready: {', '.join(filenames[:3])}... ({len(filenames)} total)")

    def keyPressEvent(self, event):
        """Handle keyboard events - Ctrl+V for clipboard paste."""
        modifiers = event.modifiers()
        if (modifiers & Qt.KeyboardModifier.ControlModifier) and event.key() == Qt.Key.Key_V:
            clipboard = QApplication.clipboard()
            mime_data = clipboard.mimeData()
            if mime_data.hasImage():
                img = clipboard.image()
                if not img.isNull():
                    from PyQt6.QtCore import QBuffer, QIODevice
                    buf = QBuffer()
                    buf.open(QIODevice.OpenModeFlag.WriteOnly)
                    img.save(buf, "PNG")
                    self.file_service.load_file_from_data(bytes(buf.data()), "clipboard.png")
                    return
        super().keyPressEvent(event)

    def get_input_text(self) -> str:
        """Get the text from the input text edit."""
        return self.input_panel.get_input_text()

    def closeEvent(self, event):
        """Handle window close event to save window size and splitter state."""
        if getattr(self, 'config_manager', None):
            self.config_manager.window_width = self.width()
            self.config_manager.window_height = self.height()
            self.config_manager.splitter_sizes = self.splitter.sizes()
            self.config_manager.save()
        event.accept()
```

### `gui/widgets/action_buttons_panel.py`

```python
# gui/widgets/action_buttons_panel.py
"""
Action Buttons Panel - Contains action buttons for the chat framework GUI.
"""

from PyQt6.QtWidgets import QWidget, QHBoxLayout, QPushButton, QSizePolicy, QFileDialog, QVBoxLayout, QGridLayout
from PyQt6.QtCore import pyqtSignal, Qt, QBuffer, QIODevice, QTimer, QEvent
from PyQt6.QtGui import QCursor



class ActionButtonsPanel(QWidget):
    """A panel containing all action buttons for the chat framework."""

    # Signals
    interrupt_signal = pyqtSignal()
    service_model_selected_signal = pyqtSignal(str, str)  # service, model
    select_file_signal = pyqtSignal(str, str)  # base64, filename
    send_signal = pyqtSignal()
    new_chat_signal = pyqtSignal()
    delete_chat_signal = pyqtSignal()
    delete_all_chats_signal = pyqtSignal()
    navigate_left_signal = pyqtSignal()
    navigate_right_signal = pyqtSignal()
    display_toggled_signal = pyqtSignal(dict)

    # Service to available models mapping
    SERVICE_MODELS = {
        "Gemini": ["Flash", "Pro"],
        "NVIDIA NIM": ["DeepSeek V3.2", "Kimi K2", "Kimi K2.5", "GLM-4.7", "GLM-5", "Qwen3.5-397B-A17B"]
    }

    # NVIDIA NIM models that support image/vision input
    NIM_VISION_MODELS = {"Kimi K2.5", "Qwen3.5-397B-A17B"}

    SERVICE_MODEL_OPTIONS = [(s, m) for s, models in SERVICE_MODELS.items() for m in models]

    def __init__(self, file_service, parent=None):
        super().__init__(parent)
        self.file_service = file_service
        self.file_service.files_updated.connect(self._update_file_controls_state)
        self.file_service.files_cleared.connect(self._update_file_controls_state)
        
        self._is_generating = False

        # Hover menu state
        self.active_dropdown = None
        self.hide_timer = QTimer()
        self.hide_timer.setInterval(250)
        self.hide_timer.timeout.connect(self._hide_dropdown)

        self.layout = QHBoxLayout(self)
        self.layout.setContentsMargins(0, 0, 0, 0)

        # Current selections
        self.current_service = "Gemini"
        self.current_model = "Flash"

        self._create_buttons()

    BLUE = ("#1E88E5", "#2A9BF8", "#1966C2")
    GREEN = ("#4CAF50", "#5CBF60", "#45A049")
    RED = ("#F44336", "#EF5350", "#D32F2F")
    GREY = ("#9E9E9E", "#BDBDBD", "#757575")
    ORANGE = ("#FF6B35", "#FF8C5A", "#E5562A")

    @staticmethod
    def _btn_style(colors, padding="8px"):
        bg, hover, pressed = colors
        return f"""
            QPushButton {{ background-color: {bg}; color: white; font-weight: bold; font-size: 10pt; border: 2px solid {bg}; border-radius: 4px; padding: {padding}; }}
            QPushButton:hover {{ background-color: {hover}; border-color: {hover}; }}
            QPushButton:pressed {{ background-color: {pressed}; border-color: {pressed}; }}
            QPushButton:disabled {{ background-color: #CCCCCC; color: #666666; border-color: #CCCCCC; }}
        """

    def _create_buttons(self):
        def make_btn(text, style, tooltip=""):
            btn = QPushButton(text)
            btn.setStyleSheet(style)
            btn.setCursor(QCursor(Qt.CursorShape.PointingHandCursor))
            btn.setFocusPolicy(Qt.FocusPolicy.NoFocus)
            if tooltip: btn.setToolTip(tooltip)
            return btn

        self.service_model_btn = make_btn(f"{self.current_service}:{self.current_model}", self._btn_style(self.BLUE))
        self.service_model_btn.installEventFilter(self)
        self.layout.addWidget(self.service_model_btn, stretch=2)

        self.display_btn = make_btn("Display", self._btn_style(self.GREY))
        self.display_btn.installEventFilter(self)
        self.layout.addWidget(self.display_btn, stretch=1)

        chat_mgmt_widget = QWidget()
        chat_mgmt_layout = QGridLayout(chat_mgmt_widget)
        chat_mgmt_layout.setContentsMargins(0, 0, 0, 0)
        chat_mgmt_layout.setSpacing(2)

        self.new_chat_btn = make_btn("ðŸ†•", self._btn_style(self.GREEN, "4px"), tooltip="New Chat")
        self.new_chat_btn.clicked.connect(self.new_chat_signal.emit)
        chat_mgmt_layout.addWidget(self.new_chat_btn, 0, 0)

        self.delete_chat_btn = make_btn("ðŸ—‘ï¸", self._btn_style(self.RED, "4px"), tooltip="Delete Chat")
        self.delete_chat_btn.clicked.connect(self.delete_chat_signal.emit)
        chat_mgmt_layout.addWidget(self.delete_chat_btn, 0, 1)

        self.nav_left_btn = make_btn("â—€", "", tooltip="Previous Chat")
        self.nav_left_btn.clicked.connect(self.navigate_left_signal.emit)
        chat_mgmt_layout.addWidget(self.nav_left_btn, 1, 0)

        self.nav_right_btn = make_btn("â–¶", "", tooltip="Next Chat")
        self.nav_right_btn.clicked.connect(self.navigate_right_signal.emit)
        chat_mgmt_layout.addWidget(self.nav_right_btn, 1, 1)
        
        self.update_navigation_buttons(False, False)

        chat_mgmt_widget.setSizePolicy(QSizePolicy.Policy.Preferred, QSizePolicy.Policy.Preferred)
        chat_mgmt_widget.setMaximumHeight(40)
        for btn in [self.new_chat_btn, self.delete_chat_btn, self.nav_left_btn, self.nav_right_btn]:
            btn.setSizePolicy(QSizePolicy.Policy.Preferred, QSizePolicy.Policy.Preferred)
        
        self.layout.addWidget(chat_mgmt_widget, stretch=1)

        select_file_container = QWidget()
        select_file_container.setSizePolicy(QSizePolicy.Policy.Preferred, QSizePolicy.Policy.Preferred)
        select_file_container_layout = QHBoxLayout(select_file_container)
        select_file_container_layout.setContentsMargins(0, 0, 0, 0)
        select_file_container_layout.setSpacing(0)
        
        self.select_file_btn = make_btn("Attach", self._btn_style(self.ORANGE))
        self.select_file_btn.setAcceptDrops(True)
        self.select_file_btn.dragEnterEvent = self._upload_drag_enter
        self.select_file_btn.dropEvent = self._upload_drop
        self.select_file_btn.clicked.connect(self._on_select_file_clicked)
        select_file_container_layout.addWidget(self.select_file_btn)
        
        self.clear_files_btn = make_btn("Ã—", self._btn_style(self.RED, "2px 6px"), tooltip="Clear all files")
        self.clear_files_btn.setStyleSheet(self.clear_files_btn.styleSheet() + "QPushButton { min-width: 20px; max-width: 20px; min-height: 20px; max-height: 20px; font-size: 12pt; }")
        self.clear_files_btn.clicked.connect(self._on_clear_files_clicked)
        self.clear_files_btn.hide()
        self.clear_files_btn.setParent(select_file_container)
        self.clear_files_btn.raise_()
        
        self.select_file_btn.installEventFilter(self)
        self.layout.addWidget(select_file_container, stretch=2)

        self.send_btn = make_btn("Send", self._btn_style(self.GREEN))
        self.send_btn.clicked.connect(self._on_send_btn_clicked)
        self.send_btn.setEnabled(False)
        self.layout.addWidget(self.send_btn, stretch=2)

        # Set size policies
        for btn in [self.service_model_btn, self.display_btn, self.select_file_btn, self.send_btn]:
            btn.setSizePolicy(QSizePolicy.Policy.Preferred, QSizePolicy.Policy.Preferred)

        # Create unified dropdowns
        self._create_dropdowns()

    def _create_dropdowns(self):
        self._create_unified_dropdown()
        self._create_display_dropdown()

    def _create_unified_dropdown(self):
        """Create unified dropdown for service:model selection."""
        parent_window = self.window() or None
        dropdown = QWidget(parent_window)
        dropdown.setWindowFlags(Qt.WindowType.FramelessWindowHint | Qt.WindowType.Tool)
        dropdown.setAttribute(Qt.WidgetAttribute.WA_ShowWithoutActivating)
        dropdown.setStyleSheet("QWidget { background-color: #2a2a2a; border: 1px solid #555; border-radius: 4px; }")
        layout = QVBoxLayout(dropdown)
        layout.setContentsMargins(4, 4, 4, 4)
        layout.setSpacing(2)

        for service, model in self.SERVICE_MODEL_OPTIONS:
            option_btn = QPushButton(f"{service}:{model}")
            option_btn.setStyleSheet("""
                QPushButton { background-color: transparent; color: white; border: none; text-align: left; padding: 6px 12px; font-size: 9pt; }
                QPushButton:hover { background-color: #3d3d3d; }
            """)
            option_btn.clicked.connect(lambda checked, s=service, m=model: self._on_service_model_selected(s, m))
            layout.addWidget(option_btn)

        dropdown.adjustSize()
        dropdown.hide()
        dropdown.installEventFilter(self)
        self.unified_dropdown = dropdown

    def _create_display_dropdown(self):
        """Create dropdown for display field toggling."""
        parent_window = self.window() or None
        dropdown = QWidget(parent_window)
        dropdown.setWindowFlags(Qt.WindowType.FramelessWindowHint | Qt.WindowType.Tool)
        dropdown.setAttribute(Qt.WidgetAttribute.WA_ShowWithoutActivating)
        dropdown.setStyleSheet("QWidget { background-color: #2a2a2a; border: 1px solid #555; border-radius: 4px; }")
        layout = QVBoxLayout(dropdown)
        layout.setContentsMargins(4, 4, 4, 4)
        layout.setSpacing(2)

        self.display_checkboxes = {}
        fields = [
            "core", "composition", "lighting", "style", "technical", 
            "post_processing", "special_elements", "detailed_prompt",
            "grok_imagine_optimized", "gemini_optimized", "flux_optimized", 
            "stable_diffusion_optimized", "video_optimized", "ooc_note"
        ]
        
        self.display_fields = {}
        
        for field in fields:
            btn = QPushButton(f"â˜‘ {field}")
            btn.setStyleSheet("""
                QPushButton { background-color: transparent; color: white; border: none; text-align: left; padding: 4px 12px; font-size: 9pt; }
                QPushButton:hover { background-color: #3d3d3d; }
            """)
            btn.clicked.connect(lambda checked, f=field: self._on_display_toggle(f))
            layout.addWidget(btn)
            self.display_checkboxes[field] = btn

        dropdown.adjustSize()
        dropdown.hide()
        dropdown.installEventFilter(self)
        self.display_dropdown = dropdown

    def set_display_fields(self, fields: dict):
        self.display_fields = fields.copy()
        if hasattr(self, 'display_checkboxes'):
            for field, btn in self.display_checkboxes.items():
                is_checked = self.display_fields.get(field, True)
                btn.setText(f"{'â˜‘' if is_checked else 'â˜'} {field}")

    def _on_display_toggle(self, field: str):
        current = self.display_fields.get(field, True)
        self.display_fields[field] = not current
        self.set_display_fields(self.display_fields)
        self.display_toggled_signal.emit(self.display_fields)


    def eventFilter(self, obj, event):
        """Handle hover events for dropdown menus and clear button positioning."""
        et = event.type()

        # Handle select_file_btn resize to reposition clear button
        if hasattr(self, 'select_file_btn') and obj == self.select_file_btn and et == QEvent.Type.Resize:
            self._update_clear_button_position()

        # Enter events
        if et == QEvent.Type.Enter:
            if obj == self.service_model_btn:
                self._show_dropdown("unified")
            elif obj == self.display_btn:
                self._show_dropdown("display")
            elif obj in [self.unified_dropdown, self.display_dropdown]:
                self.hide_timer.stop()

        # Leave events
        elif et == QEvent.Type.Leave:
            if obj in [self.service_model_btn, self.unified_dropdown, self.display_btn, self.display_dropdown]:
                self.hide_timer.start()

        return super().eventFilter(obj, event)
    
    def _update_clear_button_position(self):
        """Update clear button position to top-right of select_file_btn."""
        if not self.clear_files_btn.isVisible():
            return
        btn_rect = self.select_file_btn.geometry()
        clear_btn_size = 20
        # Position at top-right with small offset
        x = btn_rect.right() - clear_btn_size - 4
        y = btn_rect.top() + 4
        self.clear_files_btn.setGeometry(x, y, clear_btn_size, clear_btn_size)

    def _show_dropdown(self, dropdown_type):
        if self._is_generating: return
        self.hide_timer.stop()
        
        target_dropdown = self.unified_dropdown if dropdown_type == "unified" else self.display_dropdown
        target_btn = self.service_model_btn if dropdown_type == "unified" else self.display_btn
        
        if self.active_dropdown and self.active_dropdown != target_dropdown:
            self.active_dropdown.hide()
        if self.active_dropdown == target_dropdown: return

        self.active_dropdown = target_dropdown
        btn_global_pos = target_btn.mapToGlobal(target_btn.rect().topLeft())
        target_dropdown.move(btn_global_pos.x(), btn_global_pos.y() - target_dropdown.height() - 2)
        target_dropdown.show()
        target_dropdown.raise_()

    def _hide_dropdown(self):
        if self.active_dropdown:
            self.active_dropdown.hide()
            self.active_dropdown = None
            self.active_button = None

    def _on_service_model_selected(self, service: str, model: str):
        """Handle unified service:model selection."""
        self.current_service = service
        self.current_model = model
        self.service_model_btn.setText(f"{service}:{model}")
        self._update_file_controls_state()
        
        self.service_model_selected_signal.emit(service, model)
        self._hide_dropdown()

    def _update_file_controls_state(self):
        """Update state of file controls based on current service and file selection."""
        # Disable file selection for NVIDIA NIM models that don't support vision
        no_file_support = (self.current_service == "NVIDIA NIM"
                           and self.current_model not in self.NIM_VISION_MODELS)
        has_files = self.file_service.has_files()
        
        self.select_file_btn.setEnabled(not no_file_support and not self._is_generating)
        
        if self._is_generating:
            # During generation, this is the Cancel button, so keep it enabled
            self.send_btn.setEnabled(True)
        elif has_files:
            # Disable Send button if files attached and model doesn't support them
            self.send_btn.setEnabled(not no_file_support)
        
        # Show/hide clear button based on file state
        self.clear_files_btn.setVisible(has_files)
        self.clear_files_btn.setEnabled(not self._is_generating)
        if has_files:
            self._update_clear_button_position()

    def _on_send_btn_clicked(self):
        if self._is_generating:
            self.interrupt_signal.emit()
        else:
            self.send_signal.emit()

    def set_generating_state(self, state: bool):
        """Enable or disable actions based on whether AI is currently generating."""
        self._is_generating = state
        self.new_chat_btn.setEnabled(not state)
        self.delete_chat_btn.setEnabled(not state)
        self.service_model_btn.setEnabled(not state)
        self.display_btn.setEnabled(not state)
        
        if state:
            self._hide_dropdown()
            self.update_navigation_buttons(False, False)
            self.send_btn.setText("Cancel")
            self.send_btn.setStyleSheet(self._btn_style(self.RED))
            grey_style = self._btn_style(self.GREY, "4px")
            self.new_chat_btn.setStyleSheet(grey_style)
            self.delete_chat_btn.setStyleSheet(grey_style)
        else:
            self.send_btn.setText("Send")
            self.send_btn.setStyleSheet(self._btn_style(self.GREEN))
            self.new_chat_btn.setStyleSheet(self._btn_style(self.GREEN, "4px"))
            self.delete_chat_btn.setStyleSheet(self._btn_style(self.RED, "4px"))
            
        self._update_file_controls_state()

    def update_text_action_buttons(self, has_content: bool):
        """
        Update Send button enabled state based on input text content.

        Args:
            has_content: True if input field has non-whitespace text, False otherwise
        """
        if self._is_generating:
            self.send_btn.setEnabled(True)
            return

        # Only update if no files attached - files take precedence
        if not self.file_service.has_files():
            self.send_btn.setEnabled(has_content)

    def _on_select_file_clicked(self):
        paths, _ = QFileDialog.getOpenFileNames(self, "Select file(s)", "", "All Files (*)")
        for path in paths: self.file_service.load_file_from_path(path)
        if files := self.file_service.get_files():
            self.select_file_signal.emit(files[0][0] or "", "")
    
    def _on_clear_files_clicked(self):
        """Handle clear files button click."""
        self.file_service.clear_files()
        self.select_file_signal.emit("", "")

    def _upload_drag_enter(self, event):
        """Handle drag enter event for select file button."""
        md = event.mimeData()
        if md.hasUrls():
            for url in md.urls():
                if url.isLocalFile():
                    event.acceptProposedAction()
                    return
        if md.hasImage():
            event.acceptProposedAction()
            return
        event.ignore()

    def _upload_drop(self, event):
        """Handle drop event for upload button - supports multiple files."""
        try:
            md = event.mimeData()
            if md.hasUrls():
                files_loaded = False
                for url in md.urls():
                    if url.isLocalFile():
                        path = url.toLocalFile()
                        if self.file_service.load_file_from_path(path):
                            files_loaded = True
                if files_loaded:
                    # Emit signal with first file's data for backward compatibility
                    files = self.file_service.get_files()
                    if files:
                        b64, _ = files[0]
                        self.select_file_signal.emit(b64 or "", "")
                    event.acceptProposedAction()
                    return
            elif md.hasImage():
                img = md.imageData()
                if img:
                    buf = QBuffer()
                    buf.open(QIODevice.OpenModeFlag.WriteOnly)
                    img.save(buf, "PNG")
                    if self.file_service.load_file_from_data(bytes(buf.data()), "clipboard"):
                        if files := self.file_service.get_files():
                            self.select_file_signal.emit(files[0][0] or "", "")
                        event.acceptProposedAction()
                        return
        except Exception:
            pass
        event.ignore()

    def set_service_model_text(self, service: str, model: str):
        """Set the text of the unified service:model button."""
        self.current_service = service
        self.current_model = model
        self.service_model_btn.setText(f"{service}:{model}")
        self._update_file_controls_state()

    def update_navigation_buttons(self, can_go_left: bool, can_go_right: bool):
        for btn, enabled in [(self.nav_left_btn, can_go_left), (self.nav_right_btn, can_go_right)]:
            btn.setEnabled(enabled)
            btn.setStyleSheet(self._btn_style(self.BLUE if enabled else self.GREY, "4px"))
```

### `gui/widgets/airforce_page.py`

```python
# gui/widgets/airforce_page.py
"""
Airforce Page - Image generation interface for the Airforce API.
Provides controls for prompt, model, size, seed and displays generated images.
"""

from PyQt6.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, QPushButton, QLineEdit
)
from PyQt6.QtCore import pyqtSignal, Qt, QTimer, QEvent
from PyQt6.QtGui import QCursor

import os

from gui.widgets.image_gen_common import (
    ImageDisplay, INPUT_STYLE, BTN_GENERATE, BTN_CANCEL,
    BTN_DROPDOWN, make_dropdown,
)
from core.services.airforce_service import AirforceService
from core.utils import reveal_file_in_explorer


class AirforcePage(QWidget):
    """Airforce AI image generation page with controls and image display."""

    status_updated = pyqtSignal(str)

    MODELS = ["grok-imagine", "imagen-4"]
    SIZES = ["1024x1024", "1344x768", "768x1344"]
    DEFAULT_MODEL = "grok-imagine"
    DEFAULT_SIZE = "1024x1024"
    DEFAULT_SEED = -1

    def __init__(self, config_manager=None, parent=None):
        super().__init__(parent)
        self.config_manager = config_manager
        self.current_model = self.DEFAULT_MODEL
        self.current_size = self.DEFAULT_SIZE
        self._is_generating = False
        self._current_image_path = ""

        self.active_dropdown = None
        self.hide_timer = QTimer()
        self.hide_timer.setInterval(250)
        self.hide_timer.timeout.connect(self._hide_dropdown)

        self.service = AirforceService()
        self.service.image_generated.connect(self._on_image_generated)
        self.service.error_occurred.connect(self._on_error)
        self.service.status_updated.connect(self.status_updated.emit)

        self._build_ui()
        self._load_from_config()

    # ------------------------------------------------------------------ UI

    def _build_ui(self):
        layout = QVBoxLayout(self)
        layout.setContentsMargins(0, 0, 0, 0)
        layout.setSpacing(0)

        # --- Controls bar ---
        controls = QWidget()
        controls.setStyleSheet("background-color: #121212;")
        cl = QHBoxLayout(controls)
        cl.setContentsMargins(4, 4, 4, 4)
        cl.setSpacing(6)

        self.generate_btn = QPushButton("Generate")
        self.generate_btn.setStyleSheet(BTN_GENERATE)
        self.generate_btn.setCursor(QCursor(Qt.CursorShape.PointingHandCursor))
        self.generate_btn.setFocusPolicy(Qt.FocusPolicy.NoFocus)
        self.generate_btn.clicked.connect(self._on_generate_clicked)
        cl.addWidget(self.generate_btn)

        self.positive_input = QLineEdit()
        self.positive_input.setPlaceholderText("Positive Prompt...")
        self.positive_input.setStyleSheet(INPUT_STYLE)
        self.positive_input.returnPressed.connect(self._on_generate_clicked)
        cl.addWidget(self.positive_input, stretch=2)

        self.negative_input = QLineEdit()
        self.negative_input.setPlaceholderText("Negative Prompt...")
        self.negative_input.setStyleSheet(INPUT_STYLE)
        self.negative_input.returnPressed.connect(self._on_generate_clicked)
        cl.addWidget(self.negative_input, stretch=1)

        self.model_btn = QPushButton(self.current_model)
        self.model_btn.setStyleSheet(BTN_DROPDOWN)
        self.model_btn.setCursor(QCursor(Qt.CursorShape.PointingHandCursor))
        self.model_btn.setFocusPolicy(Qt.FocusPolicy.NoFocus)
        self.model_btn.setMinimumWidth(100)
        self.model_btn.installEventFilter(self)
        cl.addWidget(self.model_btn)

        self.size_btn = QPushButton(self.current_size)
        self.size_btn.setStyleSheet(BTN_DROPDOWN)
        self.size_btn.setCursor(QCursor(Qt.CursorShape.PointingHandCursor))
        self.size_btn.setFocusPolicy(Qt.FocusPolicy.NoFocus)
        self.size_btn.setMinimumWidth(90)
        self.size_btn.installEventFilter(self)
        cl.addWidget(self.size_btn)

        self.seed_input = QLineEdit(str(self.DEFAULT_SEED))
        self.seed_input.setStyleSheet(INPUT_STYLE)
        self.seed_input.setFixedWidth(64)
        self.seed_input.setAlignment(Qt.AlignmentFlag.AlignCenter)
        self.seed_input.setToolTip("Seed (-1 for random)")
        self.seed_input.returnPressed.connect(self._on_generate_clicked)
        cl.addWidget(self.seed_input)

        layout.addWidget(controls)

        # --- Image display ---
        self.image_display = ImageDisplay()
        self.image_display.clicked.connect(self._on_image_clicked)
        layout.addWidget(self.image_display, 1)

        # --- Dropdowns ---
        self.model_dropdown = make_dropdown(
            self, self.MODELS, self._on_model_selected, self
        )
        self.size_dropdown = make_dropdown(
            self, self.SIZES, self._on_size_selected, self
        )

    # -------------------------------------------------------------- Dropdowns

    def eventFilter(self, obj, event):
        et = event.type()
        if et == QEvent.Type.Enter:
            if obj == self.model_btn:
                self._show_dropdown(self.model_dropdown, self.model_btn)
            elif obj == self.size_btn:
                self._show_dropdown(self.size_dropdown, self.size_btn)
            elif obj in (self.model_dropdown, self.size_dropdown):
                self.hide_timer.stop()
        elif et == QEvent.Type.Leave:
            if obj in (self.model_btn, self.size_btn,
                       self.model_dropdown, self.size_dropdown):
                self.hide_timer.start()
        return super().eventFilter(obj, event)

    def _show_dropdown(self, dropdown, button):
        if self._is_generating:
            return
        self.hide_timer.stop()
        if self.active_dropdown and self.active_dropdown is not dropdown:
            self.active_dropdown.hide()
        if self.active_dropdown is dropdown:
            return
        self.active_dropdown = dropdown
        pos = button.mapToGlobal(button.rect().bottomLeft())
        dropdown.move(pos.x(), pos.y() + 2)
        dropdown.show()
        dropdown.raise_()

    def _hide_dropdown(self):
        if self.active_dropdown:
            self.active_dropdown.hide()
            self.active_dropdown = None

    def _on_model_selected(self, model: str):
        self.current_model = model
        self.model_btn.setText(model)
        self._hide_dropdown()
        self._save_to_config()

    def _on_size_selected(self, size: str):
        self.current_size = size
        self.size_btn.setText(size)
        self._hide_dropdown()
        self._save_to_config()

    # ------------------------------------------------------------ Generation

    def _on_generate_clicked(self):
        if self._is_generating:
            self.service.cancel_generation()
            self._set_generating(False)
            self.status_updated.emit("Generation cancelled.")
            return

        prompt = self.positive_input.text().strip()
        if not prompt:
            self.status_updated.emit("Error: Positive prompt cannot be empty.")
            return

        try:
            seed = int(self.seed_input.text().strip())
        except ValueError:
            seed = -1

        self._set_generating(True)
        self._save_to_config()
        self.service.generate_image(
            prompt=prompt,
            negative_prompt=self.negative_input.text().strip(),
            model=self.current_model,
            size=self.current_size,
            seed=seed,
        )

    def _on_image_generated(self, filepath: str):
        self._set_generating(False)
        self._current_image_path = filepath
        self.image_display.set_image(filepath)
        self._save_to_config()

    def _on_error(self, _error_msg: str):
        self._set_generating(False)

    def _set_generating(self, state: bool):
        self._is_generating = state
        self.positive_input.setEnabled(not state)
        self.negative_input.setEnabled(not state)
        self.model_btn.setEnabled(not state)
        self.size_btn.setEnabled(not state)
        self.seed_input.setEnabled(not state)

        if state:
            self._hide_dropdown()
            self.generate_btn.setText("Cancel")
            self.generate_btn.setStyleSheet(BTN_CANCEL)
        else:
            self.generate_btn.setText("Generate")
            self.generate_btn.setStyleSheet(BTN_GENERATE)

    def hideEvent(self, event):
        """Close dropdowns when page is hidden (tab switch)."""
        self._hide_dropdown()
        super().hideEvent(event)

    def _on_image_clicked(self):
        """Open file explorer and select the current image."""
        if self._current_image_path and os.path.isfile(self._current_image_path):
            reveal_file_in_explorer(self._current_image_path)
        else:
            self.status_updated.emit("Image file not found on disk.")

    # ------------------------------------------------------------- Config

    def _save_to_config(self):
        """Persist current Airforce settings to config."""
        if not self.config_manager:
            return
        self.config_manager.airforce_positive_prompt = self.positive_input.text()
        self.config_manager.airforce_negative_prompt = self.negative_input.text()
        self.config_manager.airforce_model = self.current_model
        self.config_manager.airforce_size = self.current_size
        try:
            self.config_manager.airforce_seed = int(self.seed_input.text())
        except ValueError:
            self.config_manager.airforce_seed = self.DEFAULT_SEED
        self.config_manager.airforce_last_image = self._current_image_path
        self.config_manager.save()

    def _load_from_config(self):
        """Load persisted Airforce settings from config."""
        if not self.config_manager:
            return

        self.positive_input.setText(
            getattr(self.config_manager, 'airforce_positive_prompt', ''))
        self.negative_input.setText(
            getattr(self.config_manager, 'airforce_negative_prompt', ''))

        model = getattr(self.config_manager, 'airforce_model', self.DEFAULT_MODEL)
        if model in self.MODELS:
            self.current_model = model
            self.model_btn.setText(model)

        size = getattr(self.config_manager, 'airforce_size', self.DEFAULT_SIZE)
        if size in self.SIZES:
            self.current_size = size
            self.size_btn.setText(size)

        seed = getattr(self.config_manager, 'airforce_seed', self.DEFAULT_SEED)
        self.seed_input.setText(str(seed))

        last_image = getattr(self.config_manager, 'airforce_last_image', '')
        if last_image and os.path.isfile(last_image):
            self._current_image_path = last_image
            self.image_display.set_image(last_image)
```

### `gui/widgets/gallery_page.py`

```python
# gui/widgets/gallery_page.py
"""
Gallery Page - Displays generated images in a responsive 4x3 grid.
Includes pagination, filtering, and prompt copying functionalities.
"""

from datetime import datetime

from PyQt6.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, QPushButton, QLabel, QGridLayout, QSizePolicy
)
from PyQt6.QtCore import pyqtSignal, Qt, QTimer, QEvent
from PyQt6.QtGui import QCursor

from gui.widgets.image_gen_common import ImageDisplay, BTN_DROPDOWN, make_dropdown
from core.utils import reveal_file_in_explorer
from core.services.gallery_service import GalleryService


class ElidedLabel(QLabel):
    """A QLabel that elides its text on the right if it exceeds widget width."""
    clicked = pyqtSignal()
    
    def __init__(self, text="", parent=None):
        super().__init__(text, parent)
        self._full_text = text
        self.setSizePolicy(QSizePolicy.Policy.Ignored, QSizePolicy.Policy.Fixed)
        
    def setText(self, text):
        self._full_text = text
        super().setText(text)
        self.update_elision()
        
    def resizeEvent(self, event):
        super().resizeEvent(event)
        self.update_elision()
        
    def update_elision(self):
        fm = self.fontMetrics()
        w = max(0, self.width() - 2)
        elided = fm.elidedText(self._full_text, Qt.TextElideMode.ElideRight, w)
        super().setText(elided)

    def mousePressEvent(self, event):
        if event.button() == Qt.MouseButton.LeftButton:
            self.clicked.emit()
        super().mousePressEvent(event)


class GalleryItemWidget(QWidget):
    """Individual container for an image, prompt, and metadata in the Gallery grid."""
    prompt_copied = pyqtSignal(str)
    
    def __init__(self, parent=None):
        super().__init__(parent)
        self.filepath = ""
        self.prompt = ""
        
        self.setStyleSheet("""
            GalleryItemWidget {
                background-color: #1e1e1e;
                border: 1px solid #333;
                border-radius: 4px;
            }
        """)
        
        # Force uniform sizing and prevent layout collapse when hidden
        policy = QSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Expanding)
        policy.setRetainSizeWhenHidden(True)
        self.setSizePolicy(policy)
        
        layout = QVBoxLayout(self)
        layout.setContentsMargins(4, 4, 4, 4)
        layout.setSpacing(4)
        
        self.image_display = ImageDisplay()
        self.image_display.setMinimumSize(32, 32)
        
        self.prompt_label = ElidedLabel()
        self.prompt_label.setCursor(QCursor(Qt.CursorShape.PointingHandCursor))
        self.prompt_label.setStyleSheet("color: #ccc; font-size: 11px; border: none; background: transparent;")
        self.prompt_label.setToolTip("Click to copy prompt")
        
        self.meta_label = ElidedLabel()
        self.meta_label.setStyleSheet("color: #888; font-size: 10px; border: none; background: transparent;")
        
        layout.addWidget(self.image_display, stretch=1)
        layout.addWidget(self.prompt_label)
        layout.addWidget(self.meta_label)
        
        self.image_display.clicked.connect(self._on_image_clicked)
        self.prompt_label.clicked.connect(self._on_prompt_clicked)
        
    def set_data(self, meta):
        self.filepath = meta.filepath
        self.prompt = meta.prompt
        self.image_display.set_image(meta.filepath)
        
        display_prompt = self.prompt.replace('\n', ' ').strip()
        if not display_prompt:
            display_prompt = "No prompt"
            
        self.prompt_label.setText(display_prompt)
        
        try:
            dt = datetime.strptime(meta.timestamp, "%Y-%m-%d_%H-%M-%S")
            ts_str = dt.strftime("%Y-%m-%d %H:%M:%S")
        except ValueError:
            ts_str = meta.timestamp
            
        self.meta_label.setText(f"{meta.service} | {meta.model} | {ts_str}")
        self.show()
        
    def clear(self):
        self.filepath = ""
        self.prompt = ""
        self.image_display.clear_image()
        self.prompt_label.setText("")
        self.meta_label.setText("")
        self.hide()
        
    def _on_image_clicked(self):
        if self.filepath:
            reveal_file_in_explorer(self.filepath)
            
    def _on_prompt_clicked(self):
        if self.prompt:
            from PyQt6.QtWidgets import QApplication
            QApplication.clipboard().setText(self.prompt)
            self.prompt_copied.emit("Prompt copied to clipboard.")


class GalleryPage(QWidget):
    """Media Gallery page displaying generated images in a paginated grid."""
    status_updated = pyqtSignal(str)
    
    FILTERS = ["All", "Pollinations", "Airforce", "Perchance"]
    ITEMS_PER_PAGE = 12

    def __init__(self, config_manager=None, parent=None):
        super().__init__(parent)
        self.config_manager = config_manager
        self.service = GalleryService()
        
        self.images = []
        self.current_page = 1
        self.total_pages = 1
        self.current_filter = "All"
        self._items = []
        
        self.active_dropdown = None
        self.hide_timer = QTimer()
        self.hide_timer.setInterval(250)
        self.hide_timer.timeout.connect(self._hide_dropdown)
        
        self._build_ui()
        self._load_from_config()
        self.refresh()

    def _build_ui(self):
        layout = QVBoxLayout(self)
        layout.setContentsMargins(0, 0, 0, 0)
        layout.setSpacing(0)
        
        # --- Controls Bar ---
        controls = QWidget()
        controls.setStyleSheet("background-color: #121212;")
        cl = QHBoxLayout(controls)
        cl.setContentsMargins(4, 4, 4, 4)
        cl.setSpacing(6)
        
        cl.addStretch(1)
        
        # Internal Page Pagination
        paginator_layout = QHBoxLayout()
        paginator_layout.setSpacing(2)
        
        self.first_btn = QPushButton("Â«")
        self.prev_btn = QPushButton("â€¹")
        self.next_btn = QPushButton("â€º")
        self.last_btn = QPushButton("Â»")
        
        for btn in [self.first_btn, self.prev_btn, self.next_btn, self.last_btn]:
            btn.setFixedSize(28, 28)
            btn.setStyleSheet(BTN_DROPDOWN)
            btn.setCursor(QCursor(Qt.CursorShape.PointingHandCursor))
            paginator_layout.addWidget(btn)
            
        self.first_btn.clicked.connect(lambda: self.set_page(1))
        self.prev_btn.clicked.connect(lambda: self.set_page(self.current_page - 1))
        self.next_btn.clicked.connect(lambda: self.set_page(self.current_page + 1))
        self.last_btn.clicked.connect(self._goto_last_page)
        
        self.page_label = QLabel("Page 1 of 1 (0 items)")
        self.page_label.setStyleSheet("color: #ccc; font-size: 11px; padding: 0 8px;")
        self.page_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
        
        paginator_layout.insertWidget(2, self.page_label)
        cl.addLayout(paginator_layout)
        
        cl.addStretch(1)
        
        # Display Filtering Toggles
        self.filter_btn = QPushButton(self.current_filter)
        self.filter_btn.setStyleSheet(BTN_DROPDOWN)
        self.filter_btn.setCursor(QCursor(Qt.CursorShape.PointingHandCursor))
        self.filter_btn.setMinimumWidth(100)
        
        self.filter_dropdown = make_dropdown(self, self.FILTERS, self._on_filter_selected, self)
        self.filter_btn.installEventFilter(self)
        
        cl.addWidget(self.filter_btn)
        layout.addWidget(controls)
        
        # --- Grid Area ---
        self.grid_container = QWidget()
        self.grid_container.setStyleSheet("background-color: #2a2a2a;")
        self.grid_layout = QGridLayout(self.grid_container)
        self.grid_layout.setContentsMargins(8, 8, 8, 8)
        self.grid_layout.setSpacing(8)
        
        for row in range(3):
            self.grid_layout.setRowStretch(row, 1)
            for col in range(4):
                if row == 0:
                    self.grid_layout.setColumnStretch(col, 1)
                item = GalleryItemWidget()
                item.prompt_copied.connect(self.status_updated.emit)
                self.grid_layout.addWidget(item, row, col)
                self._items.append(item)
                
        layout.addWidget(self.grid_container, stretch=1)

    def eventFilter(self, obj, event):
        et = event.type()
        if et == QEvent.Type.Enter:
            if obj == self.filter_btn:
                self._show_dropdown(self.filter_dropdown, self.filter_btn)
            elif obj == self.filter_dropdown:
                self.hide_timer.stop()
        elif et == QEvent.Type.Leave:
            if obj in (self.filter_btn, self.filter_dropdown):
                self.hide_timer.start()
        return super().eventFilter(obj, event)

    def _show_dropdown(self, dropdown, button):
        self.hide_timer.stop()
        if self.active_dropdown and self.active_dropdown is not dropdown:
            self.active_dropdown.hide()
        if self.active_dropdown is dropdown:
            return
        self.active_dropdown = dropdown
        pos = button.mapToGlobal(button.rect().bottomLeft())
        dropdown.move(pos.x(), pos.y() + 2)
        dropdown.show()
        dropdown.raise_()

    def _hide_dropdown(self):
        if self.active_dropdown:
            self.active_dropdown.hide()
            self.active_dropdown = None

    def _on_filter_selected(self, filter_name: str):
        self.current_filter = filter_name
        self.filter_btn.setText(filter_name)
        self._hide_dropdown()
        self.current_page = 1
        self._save_to_config()
        self.refresh()
        
    def _save_to_config(self):
        if not self.config_manager:
            return
        self.config_manager.gallery_page = self.current_page
        self.config_manager.gallery_filter = self.current_filter
        self.config_manager.save()
        
    def _load_from_config(self):
        if not self.config_manager:
            return
        self.current_page = getattr(self.config_manager, "gallery_page", 1)
        self.current_filter = getattr(self.config_manager, "gallery_filter", "All")
        if self.current_filter in self.FILTERS:
            self.filter_btn.setText(self.current_filter)

    def refresh(self):
        self.images = self.service.get_images(self.current_filter)
        self.total_pages = max(1, (len(self.images) + self.ITEMS_PER_PAGE - 1) // self.ITEMS_PER_PAGE)
        if self.current_page > self.total_pages:
            self.current_page = self.total_pages
        self._update_display()
        
    def _goto_last_page(self):
        self.set_page(self.total_pages)

    def set_page(self, page: int):
        if 1 <= page <= self.total_pages and page != self.current_page:
            self.current_page = page
            self._save_to_config()
            self._update_display()

    def _update_display(self):
        start_idx = (self.current_page - 1) * self.ITEMS_PER_PAGE
        end_idx = start_idx + self.ITEMS_PER_PAGE
        page_images = self.images[start_idx:end_idx]
        
        self.page_label.setText(f"Page {self.current_page} of {self.total_pages} ({len(self.images)} items)")
        
        self.first_btn.setEnabled(self.current_page > 1)
        self.prev_btn.setEnabled(self.current_page > 1)
        self.next_btn.setEnabled(self.current_page < self.total_pages)
        self.last_btn.setEnabled(self.current_page < self.total_pages)
        
        for i, item_widget in enumerate(self._items):
            if i < len(page_images):
                item_widget.set_data(page_images[i])
            else:
                item_widget.clear()

    def hideEvent(self, event):
        self._hide_dropdown()
        super().hideEvent(event)
```

### `gui/widgets/image_gen_common.py`

```python
# gui/widgets/image_gen_common.py
"""
Shared components for image generation pages.
Provides ImageDisplay widget, UI style constants, and dropdown factory.
"""

from PyQt6.QtWidgets import QLabel, QSizePolicy, QWidget, QVBoxLayout, QPushButton
from PyQt6.QtCore import pyqtSignal, Qt
from PyQt6.QtGui import QCursor, QPixmap


# â”€â”€ Shared style constants â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

INPUT_STYLE = (
    "QLineEdit {"
    "  background-color: #1e1e1e; color: #eee;"
    "  border: 1px solid #333; border-radius: 3px;"
    "  font-size: 12px; padding: 6px;"
    "}"
    "QLineEdit:disabled { color: #666; }"
)

BTN_GENERATE = (
    "QPushButton {"
    "  background-color: #1E88E5; color: #fff; font-weight: bold;"
    "  border: 1px solid #1E88E5; border-radius: 3px;"
    "  font-size: 12px; padding: 6px 12px;"
    "}"
    "QPushButton:hover { background-color: #2A9BF8; border-color: #2A9BF8; }"
    "QPushButton:pressed { background-color: #1966C2; border-color: #1966C2; }"
)

BTN_CANCEL = (
    "QPushButton {"
    "  background-color: #F44336; color: #fff; font-weight: bold;"
    "  border: 1px solid #F44336; border-radius: 3px;"
    "  font-size: 12px; padding: 6px 12px;"
    "}"
    "QPushButton:hover { background-color: #EF5350; border-color: #EF5350; }"
    "QPushButton:pressed { background-color: #D32F2F; border-color: #D32F2F; }"
)

BTN_DROPDOWN = (
    "QPushButton {"
    "  background-color: #1e1e1e; color: #eee;"
    "  border: 1px solid #333; border-radius: 3px;"
    "  font-size: 12px; padding: 6px 8px;"
    "}"
    "QPushButton:hover { background-color: #2a2a2a; border-color: #555; }"
    "QPushButton:disabled { color: #666; }"
)

DROPDOWN_OPTION = (
    "QPushButton {"
    "  background-color: transparent; color: #eee; border: none;"
    "  text-align: left; padding: 6px 12px; font-size: 12px;"
    "}"
    "QPushButton:hover { background-color: #2a2a2a; }"
)

DROPDOWN_CONTAINER = (
    "QWidget { background-color: #1e1e1e; border: 1px solid #333; border-radius: 3px; }"
)


# â”€â”€ Shared widgets â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

class ImageDisplay(QLabel):
    """Custom label that displays an image fully contained, never cropped."""

    clicked = pyqtSignal()

    def __init__(self, parent=None):
        super().__init__(parent)
        self._pixmap = None
        self.setAlignment(Qt.AlignmentFlag.AlignCenter)
        self.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Expanding)
        self.setMinimumSize(64, 64)
        self.setStyleSheet("background-color: #121212; border: none;")

    def set_image(self, filepath: str):
        """Load and display an image from file path."""
        self._pixmap = QPixmap(filepath)
        self._update_display()
        self.setCursor(QCursor(Qt.CursorShape.PointingHandCursor))

    def clear_image(self):
        self._pixmap = None
        self.clear()
        self.setCursor(QCursor(Qt.CursorShape.ArrowCursor))

    def mousePressEvent(self, event):
        if event.button() == Qt.MouseButton.LeftButton and self._pixmap:
            self.clicked.emit()
        super().mousePressEvent(event)

    def _update_display(self):
        if self._pixmap and not self._pixmap.isNull():
            scaled = self._pixmap.scaled(
                self.size(),
                Qt.AspectRatioMode.KeepAspectRatio,
                Qt.TransformationMode.SmoothTransformation,
            )
            self.setPixmap(scaled)

    def resizeEvent(self, event):
        super().resizeEvent(event)
        self._update_display()


# â”€â”€ Shared helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

def make_dropdown(parent_widget, options: list, callback, event_filter_obj) -> QWidget:
    """Create a hover-activated dropdown widget with the given options.

    Args:
        parent_widget:    Widget whose window() is used as the dropdown parent.
        options:          List of string labels for the dropdown items.
        callback:         Called with the selected option string on click.
        event_filter_obj: QObject that will receive Enter/Leave events on the dropdown.
    """
    dd = QWidget(parent_widget.window() or None)
    dd.setWindowFlags(Qt.WindowType.FramelessWindowHint | Qt.WindowType.Tool)
    dd.setAttribute(Qt.WidgetAttribute.WA_ShowWithoutActivating)
    dd.setStyleSheet(DROPDOWN_CONTAINER)
    lo = QVBoxLayout(dd)
    lo.setContentsMargins(2, 2, 2, 2)
    lo.setSpacing(1)

    for opt in options:
        btn = QPushButton(opt)
        btn.setStyleSheet(DROPDOWN_OPTION)
        btn.setCursor(QCursor(Qt.CursorShape.PointingHandCursor))
        btn.clicked.connect(lambda _, o=opt: callback(o))
        lo.addWidget(btn)

    dd.adjustSize()
    dd.hide()
    dd.installEventFilter(event_filter_obj)
    return dd
```

### `gui/widgets/input_panel.py`

```python
# gui/widgets/input_panel.py
"""
Input Panel - Contains input label and text edit.
"""

from PyQt6.QtWidgets import QWidget, QVBoxLayout, QTextEdit, QSizePolicy, QMainWindow
from PyQt6.QtCore import QEvent, QTimer, Qt, QSize, pyqtSignal


class InputPanel(QWidget):
    """A panel containing the input label and text edit with dynamic height scaling."""

    # Signals
    send_signal = pyqtSignal()
    navigate_left_signal = pyqtSignal()
    navigate_right_signal = pyqtSignal()
    text_content_changed_signal = pyqtSignal(bool)  # True if input has non-whitespace content

    # Constants
    MIN_INPUT_HEIGHT = 40
    WINDOW_DECORATION_BUFFER = 50
    SCREEN_BUFFER = 100
    FALLBACK_SCREEN_HEIGHT = 2000
    RESIZE_DEBOUNCE_MS = 50
    SCROLLBAR_UPDATE_DELAY_MS = 10
    HEIGHT_CHANGE_THRESHOLD = 1  # pixels

    def __init__(self, parent=None):
        super().__init__(parent)
        self.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Preferred)
        self.panel_layout = QVBoxLayout(self)
        self.panel_layout.setContentsMargins(0, 0, 0, 0)
        self.panel_layout.setSpacing(10)

        self.input_text = QTextEdit()
        self.input_text.setAcceptRichText(False)
        self.input_text.setStyleSheet("background-color: #2a2a2a; color: #ffffff; border: 1px solid #333;")
        self.input_text.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Ignored)
        self.input_text.setMinimumHeight(self.MIN_INPUT_HEIGHT)
        self.panel_layout.addWidget(self.input_text, stretch=1)

        # Guard flag to prevent recursive updates
        self._updating_height = False
        
        # Timer for debouncing resize events only (not text changes)
        self._resize_timer = QTimer()
        self._resize_timer.setSingleShot(True)
        self._resize_timer.timeout.connect(self._update_height)
        
        # Update height immediately on text change to prevent scrollbar flash
        self.input_text.textChanged.connect(self._on_text_changed)
        self.input_text.installEventFilter(self)

    def _get_main_window(self):
        """Traverse up the widget hierarchy to find the main window."""
        widget = self
        while widget:
            if isinstance(widget, QMainWindow):
                return widget
            widget = widget.parentWidget()
        return None

    def showEvent(self, event):
        """Install event filter on main window when shown."""
        super().showEvent(event)
        main_window = self._get_main_window()
        if main_window:
            main_window.installEventFilter(self)
        # Ensure correct initial height is set
        self._update_height()

    def _on_text_changed(self):
        """Handle text changes - update height immediately to prevent scrollbar flash."""
        # Update height immediately (will set scrollbar policy correctly)
        self._update_height()

        # Emit signal for text content state (has non-whitespace content)
        current_text = self.get_input_text()
        has_content = len(current_text.strip()) > 0
        self.text_content_changed_signal.emit(has_content)

    def eventFilter(self, obj, event):
        """Handle resize events on main window and key events on input text."""
        if isinstance(obj, QMainWindow) and event.type() == QEvent.Type.Resize:
            # Use a timer to debounce rapid resize events
            if not self._resize_timer.isActive():
                self._resize_timer.start(self.RESIZE_DEBOUNCE_MS)
        elif obj == self.input_text and event.type() == QEvent.Type.KeyPress:
            # Handle Ctrl+Enter shortcut
            if event.key() == Qt.Key.Key_Return and event.modifiers() == Qt.KeyboardModifier.ControlModifier:
                self.send_signal.emit()
                return True  # Accept the event
            # Handle Ctrl+Left and Ctrl+Right for navigation
            elif event.modifiers() == Qt.KeyboardModifier.ControlModifier:
                if event.key() == Qt.Key.Key_Left:
                    self.navigate_left_signal.emit()
                    return True  # Accept the event
                elif event.key() == Qt.Key.Key_Right:
                    self.navigate_right_signal.emit()
                    return True  # Accept the event
        return super().eventFilter(obj, event)
    
    def minimumSizeHint(self):
        m = self.panel_layout.contentsMargins()
        return QSize(super().minimumSizeHint().width(), self.MIN_INPUT_HEIGHT + self.panel_layout.spacing() + m.top() + m.bottom())
    
    def _calculate_max_height_limit(self, main_window, parent_layout):
        """Calculate the maximum allowed height for the input text area."""
        window_height = main_window.height()
        
        # Get screen available geometry as absolute maximum constraint
        screen = main_window.screen()
        max_screen_height = (
            screen.availableGeometry().height() if screen 
            else self.FALLBACK_SCREEN_HEIGHT
        )
        
        # Get sibling constraints
        response_widget = parent_layout.itemAt(0).widget()
        buttons_widget = parent_layout.itemAt(2).widget()
        
        if not response_widget or not buttons_widget:
            return None
        
        resp_min_h = response_widget.minimumHeight()
        btns_h = buttons_widget.sizeHint().height()
        
        # Calculate layout overhead
        margins = parent_layout.contentsMargins()
        spacing = parent_layout.spacing()
        overhead = margins.top() + margins.bottom() + (spacing * 2)
        
        # Account for panel spacing in InputPanel
        panel_spacing = self.panel_layout.spacing()
        panel_overhead = panel_spacing
        
        # Account for window decorations
        central = main_window.centralWidget()
        if central and central.layout():
            central_margins = central.layout().contentsMargins()
            overhead += central_margins.top() + central_margins.bottom()
        
        limit = min(window_height - self.WINDOW_DECORATION_BUFFER, max_screen_height - self.SCREEN_BUFFER)
        return max(self.MIN_INPUT_HEIGHT, limit - resp_min_h - btns_h - overhead - panel_overhead)
    
    def _calculate_content_height(self):
        """Calculate the desired content height based on document size."""
        doc_h = self.input_text.document().size().height()
        input_margins = self.input_text.contentsMargins()
        return int(doc_h + input_margins.top() + input_margins.bottom())
    
    def _update_scrollbar_policy(self, needs_scrollbar, delay_ms=0):
        def set_policy():
            doc_size = self.input_text.document().size().height()
            policy = Qt.ScrollBarPolicy.ScrollBarAsNeeded if (doc_size > self.input_text.viewport().height() or needs_scrollbar) else Qt.ScrollBarPolicy.ScrollBarAlwaysOff
            self.input_text.setVerticalScrollBarPolicy(policy)
        QTimer.singleShot(delay_ms, set_policy) if delay_ms > 0 else set_policy()

    def _update_height(self):
        """Calculate and apply dynamic height with constraint-based limits."""
        # Prevent recursive updates
        if self._updating_height:
            return
        
        self._updating_height = True
        try:
            # Get main window and parent widget
            main_window = self._get_main_window()
            if not main_window:
                return

            parent = self.parentWidget()
            if not parent:
                return

            # Validate layout structure
            layout = parent.layout()
            if not layout or layout.count() < 3:
                return

            # Calculate maximum allowed height
            max_limit = self._calculate_max_height_limit(main_window, layout)
            if max_limit is None:
                return

            # Calculate desired content height
            content_h = self._calculate_content_height()
            
            # Clamp to limits
            final_height = max(self.MIN_INPUT_HEIGHT, min(content_h, max_limit))
            needs_scrollbar = content_h > max_limit
            
            # Update height if changed
            current_height = self.input_text.height()
            height_changed = abs(current_height - final_height) > self.HEIGHT_CHANGE_THRESHOLD
            
            if height_changed:
                # Temporarily hide scrollbar during height change to prevent flash
                self.input_text.setVerticalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)
                self.input_text.setFixedHeight(int(final_height))
                # Update scrollbar policy after layout processes
                self._update_scrollbar_policy(needs_scrollbar, self.SCROLLBAR_UPDATE_DELAY_MS)
            else:
                # Height didn't change, but content might have - update scrollbar immediately
                self._update_scrollbar_policy(needs_scrollbar)
        finally:
            self._updating_height = False

    def get_input_text(self) -> str:
        """Get the text from the input text edit."""
        return self.input_text.toPlainText().strip()

    def set_input_text(self, text: str):
        """Set the text in the input text edit."""
        self.input_text.setPlainText(text)
```

### `gui/widgets/media_panel.py`

```python
# gui/widgets/media_panel.py
"""
Media Panel - Secondary pane for generative imaging interfacing.
Provides tabbed navigation for different image generation APIs.
"""

from PyQt6.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, QPushButton,
    QStackedWidget, QLabel, QSizePolicy
)
from PyQt6.QtCore import Qt, pyqtSignal
from PyQt6.QtGui import QCursor
from gui.widgets.pollinations_page import PollinationsPage
from gui.widgets.airforce_page import AirforcePage
from gui.widgets.perchance_page import PerchancePage


class MediaPanel(QWidget):
    """Secondary pane with tabbed navigation for image generation API interfaces."""

    status_updated = pyqtSignal(str)

    TAB_NAMES = ["Gallery", "Pollinations", "Airforce", "Perchance"]

    ACTIVE_BG = "#1E88E5"
    ACTIVE_HOVER = "#2A9BF8"
    INACTIVE_BG = "#2a2a2a"
    INACTIVE_HOVER = "#3d3d3d"

    _TAB_ICONS = {"Gallery": "ðŸ–¼ï¸", "Pollinations": "ðŸŒ¸", "Airforce": "âœˆï¸", "Perchance": "ðŸŽ²"}
    _TAB_DESCS = {
        "Gallery": "Generated images will appear here",
        "Pollinations": "Pollinations AI image generation",
        "Airforce": "Airforce image generation API",
        "Perchance": "Perchance image generation",
    }

    def __init__(self, config_manager=None, parent=None):
        super().__init__(parent)
        self.config_manager = config_manager
        self.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Expanding)
        self._current_tab = 0
        self._tabs = []
        self._build_ui()
        self._load_active_tab()

    def _build_ui(self):
        layout = QVBoxLayout(self)
        layout.setContentsMargins(0, 0, 0, 0)
        layout.setSpacing(0)

        # --- Tab bar ---
        tab_bar = QWidget()
        tab_bar.setFixedHeight(34)
        tab_bar.setStyleSheet("background-color: #1a1a1a;")
        tab_layout = QHBoxLayout(tab_bar)
        tab_layout.setContentsMargins(0, 0, 0, 0)
        tab_layout.setSpacing(1)

        for i, name in enumerate(self.TAB_NAMES):
            btn = QPushButton(name)
            btn.setCursor(QCursor(Qt.CursorShape.PointingHandCursor))
            btn.setFocusPolicy(Qt.FocusPolicy.NoFocus)
            btn.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Expanding)
            btn.clicked.connect(lambda _, idx=i: self._switch_tab(idx))
            self._tabs.append(btn)
            tab_layout.addWidget(btn)

        layout.addWidget(tab_bar)

        # --- Stacked content area ---
        self._stack = QStackedWidget()
        self._stack.setStyleSheet("background-color: #2a2a2a; border: 1px solid #333;")

        from gui.widgets.gallery_page import GalleryPage
        for name in self.TAB_NAMES:
            if name == "Gallery":
                self.gallery_page = GalleryPage(self.config_manager)
                self.gallery_page.status_updated.connect(self.status_updated.emit)
                self._stack.addWidget(self.gallery_page)
            elif name == "Pollinations":
                self.pollinations_page = PollinationsPage(self.config_manager)
                self.pollinations_page.status_updated.connect(self.status_updated.emit)
                self._stack.addWidget(self.pollinations_page)
            elif name == "Airforce":
                self.airforce_page = AirforcePage(self.config_manager)
                self.airforce_page.status_updated.connect(self.status_updated.emit)
                self._stack.addWidget(self.airforce_page)
            elif name == "Perchance":
                self.perchance_page = PerchancePage(self.config_manager)
                self.perchance_page.status_updated.connect(self.status_updated.emit)
                self._stack.addWidget(self.perchance_page)
            else:
                self._stack.addWidget(self._create_page(name))

        layout.addWidget(self._stack, 1)
        self._update_tab_styles()

    def _create_page(self, name: str) -> QWidget:
        """Create a placeholder page for a tab."""
        page = QWidget()
        page_layout = QVBoxLayout(page)
        page_layout.setAlignment(Qt.AlignmentFlag.AlignCenter)

        icon = QLabel(self._TAB_ICONS.get(name, "ðŸ“„"))
        icon.setStyleSheet("font-size: 32pt;")
        icon.setAlignment(Qt.AlignmentFlag.AlignCenter)
        page_layout.addWidget(icon)

        title = QLabel(name)
        title.setStyleSheet("color: #666; font-size: 14pt; font-weight: bold;")
        title.setAlignment(Qt.AlignmentFlag.AlignCenter)
        page_layout.addWidget(title)

        desc = QLabel(self._TAB_DESCS.get(name, ""))
        desc.setStyleSheet("color: #444; font-size: 9pt;")
        desc.setAlignment(Qt.AlignmentFlag.AlignCenter)
        desc.setWordWrap(True)
        page_layout.addWidget(desc)

        return page

    def _switch_tab(self, index: int):
        """Switch to the specified tab index."""
        if index == self._current_tab:
            return
        self._current_tab = index
        self._stack.setCurrentIndex(index)
        self._update_tab_styles()
        
        current_widget = self._stack.widget(index)
        if hasattr(current_widget, "refresh"):
            current_widget.refresh()
            
        if self.config_manager:
            self.config_manager.media_active_tab = index
            self.config_manager.save()

    def _load_active_tab(self):
        """Restore the last active tab from config."""
        if self.config_manager:
            tab = getattr(self.config_manager, 'media_active_tab', 0)
            if 0 <= tab < len(self.TAB_NAMES):
                self._current_tab = tab
                self._stack.setCurrentIndex(tab)
                self._update_tab_styles()

    def _update_tab_styles(self):
        """Update tab button visual styles based on active selection."""
        for i, btn in enumerate(self._tabs):
            if i == self._current_tab:
                btn.setStyleSheet(f"""
                    QPushButton {{
                        background-color: {self.ACTIVE_BG};
                        color: #ffffff;
                        font-weight: bold;
                        font-size: 9pt;
                        border: none;
                        border-radius: 0px;
                        padding: 4px 8px;
                    }}
                    QPushButton:hover {{
                        background-color: {self.ACTIVE_HOVER};
                    }}
                """)
            else:
                btn.setStyleSheet(f"""
                    QPushButton {{
                        background-color: {self.INACTIVE_BG};
                        color: #888;
                        font-size: 9pt;
                        border: none;
                        border-radius: 0px;
                        padding: 4px 8px;
                    }}
                    QPushButton:hover {{
                        background-color: {self.INACTIVE_HOVER};
                        color: #fff;
                    }}
                """)
```

### `gui/widgets/perchance_page.py`

```python
# gui/widgets/perchance_page.py
"""
Perchance Page â€“ Embeds a Perchance image generator in a QWebEngineView
with ad-blocking and persistent login / cookie storage.
"""

from PyQt6.QtWidgets import QWidget, QVBoxLayout, QLabel, QSizePolicy
from PyQt6.QtCore import pyqtSignal, Qt

from core.services.perchance_service import PerchanceService, is_webengine_available

PERCHANCE_URL = "https://perchance.org/a1481832-0a06-414f-baa6-616052e5f61d"


class PerchancePage(QWidget):
    """
    Perchance image generation page.

    Loads the Perchance generator URL inside a QWebEngineView with:

    * Persistent cookie / login profile
    * Two-layer ad blocking (request interception + DOM hiding)
    * Automatic image-download handling to ``images/``

    Falls back to a static label when PyQt6-WebEngine is not installed.
    """

    status_updated = pyqtSignal(str)

    def __init__(self, config_manager=None, parent=None):
        super().__init__(parent)
        self.config_manager = config_manager
        self.service = PerchanceService(config_manager)
        self.service.set_status_callback(self.status_updated.emit)

        self._webview = None
        self._page = None
        self._url_loaded = False

        self.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Expanding)
        self._build_ui()

    # â”€â”€ UI construction â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    def _build_ui(self):
        layout = QVBoxLayout(self)
        layout.setContentsMargins(0, 0, 0, 0)
        layout.setSpacing(0)

        if not is_webengine_available():
            self._build_fallback(layout)
            return

        try:
            from PyQt6.QtWebEngineWidgets import QWebEngineView
            from PyQt6.QtWebEngineCore import QWebEnginePage

            # Persistent profile (cookies, ad-blocking, download handling)
            profile = self.service.create_profile(self)
            if not profile:
                self._build_fallback(layout)
                return

            self._webview = QWebEngineView()
            self._page = QWebEnginePage(profile, self._webview)
            self._webview.setPage(self._page)

            # Give service access to the page for JS prompt extraction
            self.service.set_page(self._page)

            # Inject ad-hiding JS after each page load
            self._webview.loadFinished.connect(self._on_load_finished)

            layout.addWidget(self._webview, 1)

        except Exception as e:
            self._build_fallback(layout, str(e))

    def _build_fallback(self, layout, error_msg=None):
        """Display an informational placeholder when WebEngine is unavailable."""
        container = QWidget()
        cl = QVBoxLayout(container)
        cl.setAlignment(Qt.AlignmentFlag.AlignCenter)

        icon = QLabel("\U0001f3b2")  # ðŸŽ²
        icon.setStyleSheet("font-size: 32pt;")
        icon.setAlignment(Qt.AlignmentFlag.AlignCenter)
        cl.addWidget(icon)

        title = QLabel("Perchance")
        title.setStyleSheet("color: #666; font-size: 14pt; font-weight: bold;")
        title.setAlignment(Qt.AlignmentFlag.AlignCenter)
        cl.addWidget(title)

        lines = ["PyQt6-WebEngine is required for Perchance integration."]
        if error_msg:
            lines.append(f"\n{error_msg}")
        lines.append("\nInstall:  pip install PyQt6-WebEngine")
        lines.append(f"\nOr visit directly:\n{PERCHANCE_URL}")

        desc = QLabel("\n".join(lines))
        desc.setStyleSheet("color: #888; font-size: 9pt;")
        desc.setAlignment(Qt.AlignmentFlag.AlignCenter)
        desc.setWordWrap(True)
        desc.setTextInteractionFlags(Qt.TextInteractionFlag.TextSelectableByMouse)
        cl.addWidget(desc)

        layout.addWidget(container)

    # â”€â”€ Events â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    def showEvent(self, event):
        """Lazy-load the URL on first show to avoid heavy init at startup."""
        super().showEvent(event)
        if self._webview and not self._url_loaded:
            self._url_loaded = True
            from PyQt6.QtCore import QUrl

            url = PERCHANCE_URL
            if self.config_manager:
                url = getattr(self.config_manager, "perchance_url", url) or url
            self._webview.setUrl(QUrl(url))

    def _on_load_finished(self, ok: bool):
        """Inject ad-hiding JavaScript after the page finishes loading."""
        if not ok or not self._page:
            return
        script = self.service.get_ad_hide_script()
        if script:
            self._page.runJavaScript(script)
```

### `gui/widgets/pollinations_page.py`

```python
# gui/widgets/pollinations_page.py
"""
Pollinations Page - Image generation interface for the Pollinations AI API.
Provides controls for prompt, model, size, seed and displays generated images.
"""

from PyQt6.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, QPushButton, QLineEdit
)
from PyQt6.QtCore import pyqtSignal, Qt, QTimer, QEvent
from PyQt6.QtGui import QCursor

import os

from gui.widgets.image_gen_common import (
    ImageDisplay, INPUT_STYLE, BTN_GENERATE, BTN_CANCEL,
    BTN_DROPDOWN, make_dropdown,
)
from core.services.pollinations_service import PollinationsService
from core.utils import reveal_file_in_explorer


class PollinationsPage(QWidget):
    """Pollinations AI image generation page with controls and image display."""

    status_updated = pyqtSignal(str)

    MODELS = ["flux", "zimage", "klein", "klein-large", "gptimage"]
    SIZES = ["1024x1024", "1344x768", "768x1344"]
    DEFAULT_MODEL = "zimage"
    DEFAULT_SIZE = "1024x1024"
    DEFAULT_SEED = -1

    def __init__(self, config_manager=None, parent=None):
        super().__init__(parent)
        self.config_manager = config_manager
        self.current_model = self.DEFAULT_MODEL
        self.current_size = self.DEFAULT_SIZE
        self._is_generating = False
        self._current_image_path = ""

        self.active_dropdown = None
        self.hide_timer = QTimer()
        self.hide_timer.setInterval(250)
        self.hide_timer.timeout.connect(self._hide_dropdown)

        self.service = PollinationsService()
        self.service.image_generated.connect(self._on_image_generated)
        self.service.error_occurred.connect(self._on_error)
        self.service.status_updated.connect(self.status_updated.emit)

        self._build_ui()
        self._load_from_config()

    def _build_ui(self):
        layout = QVBoxLayout(self)
        layout.setContentsMargins(0, 0, 0, 0)
        layout.setSpacing(0)

        # --- Controls bar ---
        controls = QWidget()
        controls.setStyleSheet("background-color: #121212;")
        cl = QHBoxLayout(controls)
        cl.setContentsMargins(4, 4, 4, 4)
        cl.setSpacing(6)

        self.generate_btn = QPushButton("Generate")
        self.generate_btn.setStyleSheet(BTN_GENERATE)
        self.generate_btn.setCursor(QCursor(Qt.CursorShape.PointingHandCursor))
        self.generate_btn.setFocusPolicy(Qt.FocusPolicy.NoFocus)
        self.generate_btn.clicked.connect(self._on_generate_clicked)
        cl.addWidget(self.generate_btn)

        self.positive_input = QLineEdit()
        self.positive_input.setPlaceholderText("Positive Prompt...")
        self.positive_input.setStyleSheet(INPUT_STYLE)
        self.positive_input.returnPressed.connect(self._on_generate_clicked)
        cl.addWidget(self.positive_input, stretch=2)

        self.negative_input = QLineEdit()
        self.negative_input.setPlaceholderText("Negative Prompt...")
        self.negative_input.setStyleSheet(INPUT_STYLE)
        self.negative_input.returnPressed.connect(self._on_generate_clicked)
        cl.addWidget(self.negative_input, stretch=1)

        self.model_btn = QPushButton(self.current_model)
        self.model_btn.setStyleSheet(BTN_DROPDOWN)
        self.model_btn.setCursor(QCursor(Qt.CursorShape.PointingHandCursor))
        self.model_btn.setFocusPolicy(Qt.FocusPolicy.NoFocus)
        self.model_btn.setMinimumWidth(90)
        self.model_btn.installEventFilter(self)
        cl.addWidget(self.model_btn)

        self.size_btn = QPushButton(self.current_size)
        self.size_btn.setStyleSheet(BTN_DROPDOWN)
        self.size_btn.setCursor(QCursor(Qt.CursorShape.PointingHandCursor))
        self.size_btn.setFocusPolicy(Qt.FocusPolicy.NoFocus)
        self.size_btn.setMinimumWidth(90)
        self.size_btn.installEventFilter(self)
        cl.addWidget(self.size_btn)

        self.seed_input = QLineEdit(str(self.DEFAULT_SEED))
        self.seed_input.setStyleSheet(INPUT_STYLE)
        self.seed_input.setFixedWidth(64)
        self.seed_input.setAlignment(Qt.AlignmentFlag.AlignCenter)
        self.seed_input.setToolTip("Seed (-1 for random)")
        self.seed_input.returnPressed.connect(self._on_generate_clicked)
        cl.addWidget(self.seed_input)

        layout.addWidget(controls)

        # --- Image display ---
        self.image_display = ImageDisplay()
        self.image_display.clicked.connect(self._on_image_clicked)
        layout.addWidget(self.image_display, 1)

        # --- Dropdowns ---
        self.model_dropdown = make_dropdown(
            self, self.MODELS, self._on_model_selected, self
        )
        self.size_dropdown = make_dropdown(
            self, self.SIZES, self._on_size_selected, self
        )

    # ---------------------------------------------------------------- Dropdowns

    def eventFilter(self, obj, event):
        et = event.type()
        if et == QEvent.Type.Enter:
            if obj == self.model_btn:
                self._show_dropdown(self.model_dropdown, self.model_btn)
            elif obj == self.size_btn:
                self._show_dropdown(self.size_dropdown, self.size_btn)
            elif obj in (self.model_dropdown, self.size_dropdown):
                self.hide_timer.stop()
        elif et == QEvent.Type.Leave:
            if obj in (self.model_btn, self.size_btn,
                       self.model_dropdown, self.size_dropdown):
                self.hide_timer.start()
        return super().eventFilter(obj, event)

    def _show_dropdown(self, dropdown, button):
        if self._is_generating:
            return
        self.hide_timer.stop()
        if self.active_dropdown and self.active_dropdown is not dropdown:
            self.active_dropdown.hide()
        if self.active_dropdown is dropdown:
            return
        self.active_dropdown = dropdown
        pos = button.mapToGlobal(button.rect().bottomLeft())
        dropdown.move(pos.x(), pos.y() + 2)
        dropdown.show()
        dropdown.raise_()

    def _hide_dropdown(self):
        if self.active_dropdown:
            self.active_dropdown.hide()
            self.active_dropdown = None

    def _on_model_selected(self, model: str):
        self.current_model = model
        self.model_btn.setText(model)
        self._hide_dropdown()
        self._save_to_config()

    def _on_size_selected(self, size: str):
        self.current_size = size
        self.size_btn.setText(size)
        self._hide_dropdown()
        self._save_to_config()

    # ------------------------------------------------------------ Generation

    def _on_generate_clicked(self):
        if self._is_generating:
            self.service.cancel_generation()
            self._set_generating(False)
            self.status_updated.emit("Generation cancelled.")
            return

        prompt = self.positive_input.text().strip()
        if not prompt:
            self.status_updated.emit("Error: Positive prompt cannot be empty.")
            return

        try:
            seed = int(self.seed_input.text().strip())
        except ValueError:
            seed = -1

        w, h = self.current_size.split("x")
        self._set_generating(True)
        self._save_to_config()
        self.service.generate_image(
            prompt=prompt,
            negative_prompt=self.negative_input.text().strip(),
            model=self.current_model,
            width=int(w),
            height=int(h),
            seed=seed,
        )

    def _on_image_generated(self, filepath: str):
        self._set_generating(False)
        self._current_image_path = filepath
        self.image_display.set_image(filepath)
        self._save_to_config()

    def _on_error(self, _error_msg: str):
        self._set_generating(False)

    def _set_generating(self, state: bool):
        self._is_generating = state
        self.positive_input.setEnabled(not state)
        self.negative_input.setEnabled(not state)
        self.model_btn.setEnabled(not state)
        self.size_btn.setEnabled(not state)
        self.seed_input.setEnabled(not state)

        if state:
            self._hide_dropdown()
            self.generate_btn.setText("Cancel")
            self.generate_btn.setStyleSheet(BTN_CANCEL)
        else:
            self.generate_btn.setText("Generate")
            self.generate_btn.setStyleSheet(BTN_GENERATE)

    def hideEvent(self, event):
        """Close dropdowns when page is hidden (tab switch)."""
        self._hide_dropdown()
        super().hideEvent(event)

    def _on_image_clicked(self):
        """Open file explorer and select the current image."""
        if self._current_image_path and os.path.isfile(self._current_image_path):
            reveal_file_in_explorer(self._current_image_path)
        else:
            self.status_updated.emit("Image file not found on disk.")

    def _save_to_config(self):
        """Persist current Pollinations settings to config."""
        if not self.config_manager:
            return
        self.config_manager.pollinations_positive_prompt = self.positive_input.text()
        self.config_manager.pollinations_negative_prompt = self.negative_input.text()
        self.config_manager.pollinations_model = self.current_model
        self.config_manager.pollinations_size = self.current_size
        try:
            self.config_manager.pollinations_seed = int(self.seed_input.text())
        except ValueError:
            self.config_manager.pollinations_seed = self.DEFAULT_SEED
        self.config_manager.pollinations_last_image = self._current_image_path
        self.config_manager.save()

    def _load_from_config(self):
        """Load persisted Pollinations settings from config."""
        if not self.config_manager:
            return

        self.positive_input.setText(
            getattr(self.config_manager, 'pollinations_positive_prompt', ''))
        self.negative_input.setText(
            getattr(self.config_manager, 'pollinations_negative_prompt', ''))

        model = getattr(self.config_manager, 'pollinations_model', self.DEFAULT_MODEL)
        if model in self.MODELS:
            self.current_model = model
            self.model_btn.setText(model)

        size = getattr(self.config_manager, 'pollinations_size', self.DEFAULT_SIZE)
        if size in self.SIZES:
            self.current_size = size
            self.size_btn.setText(size)

        seed = getattr(self.config_manager, 'pollinations_seed', self.DEFAULT_SEED)
        self.seed_input.setText(str(seed))

        last_image = getattr(self.config_manager, 'pollinations_last_image', '')
        if last_image and os.path.isfile(last_image):
            self._current_image_path = last_image
            self.image_display.set_image(last_image)
```

### `gui/widgets/response_panel.py`

```python
# gui/widgets/response_panel.py
"""
Response Panel - Displays chat history with Gemini responses and user inputs.
Read-only, highlightable for copying, no size constraints.
"""

from typing import Optional, List
import html
import markdown
from PyQt6.QtWidgets import (
    QWidget, QVBoxLayout, QTextEdit, QSizePolicy, QLineEdit, QPushButton, QHBoxLayout, QTextBrowser
)
from PyQt6.QtCore import Qt, pyqtSignal, QPoint, QTimer
from PyQt6.QtGui import QKeyEvent, QTextCursor


class SearchLineEdit(QLineEdit):
    """Custom QLineEdit with keyboard shortcuts for search widget."""

    def keyPressEvent(self, event: QKeyEvent):
        if event.key() == Qt.Key.Key_Escape:
            # Close the search widget
            self.parent().close_requested.emit()
            event.accept()
        elif event.key() == Qt.Key.Key_Return or event.key() == Qt.Key.Key_Enter:
            # Go to next match
            self.parent().next_requested.emit()
            event.accept()
        else:
            # Default behavior for other keys
            super().keyPressEvent(event)


class SearchWidget(QWidget):
    """A search widget for finding text in the response panel."""

    search_requested = pyqtSignal(str)  # search term
    next_requested = pyqtSignal()
    previous_requested = pyqtSignal()
    close_requested = pyqtSignal()

    def __init__(self, parent=None):
        super().__init__(parent)
        self.setWindowFlags(Qt.WindowType.FramelessWindowHint | Qt.WindowType.Tool)
        self.setStyleSheet("""
            QWidget {
                background-color: #2a2a2a;
                border: 1px solid #555;
                border-radius: 4px;
            }
            QLineEdit {
                background-color: #1e1e1e;
                color: #ffffff;
                border: 1px solid #333;
                border-radius: 4px;
                padding: 4px;
                font-size: 10pt;
            }
            QPushButton {
                background-color: #3d3d3d;
                color: #ffffff;
                border: 1px solid #333;
                border-radius: 4px;
                padding: 4px;
                font-size: 10pt;
            }
            QPushButton:hover { background-color: #4d4d4d; }
            QPushButton:pressed { background-color: #2d2d2d; }
        """)

        layout = QHBoxLayout(self)
        layout.setContentsMargins(8, 8, 8, 8)
        layout.setSpacing(4)

        self.search_input = SearchLineEdit()
        self.search_input.setPlaceholderText("Search...")
        self.search_input.textChanged.connect(self.search_requested.emit)
        layout.addWidget(self.search_input)

        self.prev_btn = QPushButton("â–²")
        self.prev_btn.setFixedSize(24, 24)
        self.prev_btn.clicked.connect(self.previous_requested.emit)
        layout.addWidget(self.prev_btn)

        self.next_btn = QPushButton("â–¼")
        self.next_btn.setFixedSize(24, 24)
        self.next_btn.clicked.connect(self.next_requested.emit)
        layout.addWidget(self.next_btn)

        self.close_btn = QPushButton("Ã—")
        self.close_btn.setFixedSize(24, 24)
        self.close_btn.clicked.connect(self.close_requested.emit)
        layout.addWidget(self.close_btn)

        self.adjustSize()

    def set_match_count(self, current, total):
        """Update button tooltips with match info."""
        if total > 0:
            self.prev_btn.setToolTip(f"Previous match ({current}/{total})")
            self.next_btn.setToolTip(f"Next match ({current}/{total})")
        else:
            self.prev_btn.setToolTip("No matches")
            self.next_btn.setToolTip("No matches")


class ResponsePanel(QWidget):
    """A panel for displaying chat history."""

    def __init__(self, parent=None):
        super().__init__(parent)
        self.layout = QVBoxLayout(self)
        self.layout.setContentsMargins(0, 0, 0, 0)
        self.layout.setSpacing(10)

        self.response_text = QTextBrowser()
        self.response_text.setOpenLinks(False)
        self.response_text.anchorClicked.connect(self.handle_link_click)
        self.response_text.setPlainText("")
        self.response_text.setStyleSheet("background-color: #2a2a2a; color: #ffffff; border: 1px solid #333;")
        self.response_text.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Ignored)
        self.response_text.setMinimumHeight(40)
        self.layout.addWidget(self.response_text, stretch=1)

        # Search functionality
        self.search_widget = None
        self.search_matches = []
        self.current_match_index = -1
        
        # Streaming state
        self._is_streaming = False
        self._stream_buffer = ""  # Buffer for current streaming response
        self._thinking_buffer = ""  # Buffer for thinking content
        self._stream_has_thinking = False  # Track if we've received thinking tokens
        
        # Performance: Batched streaming updates
        self._pending_text = ""  # Pending text to be flushed
        self._pending_is_thinking = False  # Type of pending text
        self._update_timer = QTimer()
        self._update_timer.timeout.connect(self._flush_pending_updates)
        self._update_timer.setInterval(50)  # 50ms batch interval
        
        # Performance: Throttled auto-scroll
        self._scroll_timer = QTimer()
        self._scroll_timer.timeout.connect(self._do_scroll)
        self._scroll_timer.setInterval(100)  # 100ms scroll interval
        self._scroll_pending = False
        
        # Track stream start position for re-rendering
        self._stream_start_cursor_pos = 0
        
        # Display filtering parameters
        self.display_fields = {}
        
        # Color constants
        self.THINKING_COLOR = "#4ECDC4"  # Teal for thinking tokens
        self.ASSISTANT_COLOR = "#ffffff"  # White for regular response
        self.USER_COLOR = "#888888"  # Grey for user messages
        
        # Sentinel for JSON HTML blocks to bypass markdown processing
        self._JSON_SENTINEL = "\x02JSON_TABLE\x03"

    def start_stream(self):
        """Prepare panel for streaming (add new message block)."""
        self._is_streaming = True
        self._stream_buffer = ""
        self._thinking_buffer = ""
        self._stream_has_thinking = False
        self._pending_text = ""
        self._pending_is_thinking = False
        # Move cursor to end and record position for later re-rendering
        self.response_text.moveCursor(QTextCursor.MoveOperation.End)
        self._stream_start_cursor_pos = self.response_text.textCursor().position()
        # Start update timer
        self._update_timer.start()
        self._scroll_timer.start()

    def append_stream_chunk(self, text: str):
        """Append regular response chunk in real-time (white color)."""
        if not text:
            return
        self._stream_buffer += text
        # If switching from thinking to response, add visual separator
        if self._stream_has_thinking and self._pending_is_thinking:
            # Flush any pending thinking text first
            self._flush_pending_updates()
            # Add newline separator between thinking and response
            self.response_text.moveCursor(QTextCursor.MoveOperation.End)
            self.response_text.insertHtml('<br>')
        # Queue for batched update
        self._pending_text += text
        self._pending_is_thinking = False
        self._scroll_pending = True

    def append_thinking_chunk(self, text: str):
        """Append thinking chunk in teal color."""
        if not text:
            return
        self._thinking_buffer += text
        self._stream_has_thinking = True
        # Queue for batched update
        self._pending_text += text
        self._pending_is_thinking = True
        self._scroll_pending = True

    def _flush_pending_updates(self):
        """Flush pending text updates to the display (called by timer)."""
        if not self._pending_text:
            return
        color = self.THINKING_COLOR if self._pending_is_thinking else self.ASSISTANT_COLOR
        html_text = f'<span style="color: {color}; white-space: pre-wrap;">{html.escape(self._pending_text).replace(chr(10), "<br>")}</span>'
        self.response_text.moveCursor(QTextCursor.MoveOperation.End)
        self.response_text.insertHtml(html_text)
        self._pending_text = ""

    def _do_scroll(self):
        """Perform throttled auto-scroll (called by timer)."""
        if self._scroll_pending:
            scrollbar = self.response_text.verticalScrollBar()
            scrollbar.setValue(scrollbar.maximum())
            self._scroll_pending = False

    def end_stream(self):
        """Finalize streaming message with proper markdown rendering."""
        if self._is_streaming:
            # Stop timers
            self._update_timer.stop()
            self._scroll_timer.stop()
            # Flush any remaining pending updates
            self._flush_pending_updates()
            
            self._is_streaming = False
            
            # Re-render the streamed content with proper markdown
            self._rerender_stream_with_markdown()
            
            # Add line break after completed message
            self.response_text.moveCursor(QTextCursor.MoveOperation.End)
            self.response_text.insertHtml("<br>")
            
            # Final scroll to bottom
            scrollbar = self.response_text.verticalScrollBar()
            scrollbar.setValue(scrollbar.maximum())
            
            # Reset buffers
            self._stream_buffer = ""
            self._thinking_buffer = ""
            self._stream_has_thinking = False

    def _insert_md(self, text: str, color: str, br: bool = True):
        if not text.strip(): return
        self.response_text.moveCursor(QTextCursor.MoveOperation.End)
        
        md_text = markdown.markdown(text, extensions=["extra", "codehilite", "nl2br"])
        
        # Override PyQt's default <pre> and <code> styles to preserve word wrap and maintain the app's font
        md_text = md_text.replace("<pre>", "<pre style=\"white-space: pre-wrap; word-wrap: break-word; font-family: Consolas; font-size: 9pt; margin-top: 4px; margin-bottom: 4px;\">")
        md_text = md_text.replace("<code>", "<code style=\"font-family: Consolas; font-size: 9pt;\">")
        
        html = f'<span style="color: {color};">{md_text}</span>'
        self.response_text.insertHtml(html + ('<br>' if br else ''))

    def _insert_content(self, text: str, color: str):
        """Insert content that may contain JSON HTML tables mixed with markdown text."""
        if self._JSON_SENTINEL not in text:
            self._insert_md(text, color, br=False)
            return
        
        parts = text.split(self._JSON_SENTINEL)
        for i, part in enumerate(parts):
            if i % 2 == 0:
                # Text part â€” render as markdown
                if part.strip():
                    self._insert_md(part, color, br=False)
            else:
                # JSON HTML part â€” insert directly, no markdown processing
                self.response_text.moveCursor(QTextCursor.MoveOperation.End)
                self.response_text.insertHtml(part)

    def _filter_json_content(self, text: str) -> str:
        """Filter raw JSON content strictly using toggle states and format visually."""
        from core.json_helper import JsonHelper
        import re
        
        if '{' not in text:
            return text

        def replace_json(match):
            json_str = match.group(1) if len(match.groups()) > 0 else match.group(0)
            data = JsonHelper.extract_and_parse_json(json_str)
            if data and isinstance(data, dict):
                return self._format_json_html(data)
            return match.group(0)

        # Execute replacement if a codeblock exists
        if re.search(r'```(?:json)?\s*\{.*?\}\s*```', text, re.DOTALL):
            return re.sub(r'```(?:json)?\s*(\{.*?\})\s*```', replace_json, text, flags=re.DOTALL)
        
        # Attempt raw JSON parse if it looks like a JSON block
        stripped = text.strip()
        if stripped.startswith('{') and stripped.endswith('}'):
            data = JsonHelper.extract_and_parse_json(stripped)
            if data and isinstance(data, dict):
                return self._format_json_html(data)
                
        return text

    def _format_json_html(self, data: dict) -> str:
        import base64
        import html as html_mod
        import json
        filtered_data = {k: v for k, v in data.items() if self.display_fields.get(k, True)}
        if not filtered_data:
            return ""

        html_parts = [
            self._JSON_SENTINEL,
            '<table width="100%" cellspacing="0" cellpadding="10" style="border-collapse: collapse; background-color: #1e1e1e;">'
        ]
        
        items = list(filtered_data.items())
        for idx, (k, v) in enumerate(items):
            if isinstance(v, (dict, list)):
                val_str = json.dumps(v, indent=2)
            else:
                val_str = str(v)
                
            encoded_val = base64.b64encode(val_str.encode('utf-8')).decode('utf-8')
            escaped_val = html_mod.escape(val_str).replace('\n', '<br>')
            
            border_bottom = 'border-bottom: 1px solid #333;' if idx < len(items) - 1 else ''
            
            row = f'<tr><td width="20%" style="{border_bottom} color: #4ECDC4; font-weight: bold; vertical-align: top; font-family: Consolas, monospace; font-size: 10pt; padding: 10px;">{html_mod.escape(str(k))}</td><td style="{border_bottom} vertical-align: top; font-family: Consolas, monospace; font-size: 10pt; padding: 10px;"><a href="copy:{encoded_val}" title="Click to copy" style="color: #e0e0e0; text-decoration: none;">{escaped_val}</a></td></tr>'
            html_parts.append(row)
            
        html_parts.append('</table>')
        html_parts.append(self._JSON_SENTINEL)
        return "".join(html_parts)

    def _rerender_stream_with_markdown(self):
        """Remove raw streamed text and replace with markdown-rendered version."""
        cursor = self.response_text.textCursor()
        cursor.setPosition(self._stream_start_cursor_pos)
        cursor.movePosition(QTextCursor.MoveOperation.End, QTextCursor.MoveMode.KeepAnchor)
        cursor.removeSelectedText()
        
        self._insert_md(self._thinking_buffer.strip(), self.THINKING_COLOR, br=False)
        
        content = self._filter_json_content(self._stream_buffer.strip())
        self._insert_content(content, self.ASSISTANT_COLOR)

    def show_search(self):
        """Show the search widget."""
        if self.search_widget is None:
            self.search_widget = SearchWidget(self.window())
            self.search_widget.search_requested.connect(self.perform_search)
            self.search_widget.next_requested.connect(self.next_match)
            self.search_widget.previous_requested.connect(self.previous_match)
            self.search_widget.close_requested.connect(self.hide_search)

        # Position in top-right
        panel_rect = self.geometry()
        widget_size = self.search_widget.sizeHint()
        x = panel_rect.right() - widget_size.width() - 10
        y = panel_rect.top() + 10
        self.search_widget.move(self.mapToGlobal(panel_rect.topLeft()) + QPoint(x, y))
        self.search_widget.show()
        self.search_widget.raise_()
        self.search_widget.activateWindow()
        # Set focus after the widget is fully shown and activated
        QTimer.singleShot(10, lambda: self.search_widget.search_input.setFocus())

    def hide_search(self):
        """Hide the search widget."""
        if self.search_widget:
            self.search_widget.hide()
            self.clear_search_highlights()

    def perform_search(self, term: str):
        """
        Perform case-insensitive search for the given term in the response text.

        Finds all occurrences of the term, stores their positions, and highlights the first match.
        If no matches found, clears any existing highlights.

        Args:
            term: The search term to find
        """
        if not term:
            self.clear_search_highlights()
            return

        # Get plain text for searching
        plain_text = self.response_text.toPlainText()
        self.search_matches = []
        start = 0
        term_lower = term.lower()

        while True:
            pos = plain_text.lower().find(term_lower, start)
            if pos == -1:
                break
            self.search_matches.append((pos, pos + len(term)))
            start = pos + 1

        if self.search_matches:
            self.current_match_index = 0
            self.update_highlights()
            self.scroll_to_match(0)
        else:
            self.clear_search_highlights()

        self.update_search_widget()

    def navigate_match(self, step: int):
        """Navigate through search matches by step (+1 or -1)."""
        if self.search_matches:
            self.current_match_index = (self.current_match_index + step) % len(self.search_matches)
            self.update_highlights()
            self.scroll_to_match(self.current_match_index)
            self.update_search_widget()

    def next_match(self):
        self.navigate_match(1)

    def previous_match(self):
        self.navigate_match(-1)

    def update_highlights(self):
        """
        Update search highlights using QTextEdit extra selections.

        Applies different highlighting: yellow background for current match,
        cyan background for other matches. Clears previous highlights first.
        """
        from PyQt6.QtGui import QTextCharFormat

        self.response_text.setExtraSelections([])
        if not self.search_matches:
            return

        selections = []
        for i, (start, end) in enumerate(self.search_matches):
            cursor = QTextCursor(self.response_text.document())
            cursor.setPosition(start)
            cursor.setPosition(end, QTextCursor.MoveMode.KeepAnchor)

            selection = QTextEdit.ExtraSelection()
            selection.cursor = cursor

            format = QTextCharFormat()
            if i == self.current_match_index:
                # Current match - yellow background, black text
                format.setBackground(Qt.GlobalColor.yellow)
                format.setForeground(Qt.GlobalColor.black)
            else:
                # Other matches - light blue background
                format.setBackground(Qt.GlobalColor.cyan)

            selection.format = format
            selections.append(selection)

        self.response_text.setExtraSelections(selections)

    def clear_search_highlights(self):
        self.response_text.setExtraSelections([])
        self.search_matches.clear()
        self.current_match_index = -1
        self.update_search_widget()

    def scroll_to_match(self, index):
        """
        Scroll the text edit to make the specified match visible.

        Args:
            index: Index of the match in self.search_matches to scroll to
        """
        if 0 <= index < len(self.search_matches):
            start, end = self.search_matches[index]
            cursor = self.response_text.textCursor()
            cursor.setPosition(start)
            self.response_text.setTextCursor(cursor)
            self.response_text.ensureCursorVisible()

    def update_search_widget(self):
        """
        Update the search widget with current match count information.

        Displays current match number and total matches in the widget tooltips.
        """
        if self.search_widget:
            if self.search_matches:
                current = self.current_match_index + 1
                total = len(self.search_matches)
            else:
                current = 0
                total = 0
            self.search_widget.set_match_count(current, total)

    def append_user_message(self, text: str, filenames: Optional[List[str]] = None):
        """Append a user message in grey color."""
        display_text = text
        if filenames:
            display_text = f"{text} [{', '.join(filenames)}]"
        html_text = f'<span style="color: #888888;">{html.escape(display_text).replace(chr(10), "<br>")}</span><br>'
        self.response_text.moveCursor(QTextCursor.MoveOperation.End)
        self.response_text.insertHtml(html_text)

    def append_assistant_message(self, text: str):
        import re
        if match := re.search(r'<thinking>\n?(.*?)\n?</thinking>\n?', text, re.DOTALL):
            self._insert_md(match.group(1).strip(), self.THINKING_COLOR, br=False)
            content = text[match.end():].strip()
        else:
            content = text.strip()
            
        content = self._filter_json_content(content)
        self._insert_content(content, self.ASSISTANT_COLOR)
        self.response_text.moveCursor(QTextCursor.MoveOperation.End)
        self.response_text.insertHtml("<br>")

    def scroll_to_bottom(self):
        """Scroll the response text to the bottom."""
        scrollbar = self.response_text.verticalScrollBar()
        scrollbar.setValue(scrollbar.maximum())

    def clear(self):
        """Clear the response area."""
        self.response_text.clear()

    def handle_link_click(self, url):
        """Handle clicking on a link."""
        if url.scheme() == "copy":
            import base64
            from PyQt6.QtWidgets import QApplication
            try:
                encoded_text = url.toString().split(':', 1)[1]
                decoded_text = base64.b64decode(encoded_text).decode('utf-8')
                QApplication.clipboard().setText(decoded_text)
                
                # Notify the user via a status message
                window = self.window()
                if hasattr(window, 'status_signal'):
                    window.status_signal.emit(f"Copied field value to clipboard! ({len(decoded_text)} characters)")
            except Exception as e:
                pass
        else:
            # Handle regular web links
            import webbrowser
            webbrowser.open(url.toString())
```
