### TASKS

We're moving the project to the next phase, which is an introduction to integration with various image generation APIs (the models themselves which generate the images).

## CURRENT PHASE TASK:

You have full creative liberty to design and implement any system which covers these goals:

1. Complete implementation of the Perchance image generator in the media panel. Use `https://perchance.org/a1481832-0a06-414f-baa6-616052e5f61d` as the URL. If needed, create `./core/services/perchance_service.py` and `./gui/widgets/perchance_page.py`.

2. The Perchance page is unlike our other pages. It's not an API service we can call, instead we load a web page in an iframe with adblocker. As such, the top bar for model parameters and configurations are already set on the web page we load. On this web page, users can generate images in a very similar style.

3. After the generation, the image is received and downloaded to a folder `images`. Use a similar naming convention for the filenames as we do chats e.g. `2026-02-20_15-41-48`. If possible, embed the prompt data and the service used into the metadata of the image file. Save as `.jpg`.

4. Persistence with configurations, similar to pollinations. (scope for this is cookies (may be handled natively by the library(?)) for saving web page login, and the active navigation tab, and may already be implemented.)

### NON-GOALS

These are OUT OF PHASE TASK:

1. There's no parameters to configure, nor status bar updates we can pipe/interact with most likely. No last image loading, no left click to open image, prompt persistance saving, etc. as it's an external web page.
2. Gallery image work

### PERCHANCE DEVELOPER GUIDE

The following is an extrapolation of a working perchance iframe embed in an older project. The project itself has gone through numerous troubles, so don't look at this reference with rose-colored glasses. There is a lot to improve in here, so just take the information you need, and improve upon it:

# Perchance iframe Integration

This document describes how this project integrated a Perchance iframe panel with built-in adblocking capabilities. The implementation uses PyQt6's WebEngine widgets.

## Overview

The Perchance panel is a web view component that embeds an external Perchance URL. The implementation addresses two primary concerns:

1. **iframe Loading** - Loading external web content with persistent storage
2. **Adblocker** - Blocking ad networks at the request level and hiding ad elements in the DOM

---

## iframe Loading

### WebEngine Availability Check

The project uses a try/except pattern to handle environments where PyQt6-WebEngine may not be installed:

```python
try:
    from PyQt6.QtWebEngineWidgets import QWebEngineView
    from PyQt6.QtWebEngineCore import QWebEnginePage, QWebEngineUrlRequestInterceptor, QWebEngineProfile
    self.webview = QWebEngineView()
    # ... setup code
except ImportError:
    label = QLabel("WebEngine is required for Perchance integration.")
    label.setStyleSheet("color: #ffffff; font-size: 12pt; padding: 20px;")
    self.layout.addWidget(label)
```

This pattern allows the application to gracefully degrade when WebEngine is unavailable.

### Persistent Profile for Cookies and Login State

A key challenge was preserving user login state across application restarts. The solution uses a named `QWebEngineProfile` with persistent storage:

```python
def _create_persistent_profile(self):
    """
    Create a persistent QWebEngineProfile for storing cookies and browser data.
    """
    from PyQt6.QtWebEngineCore import QWebEngineProfile

    # Put the profile under the app's data dir
    base = QStandardPaths.writableLocation(QStandardPaths.StandardLocation.AppDataLocation)
    storage_root = os.path.join(base, "webengine", "perchance")
    os.makedirs(storage_root, exist_ok=True)

    profile = QWebEngineProfile("perchance", self)
    # Persist everything to disk
    profile.setPersistentStoragePath(os.path.join(storage_root, "storage"))
    profile.setCachePath(os.path.join(storage_root, "cache"))
    profile.setHttpCacheType(QWebEngineProfile.HttpCacheType.DiskHttpCache)

    # Make cookies survive restarts (including session cookies)
    if hasattr(QWebEngineProfile, "PersistentCookiesPolicy"):
        profile.setPersistentCookiesPolicy(
            QWebEngineProfile.PersistentCookiesPolicy.ForcePersistentCookies
        )

    return profile
```

Key points:
- Uses `QStandardPaths` to find the appropriate application data location for the OS
- Creates a named profile (`"perchance"`) that persists between sessions
- `ForcePersistentCookies` ensures even session cookies are saved to disk

### Profile Assignment to Page

The profile is assigned to a `QWebEnginePage` which is then set on the `QWebEngineView`:

```python
self.profile = self._create_persistent_profile()
self.page = QWebEnginePage(self.profile, self.webview)
self.webview.setPage(self.page)
```

### Loading URLs

URL loading is handled through a simple method that wraps `setUrl`:

```python
def load_url(self, url: str):
    """
    Load the specified URL in the QWebEngineView if available.

    Args:
        url: The URL to load as a string.
    """
    if self.webview:
        from PyQt6.QtCore import QUrl
        self.webview.setUrl(QUrl(url))
```

### Lazy Loading Pattern

The iframe is created lazily in the layout manager - only instantiated when first needed:

```python
# Create and add PerchanceIframe if not exists
if not self.perchance_iframe:
    from gui.widgets.perchance_iframe import PerchanceIframe
    self.perchance_iframe = PerchanceIframe(
        file_storage_service=self.file_storage_service,
        config_manager=self.config_manager
    )
    # Load URL only when creating the iframe
    self.perchance_iframe.load_url(self.config_manager.get_perchance_iframe_url())
```

---

## Adblocker

The adblocker implementation uses a two-layer approach:

1. **Request Interception** - Blocks network requests to ad domains before they execute
2. **DOM Element Hiding** - Hides ad containers after the page loads

### Layer 1: Request Interception

The project implements `QWebEngineUrlRequestInterceptor` to block requests at the network level:

```python
try:
    from PyQt6.QtWebEngineCore import QWebEngineUrlRequestInterceptor
except ImportError:
    QWebEngineUrlRequestInterceptor = None


class AdBlockInterceptor(QWebEngineUrlRequestInterceptor if QWebEngineUrlRequestInterceptor else object):
    """
    Intercepts web requests to block ad-related domains and scripts.
    """

    def __init__(self, blocked_domains):
        """
        Initialize the interceptor with blocked domains.

        Args:
            blocked_domains: List of domain strings to block
        """
        if QWebEngineUrlRequestInterceptor:
            super().__init__()
        self.blocked_domains = blocked_domains

    def interceptRequest(self, info):
        """
        Intercept and potentially block web requests.

        Args:
            info: QWebEngineUrlRequestInfo object
        """
        url = info.requestUrl().toString()
        for domain in self.blocked_domains:
            if domain in url:
                info.block(True)
                print(f"AdBlock: Blocked request to {url}")
                return
```

Key implementation details:
- The class inherits from `object` when `QWebEngineUrlRequestInterceptor` is unavailable, allowing graceful degradation
- Domain matching uses simple substring matching (`if domain in url`)
- Blocking is done via `info.block(True)`

### Blocked Domains Configuration

Blocked domains are stored in the configuration and loaded at runtime:

```python
# Default blocked domains (from ConfigManager._set_defaults)
self.adblocker_blocked_domains = [
    "a.pub.network",
    "d.pub.network",
    "cdn.snigelweb.com",
    "googletagmanager.com",
    "cloudflareinsights.com",
    "static.criteo.net",
    "secure.quantserve.com",
    "fundingchoicesmessages.google.com"
]
```

The configuration is retrieved and applied when creating the profile:

```python
if self.config_manager and QWebEngineUrlRequestInterceptor:
    blocked_domains = self.config_manager.get_adblocker_blocked_domains()
    if blocked_domains:
        interceptor = AdBlockInterceptor(blocked_domains)
        profile.setUrlRequestInterceptor(interceptor)
```

### Layer 2: DOM Element Hiding

Some ad elements may still render even when network requests are blocked. The project uses JavaScript injection to hide these elements:

```python
def _on_load_finished(self, ok):
    """
    Handle page load finished event to inject ad-hiding scripts.
    """
    if not ok or not self.config_manager:
        return

    hidden_selectors = self.config_manager.get_adblocker_hidden_selectors()
    if not hidden_selectors:
        return

    # Create JavaScript to hide ad elements
    selectors_js = ', '.join(f'"{selector}"' for selector in hidden_selectors)
    script = f"""
    (function() {{
        const selectors = [{selectors_js}];

        function hideElements() {{
            selectors.forEach(selector => {{
                const elements = document.querySelectorAll(selector);
                elements.forEach(el => {{
                    el.style.display = 'none !important';
                    el.style.visibility = 'hidden !important';
                    el.style.position = 'absolute';
                    el.style.left = '-9999px';
                }});
            }});
        }}

        // Hide immediately
        hideElements();

        // Hide after delay for dynamic content
        setTimeout(hideElements, 1000);
        setTimeout(hideElements, 3000);

        // Set up mutation observer for dynamically added elements
        const observer = new MutationObserver((mutations) => {{
            mutations.forEach((mutation) => {{
                mutation.addedNodes.forEach((node) => {{
                    if (node.nodeType === 1) {{ // Element node
                        selectors.forEach(selector => {{
                            if (node.matches && node.matches(selector)) {{
                                node.style.display = 'none !important';
                                node.style.visibility = 'hidden !important';
                                node.style.position = 'absolute';
                                node.style.left = '-9999px';
                            }}
                            const childElements = node.querySelectorAll ? node.querySelectorAll(selector) : [];
                            childElements.forEach(el => {{
                                el.style.display = 'none !important';
                                el.style.visibility = 'hidden !important';
                                el.style.position = 'absolute';
                                el.style.left = '-9999px';
                            }});
                        }});
                    }}
                }});
            }});
        }});

        observer.observe(document.body, {{
            childList: true,
            subtree: true
        }});
    }})();
    """

    # Run the script in the page
    self.webview.page().runJavaScript(script)
```

The JavaScript strategy includes:

1. **Immediate execution** - Hides elements as soon as the script runs
2. **Delayed execution** - Runs again after 1 and 3 seconds to catch dynamically loaded content
3. **MutationObserver** - Continuously watches for new DOM elements and hides matching ones

### Hidden Selectors Configuration

CSS selectors for ad elements are configurable:

```python
# Default hidden selectors (from ConfigManager._set_defaults)
self.adblocker_hidden_selectors = [
    ".ad-providers-ctn-el",
    "#adCtn",
    "#pmLink"
]
```

### Signal Connection for Load Events

The JavaScript injection is triggered by connecting to the `loadFinished` signal:

```python
if self.webview:
    self.webview.loadFinished.connect(self._on_load_finished)
```

---

## Download Handling

The implementation also handles image downloads from the Perchance page:

```python
def _on_download_requested(self, download: 'QWebEngineDownloadRequest'):
    """
    Handle download requests from the web view.
    Only accepts image downloads and saves them to the images/ directory.
    """
    if not self.file_storage_service:
        return

    try:
        from PyQt6.QtWebEngineCore import QWebEngineDownloadRequest

        # Check if this is an image download
        mime_type = (download.mimeType() or "").lower()
        filename = (download.downloadFileName() or "").lower()
        is_image = (
            mime_type.startswith("image/") or
            filename.endswith((".png", ".jpg", ".jpeg", ".webp", ".gif", ".svg"))
        )

        if not is_image:
            # Ignore non-image downloads
            return

        # Get the images directory path
        images_dir = self.file_storage_service.get_images_directory()

        # Use the provided filename with timestamp prefix
        if download.downloadFileName():
            timestamp = int(time.time())
            final_filename = f"{timestamp}_{download.downloadFileName()}"
        else:
            timestamp = int(time.time() * 1000)
            final_filename = f"perchance_{timestamp}.png"

        # Set download directory and filename
        download.setDownloadDirectory(str(images_dir))
        download.setDownloadFileName(final_filename)

        # Accept the download
        download.accept()

    except Exception as e:
        print(f"Error handling download request: {e}")
```

Downloads are connected through the profile:

```python
if self.file_storage_service:
    profile.downloadRequested.connect(self._on_download_requested)
```

---

## Configuration Schema

The adblocker settings are stored in `gui_config.json`:

```json
{
    "adblocker": {
        "blocked_domains": [
            "a.pub.network",
            "d.pub.network",
            "cdn.snigelweb.com",
            "googletagmanager.com",
            "cloudflareinsights.com",
            "static.criteo.net",
            "secure.quantserve.com",
            "fundingchoicesmessages.google.com"
        ],
        "hidden_selectors": [
            ".ad-providers-ctn-el",
            "#adCtn",
            "#pmLink"
        ]
    }
}
```

---

## Checking WebEngine Availability

A static method provides a way to check if WebEngine is available before attempting to use it:

```python
@staticmethod
def is_perchance_available():
    """
    Check if PyQt6 WebEngine is available for Perchance integration.

    Returns:
        bool: True if WebEngine is available
    """
    try:
        import PyQt6.QtWebEngineWidgets
        return True
    except ImportError:
        return False
```

---

## Summary

This implementation achieved the following:

- **Persistent login state** through named profiles with disk-based storage
- **Network-level ad blocking** through URL request interception
- **DOM-level ad hiding** through JavaScript injection with MutationObserver
- **Graceful degradation** when WebEngine is unavailable
- **Configurable blocking rules** stored in JSON configuration
- **Image download handling** with automatic file naming

### PROJECT 

A sophisticated desktop application that enhances image generation prompts using AI models and provides seamless integration with various image generation APIs with a modern PyQt6 GUI.

### DELIVERABLES

Please output a brief summary including any design choices, and the updated or new files where applicable. You may create new services or modules. If only small changes to existing files are required, please output them in

SEARCH: 

```
...stuff...
``` 

REPLACE:

```
...stuff...
``` 

style blocks.

### CONTEXT

## ðŸŽ¯ Focused Context (Agent-Selected)

**Project Root:** `image-prompter/`
**Files Included:** 8

---

### File Index

1. `gui/widgets/media_panel.py`
2. `core/config.py`
3. `gui/widgets/pollinations_page.py`
4. `core/utils.py`
5. `gui/widgets/image_gen_common.py`
6. `app/controller.py`
7. `gui/main_window.py`
8. `app/main.py`

---

### `gui/widgets/media_panel.py`

```python
# gui/widgets/media_panel.py
"""
Media Panel - Secondary pane for generative imaging interfacing.
Provides tabbed navigation for different image generation APIs.
"""

from PyQt6.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, QPushButton,
    QStackedWidget, QLabel, QSizePolicy
)
from PyQt6.QtCore import Qt, pyqtSignal
from PyQt6.QtGui import QCursor
from gui.widgets.pollinations_page import PollinationsPage
from gui.widgets.airforce_page import AirforcePage


class MediaPanel(QWidget):
    """Secondary pane with tabbed navigation for image generation API interfaces."""

    status_updated = pyqtSignal(str)

    TAB_NAMES = ["Gallery", "Pollinations", "Airforce", "Perchance"]

    ACTIVE_BG = "#1E88E5"
    ACTIVE_HOVER = "#2A9BF8"
    INACTIVE_BG = "#2a2a2a"
    INACTIVE_HOVER = "#3d3d3d"

    _TAB_ICONS = {"Gallery": "ðŸ–¼ï¸", "Pollinations": "ðŸŒ¸", "Airforce": "âœˆï¸", "Perchance": "ðŸŽ²"}
    _TAB_DESCS = {
        "Gallery": "Generated images will appear here",
        "Pollinations": "Pollinations AI image generation",
        "Airforce": "Airforce image generation API",
        "Perchance": "Perchance image generation",
    }

    def __init__(self, config_manager=None, parent=None):
        super().__init__(parent)
        self.config_manager = config_manager
        self.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Expanding)
        self._current_tab = 0
        self._tabs = []
        self._build_ui()
        self._load_active_tab()

    def _build_ui(self):
        layout = QVBoxLayout(self)
        layout.setContentsMargins(0, 0, 0, 0)
        layout.setSpacing(0)

        # --- Tab bar ---
        tab_bar = QWidget()
        tab_bar.setFixedHeight(34)
        tab_bar.setStyleSheet("background-color: #1a1a1a;")
        tab_layout = QHBoxLayout(tab_bar)
        tab_layout.setContentsMargins(0, 0, 0, 0)
        tab_layout.setSpacing(1)

        for i, name in enumerate(self.TAB_NAMES):
            btn = QPushButton(name)
            btn.setCursor(QCursor(Qt.CursorShape.PointingHandCursor))
            btn.setFocusPolicy(Qt.FocusPolicy.NoFocus)
            btn.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Expanding)
            btn.clicked.connect(lambda _, idx=i: self._switch_tab(idx))
            self._tabs.append(btn)
            tab_layout.addWidget(btn)

        layout.addWidget(tab_bar)

        # --- Stacked content area ---
        self._stack = QStackedWidget()
        self._stack.setStyleSheet("background-color: #2a2a2a; border: 1px solid #333;")

        for name in self.TAB_NAMES:
            if name == "Pollinations":
                self.pollinations_page = PollinationsPage(self.config_manager)
                self.pollinations_page.status_updated.connect(self.status_updated.emit)
                self._stack.addWidget(self.pollinations_page)
            elif name == "Airforce":
                self.airforce_page = AirforcePage(self.config_manager)
                self.airforce_page.status_updated.connect(self.status_updated.emit)
                self._stack.addWidget(self.airforce_page)
            else:
                self._stack.addWidget(self._create_page(name))

        layout.addWidget(self._stack, 1)
        self._update_tab_styles()

    def _create_page(self, name: str) -> QWidget:
        """Create a placeholder page for a tab."""
        page = QWidget()
        page_layout = QVBoxLayout(page)
        page_layout.setAlignment(Qt.AlignmentFlag.AlignCenter)

        icon = QLabel(self._TAB_ICONS.get(name, "ðŸ“„"))
        icon.setStyleSheet("font-size: 32pt;")
        icon.setAlignment(Qt.AlignmentFlag.AlignCenter)
        page_layout.addWidget(icon)

        title = QLabel(name)
        title.setStyleSheet("color: #666; font-size: 14pt; font-weight: bold;")
        title.setAlignment(Qt.AlignmentFlag.AlignCenter)
        page_layout.addWidget(title)

        desc = QLabel(self._TAB_DESCS.get(name, ""))
        desc.setStyleSheet("color: #444; font-size: 9pt;")
        desc.setAlignment(Qt.AlignmentFlag.AlignCenter)
        desc.setWordWrap(True)
        page_layout.addWidget(desc)

        return page

    def _switch_tab(self, index: int):
        """Switch to the specified tab index."""
        if index == self._current_tab:
            return
        self._current_tab = index
        self._stack.setCurrentIndex(index)
        self._update_tab_styles()
        if self.config_manager:
            self.config_manager.media_active_tab = index
            self.config_manager.save()

    def _load_active_tab(self):
        """Restore the last active tab from config."""
        if self.config_manager:
            tab = getattr(self.config_manager, 'media_active_tab', 0)
            if 0 <= tab < len(self.TAB_NAMES):
                self._current_tab = tab
                self._stack.setCurrentIndex(tab)
                self._update_tab_styles()

    def _update_tab_styles(self):
        """Update tab button visual styles based on active selection."""
        for i, btn in enumerate(self._tabs):
            if i == self._current_tab:
                btn.setStyleSheet(f"""
                    QPushButton {{
                        background-color: {self.ACTIVE_BG};
                        color: #ffffff;
                        font-weight: bold;
                        font-size: 9pt;
                        border: none;
                        border-radius: 0px;
                        padding: 4px 8px;
                    }}
                    QPushButton:hover {{
                        background-color: {self.ACTIVE_HOVER};
                    }}
                """)
            else:
                btn.setStyleSheet(f"""
                    QPushButton {{
                        background-color: {self.INACTIVE_BG};
                        color: #888;
                        font-size: 9pt;
                        border: none;
                        border-radius: 0px;
                        padding: 4px 8px;
                    }}
                    QPushButton:hover {{
                        background-color: {self.INACTIVE_HOVER};
                        color: #fff;
                    }}
                """)
```

### `core/config.py`

```python
"""Configuration Manager for PyQt6 GUI Framework."""
import os
import json

_DEFAULTS = {
    "window_width": 1200,
    "window_height": 800,
    "theme": "dark",
    "current_service": "Gemini",
    "current_model": "Flash",
    "default_system_prompt": "You are a helpful AI assistant.",
    "splitter_sizes": [780, 420],
    "media_active_tab": 0,
    "pollinations_positive_prompt": "",
    "pollinations_negative_prompt": "",
    "pollinations_model": "zimage",
    "pollinations_size": "1024x1024",
    "pollinations_seed": -1,
    "pollinations_last_image": "",
    "airforce_positive_prompt": "",
    "airforce_negative_prompt": "",
    "airforce_model": "grok-imagine",
    "airforce_size": "1024x1024",
    "airforce_seed": -1,
    "airforce_last_image": "",
    "display_fields": {
        "core": True,
        "composition": True,
        "lighting": True,
        "style": True,
        "technical": True,
        "post_processing": True,
        "special_elements": True,
        "detailed_prompt": True,
        "grok_imagine_optimized": True,
        "gemini_optimized": True,
        "flux_optimized": True,
        "stable_diffusion_optimized": True,
        "video_optimized": True
    }
}

class ConfigManager:
    """Manages GUI configuration values and local gui_config.json persistence."""

    def __init__(self, config_file: str = "gui_config.json"):
        self.config_file = config_file
        self.__dict__.update(_DEFAULTS)
        self._load_config()

    def _load_config(self) -> None:
        if not os.path.exists(self.config_file):
            return
        try:
            with open(self.config_file, 'r') as f:
                config = json.load(f)
                for k in _DEFAULTS:
                    val = config.get(k, getattr(self, k))
                    if isinstance(val, dict) and isinstance(_DEFAULTS[k], dict):
                        merged = _DEFAULTS[k].copy()
                        merged.update(val)
                        setattr(self, k, merged)
                    else:
                        setattr(self, k, val)
                if "default_service" in config and "current_service" not in config:
                    self.current_service = config["default_service"]
                if "service_models" in config and "current_model" not in config:
                    self.current_model = config.get("service_models", {}).get(self.current_service, self.current_model)
        except Exception:
            pass

    def save(self) -> None:
        try:
            with open(self.config_file, 'w') as f:
                json.dump({k: getattr(self, k) for k in _DEFAULTS}, f, indent=2)
        except Exception:
            pass
```

### `gui/widgets/pollinations_page.py`

```python
# gui/widgets/pollinations_page.py
"""
Pollinations Page - Image generation interface for the Pollinations AI API.
Provides controls for prompt, model, size, seed and displays generated images.
"""

from PyQt6.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, QPushButton, QLineEdit
)
from PyQt6.QtCore import pyqtSignal, Qt, QTimer, QEvent
from PyQt6.QtGui import QCursor

import os

from gui.widgets.image_gen_common import (
    ImageDisplay, INPUT_STYLE, BTN_GENERATE, BTN_CANCEL,
    BTN_DROPDOWN, make_dropdown,
)
from core.services.pollinations_service import PollinationsService
from core.utils import reveal_file_in_explorer


class PollinationsPage(QWidget):
    """Pollinations AI image generation page with controls and image display."""

    status_updated = pyqtSignal(str)

    MODELS = ["flux", "zimage", "klein", "klein-large", "gptimage"]
    SIZES = ["1024x1024", "1344x768", "768x1344"]
    DEFAULT_MODEL = "zimage"
    DEFAULT_SIZE = "1024x1024"
    DEFAULT_SEED = -1

    def __init__(self, config_manager=None, parent=None):
        super().__init__(parent)
        self.config_manager = config_manager
        self.current_model = self.DEFAULT_MODEL
        self.current_size = self.DEFAULT_SIZE
        self._is_generating = False
        self._current_image_path = ""

        self.active_dropdown = None
        self.hide_timer = QTimer()
        self.hide_timer.setInterval(250)
        self.hide_timer.timeout.connect(self._hide_dropdown)

        self.service = PollinationsService()
        self.service.image_generated.connect(self._on_image_generated)
        self.service.error_occurred.connect(self._on_error)
        self.service.status_updated.connect(self.status_updated.emit)

        self._build_ui()
        self._load_from_config()

    def _build_ui(self):
        layout = QVBoxLayout(self)
        layout.setContentsMargins(0, 0, 0, 0)
        layout.setSpacing(0)

        # --- Controls bar ---
        controls = QWidget()
        controls.setStyleSheet("background-color: #121212;")
        cl = QHBoxLayout(controls)
        cl.setContentsMargins(4, 4, 4, 4)
        cl.setSpacing(6)

        self.generate_btn = QPushButton("Generate")
        self.generate_btn.setStyleSheet(BTN_GENERATE)
        self.generate_btn.setCursor(QCursor(Qt.CursorShape.PointingHandCursor))
        self.generate_btn.setFocusPolicy(Qt.FocusPolicy.NoFocus)
        self.generate_btn.clicked.connect(self._on_generate_clicked)
        cl.addWidget(self.generate_btn)

        self.positive_input = QLineEdit()
        self.positive_input.setPlaceholderText("Positive Prompt...")
        self.positive_input.setStyleSheet(INPUT_STYLE)
        self.positive_input.returnPressed.connect(self._on_generate_clicked)
        cl.addWidget(self.positive_input, stretch=2)

        self.negative_input = QLineEdit()
        self.negative_input.setPlaceholderText("Negative Prompt...")
        self.negative_input.setStyleSheet(INPUT_STYLE)
        self.negative_input.returnPressed.connect(self._on_generate_clicked)
        cl.addWidget(self.negative_input, stretch=1)

        self.model_btn = QPushButton(self.current_model)
        self.model_btn.setStyleSheet(BTN_DROPDOWN)
        self.model_btn.setCursor(QCursor(Qt.CursorShape.PointingHandCursor))
        self.model_btn.setFocusPolicy(Qt.FocusPolicy.NoFocus)
        self.model_btn.setMinimumWidth(90)
        self.model_btn.installEventFilter(self)
        cl.addWidget(self.model_btn)

        self.size_btn = QPushButton(self.current_size)
        self.size_btn.setStyleSheet(BTN_DROPDOWN)
        self.size_btn.setCursor(QCursor(Qt.CursorShape.PointingHandCursor))
        self.size_btn.setFocusPolicy(Qt.FocusPolicy.NoFocus)
        self.size_btn.setMinimumWidth(90)
        self.size_btn.installEventFilter(self)
        cl.addWidget(self.size_btn)

        self.seed_input = QLineEdit(str(self.DEFAULT_SEED))
        self.seed_input.setStyleSheet(INPUT_STYLE)
        self.seed_input.setFixedWidth(64)
        self.seed_input.setAlignment(Qt.AlignmentFlag.AlignCenter)
        self.seed_input.setToolTip("Seed (-1 for random)")
        self.seed_input.returnPressed.connect(self._on_generate_clicked)
        cl.addWidget(self.seed_input)

        layout.addWidget(controls)

        # --- Image display ---
        self.image_display = ImageDisplay()
        self.image_display.clicked.connect(self._on_image_clicked)
        layout.addWidget(self.image_display, 1)

        # --- Dropdowns ---
        self.model_dropdown = make_dropdown(
            self, self.MODELS, self._on_model_selected, self
        )
        self.size_dropdown = make_dropdown(
            self, self.SIZES, self._on_size_selected, self
        )

    # ---------------------------------------------------------------- Dropdowns

    def eventFilter(self, obj, event):
        et = event.type()
        if et == QEvent.Type.Enter:
            if obj == self.model_btn:
                self._show_dropdown(self.model_dropdown, self.model_btn)
            elif obj == self.size_btn:
                self._show_dropdown(self.size_dropdown, self.size_btn)
            elif obj in (self.model_dropdown, self.size_dropdown):
                self.hide_timer.stop()
        elif et == QEvent.Type.Leave:
            if obj in (self.model_btn, self.size_btn,
                       self.model_dropdown, self.size_dropdown):
                self.hide_timer.start()
        return super().eventFilter(obj, event)

    def _show_dropdown(self, dropdown, button):
        if self._is_generating:
            return
        self.hide_timer.stop()
        if self.active_dropdown and self.active_dropdown is not dropdown:
            self.active_dropdown.hide()
        if self.active_dropdown is dropdown:
            return
        self.active_dropdown = dropdown
        pos = button.mapToGlobal(button.rect().bottomLeft())
        dropdown.move(pos.x(), pos.y() + 2)
        dropdown.show()
        dropdown.raise_()

    def _hide_dropdown(self):
        if self.active_dropdown:
            self.active_dropdown.hide()
            self.active_dropdown = None

    def _on_model_selected(self, model: str):
        self.current_model = model
        self.model_btn.setText(model)
        self._hide_dropdown()
        self._save_to_config()

    def _on_size_selected(self, size: str):
        self.current_size = size
        self.size_btn.setText(size)
        self._hide_dropdown()
        self._save_to_config()

    # ------------------------------------------------------------ Generation

    def _on_generate_clicked(self):
        if self._is_generating:
            self.service.cancel_generation()
            self._set_generating(False)
            self.status_updated.emit("Generation cancelled.")
            return

        prompt = self.positive_input.text().strip()
        if not prompt:
            self.status_updated.emit("Error: Positive prompt cannot be empty.")
            return

        try:
            seed = int(self.seed_input.text().strip())
        except ValueError:
            seed = -1

        w, h = self.current_size.split("x")
        self._set_generating(True)
        self._save_to_config()
        self.service.generate_image(
            prompt=prompt,
            negative_prompt=self.negative_input.text().strip(),
            model=self.current_model,
            width=int(w),
            height=int(h),
            seed=seed,
        )

    def _on_image_generated(self, filepath: str):
        self._set_generating(False)
        self._current_image_path = filepath
        self.image_display.set_image(filepath)
        self._save_to_config()

    def _on_error(self, _error_msg: str):
        self._set_generating(False)

    def _set_generating(self, state: bool):
        self._is_generating = state
        self.positive_input.setEnabled(not state)
        self.negative_input.setEnabled(not state)
        self.model_btn.setEnabled(not state)
        self.size_btn.setEnabled(not state)
        self.seed_input.setEnabled(not state)

        if state:
            self._hide_dropdown()
            self.generate_btn.setText("Cancel")
            self.generate_btn.setStyleSheet(BTN_CANCEL)
        else:
            self.generate_btn.setText("Generate")
            self.generate_btn.setStyleSheet(BTN_GENERATE)

    def hideEvent(self, event):
        """Close dropdowns when page is hidden (tab switch)."""
        self._hide_dropdown()
        super().hideEvent(event)

    def _on_image_clicked(self):
        """Open file explorer and select the current image."""
        if self._current_image_path and os.path.isfile(self._current_image_path):
            reveal_file_in_explorer(self._current_image_path)
        else:
            self.status_updated.emit("Image file not found on disk.")

    def _save_to_config(self):
        """Persist current Pollinations settings to config."""
        if not self.config_manager:
            return
        self.config_manager.pollinations_positive_prompt = self.positive_input.text()
        self.config_manager.pollinations_negative_prompt = self.negative_input.text()
        self.config_manager.pollinations_model = self.current_model
        self.config_manager.pollinations_size = self.current_size
        try:
            self.config_manager.pollinations_seed = int(self.seed_input.text())
        except ValueError:
            self.config_manager.pollinations_seed = self.DEFAULT_SEED
        self.config_manager.pollinations_last_image = self._current_image_path
        self.config_manager.save()

    def _load_from_config(self):
        """Load persisted Pollinations settings from config."""
        if not self.config_manager:
            return

        self.positive_input.setText(
            getattr(self.config_manager, 'pollinations_positive_prompt', ''))
        self.negative_input.setText(
            getattr(self.config_manager, 'pollinations_negative_prompt', ''))

        model = getattr(self.config_manager, 'pollinations_model', self.DEFAULT_MODEL)
        if model in self.MODELS:
            self.current_model = model
            self.model_btn.setText(model)

        size = getattr(self.config_manager, 'pollinations_size', self.DEFAULT_SIZE)
        if size in self.SIZES:
            self.current_size = size
            self.size_btn.setText(size)

        seed = getattr(self.config_manager, 'pollinations_seed', self.DEFAULT_SEED)
        self.seed_input.setText(str(seed))

        last_image = getattr(self.config_manager, 'pollinations_last_image', '')
        if last_image and os.path.isfile(last_image):
            self._current_image_path = last_image
            self.image_display.set_image(last_image)
```

### `core/utils.py`

```python
# core/utils.py
"""Shared utility functions for the application."""

import os
import sys
import subprocess
from datetime import datetime
from pathlib import Path


def reveal_file_in_explorer(filepath: str) -> bool:
    """
    Open the system file explorer and select/highlight the given file.

    Platform behavior:
        Windows: explorer /select,<path>
        macOS:   open -R <path>
        Linux:   xdg-open <parent directory>

    Returns True if the command was launched, False on error or missing file.
    """
    filepath = os.path.normpath(os.path.abspath(filepath))
    if not os.path.exists(filepath):
        return False
    try:
        if sys.platform == "win32":
            subprocess.Popen(["explorer", f"/select,{filepath}"])
        elif sys.platform == "darwin":
            subprocess.Popen(["open", "-R", filepath])
        else:
            subprocess.Popen(["xdg-open", os.path.dirname(filepath)])
        return True
    except Exception:
        return False


def open_file(filepath: str) -> bool:
    """
    Open a file with the system's default application.

    Returns True if the command was launched, False on error or missing file.
    """
    filepath = os.path.normpath(os.path.abspath(filepath))
    if not os.path.exists(filepath):
        return False
    try:
        if sys.platform == "win32":
            os.startfile(filepath)
        elif sys.platform == "darwin":
            subprocess.Popen(["open", filepath])
        else:
            subprocess.Popen(["xdg-open", filepath])
        return True
    except Exception:
        return False


def save_generated_image(
    image_data: bytes,
    prompt: str,
    negative_prompt: str,
    model: str,
    size: str,
    seed: int,
    service: str,
) -> str:
    """Save generated image to the images/ directory with embedded EXIF metadata.

    Uses a timestamp-based filename (``YYYY-MM-DD_HH-MM-SS.jpg``) and embeds
    prompt / generation metadata into the EXIF ImageDescription tag when
    Pillow is available.

    Args:
        image_data:      Raw image bytes (any format Pillow can open).
        prompt:          Positive prompt text.
        negative_prompt: Negative prompt text (may be empty).
        model:           Model identifier string.
        size:            Size string, e.g. ``"1024x1024"``.
        seed:            Seed value used for generation.
        service:         Service name (e.g. ``"Pollinations"``, ``"Airforce"``).

    Returns:
        The absolute-ish path to the saved file as a string.
    """
    images_dir = Path("images")
    images_dir.mkdir(exist_ok=True)

    timestamp = datetime.now().strftime("%Y-%m-%d_%H-%M-%S")
    filepath = images_dir / f"{timestamp}.jpg"
    counter = 1
    while filepath.exists():
        filepath = images_dir / f"{timestamp}_{counter}.jpg"
        counter += 1

    metadata_str = (
        f"Prompt: {prompt} | "
        f"Negative: {negative_prompt or 'None'} | "
        f"Model: {model} | "
        f"Size: {size} | "
        f"Seed: {seed} | "
        f"Service: {service}"
    )

    saved_with_meta = False
    try:
        from PIL import Image
        import io

        img = Image.open(io.BytesIO(image_data))
        if img.mode in ("RGBA", "P", "LA"):
            img = img.convert("RGB")

        exif = img.getexif()
        exif[0x010E] = metadata_str        # ImageDescription
        exif[0x0131] = f"{service} AI"     # Software
        img.save(str(filepath), "JPEG", quality=95, exif=exif.tobytes())
        saved_with_meta = True
    except Exception:
        pass

    if not saved_with_meta:
        with open(filepath, "wb") as f:
            f.write(image_data)

    return str(filepath)
```

### `gui/widgets/image_gen_common.py`

```python
# gui/widgets/image_gen_common.py
"""
Shared components for image generation pages.
Provides ImageDisplay widget, UI style constants, and dropdown factory.
"""

from PyQt6.QtWidgets import QLabel, QSizePolicy, QWidget, QVBoxLayout, QPushButton
from PyQt6.QtCore import pyqtSignal, Qt
from PyQt6.QtGui import QCursor, QPixmap


# â”€â”€ Shared style constants â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

INPUT_STYLE = (
    "QLineEdit {"
    "  background-color: #1e1e1e; color: #eee;"
    "  border: 1px solid #333; border-radius: 3px;"
    "  font-size: 12px; padding: 6px;"
    "}"
    "QLineEdit:disabled { color: #666; }"
)

BTN_GENERATE = (
    "QPushButton {"
    "  background-color: #1E88E5; color: #fff; font-weight: bold;"
    "  border: 1px solid #1E88E5; border-radius: 3px;"
    "  font-size: 12px; padding: 6px 12px;"
    "}"
    "QPushButton:hover { background-color: #2A9BF8; border-color: #2A9BF8; }"
    "QPushButton:pressed { background-color: #1966C2; border-color: #1966C2; }"
)

BTN_CANCEL = (
    "QPushButton {"
    "  background-color: #F44336; color: #fff; font-weight: bold;"
    "  border: 1px solid #F44336; border-radius: 3px;"
    "  font-size: 12px; padding: 6px 12px;"
    "}"
    "QPushButton:hover { background-color: #EF5350; border-color: #EF5350; }"
    "QPushButton:pressed { background-color: #D32F2F; border-color: #D32F2F; }"
)

BTN_DROPDOWN = (
    "QPushButton {"
    "  background-color: #1e1e1e; color: #eee;"
    "  border: 1px solid #333; border-radius: 3px;"
    "  font-size: 12px; padding: 6px 8px;"
    "}"
    "QPushButton:hover { background-color: #2a2a2a; border-color: #555; }"
    "QPushButton:disabled { color: #666; }"
)

DROPDOWN_OPTION = (
    "QPushButton {"
    "  background-color: transparent; color: #eee; border: none;"
    "  text-align: left; padding: 6px 12px; font-size: 12px;"
    "}"
    "QPushButton:hover { background-color: #2a2a2a; }"
)

DROPDOWN_CONTAINER = (
    "QWidget { background-color: #1e1e1e; border: 1px solid #333; border-radius: 3px; }"
)


# â”€â”€ Shared widgets â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

class ImageDisplay(QLabel):
    """Custom label that displays an image fully contained, never cropped."""

    clicked = pyqtSignal()

    def __init__(self, parent=None):
        super().__init__(parent)
        self._pixmap = None
        self.setAlignment(Qt.AlignmentFlag.AlignCenter)
        self.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Expanding)
        self.setMinimumSize(64, 64)
        self.setStyleSheet("background-color: #121212; border: none;")

    def set_image(self, filepath: str):
        """Load and display an image from file path."""
        self._pixmap = QPixmap(filepath)
        self._update_display()
        self.setCursor(QCursor(Qt.CursorShape.PointingHandCursor))

    def clear_image(self):
        self._pixmap = None
        self.clear()
        self.setCursor(QCursor(Qt.CursorShape.ArrowCursor))

    def mousePressEvent(self, event):
        if event.button() == Qt.MouseButton.LeftButton and self._pixmap:
            self.clicked.emit()
        super().mousePressEvent(event)

    def _update_display(self):
        if self._pixmap and not self._pixmap.isNull():
            scaled = self._pixmap.scaled(
                self.size(),
                Qt.AspectRatioMode.KeepAspectRatio,
                Qt.TransformationMode.SmoothTransformation,
            )
            self.setPixmap(scaled)

    def resizeEvent(self, event):
        super().resizeEvent(event)
        self._update_display()


# â”€â”€ Shared helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

def make_dropdown(parent_widget, options: list, callback, event_filter_obj) -> QWidget:
    """Create a hover-activated dropdown widget with the given options.

    Args:
        parent_widget:    Widget whose window() is used as the dropdown parent.
        options:          List of string labels for the dropdown items.
        callback:         Called with the selected option string on click.
        event_filter_obj: QObject that will receive Enter/Leave events on the dropdown.
    """
    dd = QWidget(parent_widget.window() or None)
    dd.setWindowFlags(Qt.WindowType.FramelessWindowHint | Qt.WindowType.Tool)
    dd.setAttribute(Qt.WidgetAttribute.WA_ShowWithoutActivating)
    dd.setStyleSheet(DROPDOWN_CONTAINER)
    lo = QVBoxLayout(dd)
    lo.setContentsMargins(2, 2, 2, 2)
    lo.setSpacing(1)

    for opt in options:
        btn = QPushButton(opt)
        btn.setStyleSheet(DROPDOWN_OPTION)
        btn.setCursor(QCursor(Qt.CursorShape.PointingHandCursor))
        btn.clicked.connect(lambda _, o=opt: callback(o))
        lo.addWidget(btn)

    dd.adjustSize()
    dd.hide()
    dd.installEventFilter(event_filter_obj)
    return dd
```

### `app/controller.py`

```python
# app/controller.py
"""Application Controller - Orchestrates application logic and connects GUI to services."""
import sys
import base64
from pathlib import Path
from PyQt6.QtWidgets import QApplication, QMessageBox
from PyQt6.QtCore import pyqtSignal, QObject, QTimer

from gui.main_window import MainWindow
from core.config import ConfigManager
from core.prompt_manager import PromptManager
from core.services.file_service import FileService
from core.services.gemini_service import GeminiService
from core.services.nvidia_nim_service import NvidiaNimService
from core.services.chat_history_service import ChatHistoryService

DARK_MSGBOX_STYLE = """
    QMessageBox, QLabel { background-color: #1a1a1a; color: #ffffff; }
    QPushButton { background-color: #3d3d3d; color: #ffffff; border: 1px solid #333; padding: 8px; border-radius: 4px; }
    QPushButton:hover { background-color: #4d4d4d; }
"""


class ApplicationController(QObject):
    """Orchestrates the application logic, connecting GUI signals to backend services."""
    append_user_message_signal = pyqtSignal(str, object)
    clear_input_signal = pyqtSignal()
    clear_response_signal = pyqtSignal()

    def __init__(self, app: QApplication):
        super().__init__()
        self.app = app
        self.config_manager = ConfigManager()
        self.prompt_manager = PromptManager()

        self.file_service = FileService()
        self.services = {"Gemini": GeminiService(), "NVIDIA NIM": NvidiaNimService()}
        self.chat_history_service = ChatHistoryService()

        self.selected_service = getattr(self.config_manager, "current_service", "Gemini")
        self.selected_model = getattr(self.config_manager, "current_model", "Flash")

        self.main_window = MainWindow(self.file_service, self.config_manager)

        for service in self.services.values():
            service.response_generated.connect(self._handle_ai_response)
            service.status_updated.connect(self.main_window.status_signal.emit)
            service.chunk_received.connect(self._handle_stream_chunk)
            service.thinking_chunk_received.connect(self._handle_thinking_chunk)
            service.stream_complete.connect(self._handle_stream_complete)
            service.error_occurred.connect(self._handle_generation_error)

        self._is_streaming = False
        self._is_generating = False

        self.chat_history_service.chat_loaded.connect(self._handle_chat_loaded)
        self._connect_signals()
        self._initialize_ui()

    def handle_display_toggled(self, new_fields: dict):
        self.config_manager.display_fields = new_fields.copy()
        self.config_manager.save()
        self.main_window.response_panel.display_fields = new_fields.copy()
        
        # Re-render chat natively so UI instantly updates based on new toggles
        current_chat_id = self.chat_history_service.get_current_chat_id()
        if current_chat_id:
            chat_data = {"messages": self.chat_history_service.get_current_messages()}
            self._handle_chat_loaded(chat_data)

    def _connect_signals(self):
        abp = self.main_window.action_buttons_panel
        ip = self.main_window.input_panel

        # Media panel status â†’ main status bar
        self.main_window.media_panel.status_updated.connect(self.main_window.status_signal.emit)

        abp.select_file_signal.connect(self.handle_select_file)
        abp.send_signal.connect(self.handle_send)
        abp.display_toggled_signal.connect(self.handle_display_toggled)
        abp.interrupt_signal.connect(self.handle_interrupt)
        abp.service_model_selected_signal.connect(self.handle_service_model_selected)
        abp.new_chat_signal.connect(self.handle_new_chat)
        abp.delete_chat_signal.connect(self.handle_delete_chat)
        abp.delete_all_chats_signal.connect(self.handle_delete_all_chats)
        abp.navigate_left_signal.connect(self.handle_navigate_left)
        abp.navigate_right_signal.connect(self.handle_navigate_right)

        ip.send_signal.connect(self.handle_send)
        ip.navigate_left_signal.connect(self.handle_navigate_left)
        ip.navigate_right_signal.connect(self.handle_navigate_right)

        self.append_user_message_signal.connect(self.main_window.response_panel.append_user_message)
        self.clear_input_signal.connect(lambda: ip.set_input_text(""))
        self.clear_response_signal.connect(self.main_window.response_panel.clear)

    def _initialize_ui(self):
        self._update_service_model_button_label()
        
        # Init display fields explicitly
        if hasattr(self.config_manager, "display_fields"):
            self.main_window.action_buttons_panel.set_display_fields(self.config_manager.display_fields)
            self.main_window.response_panel.display_fields = self.config_manager.display_fields
            
        self.chat_history_service.create_new_chat()
        self._update_navigation_buttons()

    def run(self):
        self.main_window.resize(self.config_manager.window_width, self.config_manager.window_height)
        if hasattr(self.config_manager, 'splitter_sizes'):
            self.main_window.splitter.setSizes(self.config_manager.splitter_sizes)
        self.main_window.show()
        sys.exit(self.app.exec())

    # --- Action Handlers ---

    def handle_select_file(self, b64_data: str, filename: str):
        if not self.file_service.has_files():
            self.update_status("No files selected.")

    def handle_interrupt(self):
        if self._is_generating:
            self.update_status("Interrupting generation...")
            active_service = self._get_active_service()
            if hasattr(active_service, 'cancel_generation'):
                active_service.cancel_generation()

    def handle_send(self):
        user_input = self.get_input_text()
        if not user_input.strip() and not self.file_service.has_files():
            return self.update_status("Error: Input cannot be empty.")
        self._process_message(user_input)

    def handle_service_model_selected(self, service: str, model: str):
        self.selected_service = service
        self.selected_model = model
        self.config_manager.current_service = service
        self.config_manager.current_model = model
        self.config_manager.save()
        self._update_service_model_button_label()
        self.update_status(f"Selected: {service} - {model}")

    def handle_new_chat(self):
        if self._is_generating:
            return self.update_status("Cannot create a new chat while generating.")
        if self.chat_history_service.get_current_messages():
            self.chat_history_service.save_current_chat()
        self.chat_history_service.create_new_chat()
        self.clear_response_signal.emit()
        self.clear_input_signal.emit()
        self.update_status("New chat created.")
        self._update_navigation_buttons()

    def handle_delete_chat(self):
        if self._is_generating:
            return self.update_status("Cannot delete chat while generating.")
        current_chat_id = self.chat_history_service.get_current_chat_id()
        if not current_chat_id:
            return self.update_status("No chat to delete.")
        if not self._confirm_dialog("Delete Chat", "Are you sure you want to delete this chat?"):
            return

        if self.chat_history_service.delete_chat(current_chat_id):
            adjacent_id = (self.chat_history_service.get_adjacent_chat_id("left") or
                           self.chat_history_service.get_adjacent_chat_id("right"))
            if adjacent_id:
                self.chat_history_service.load_chat(adjacent_id)
                self.update_status(f"Chat deleted. Loaded chat: {adjacent_id}")
            else:
                self.chat_history_service.create_new_chat()
                self.clear_response_signal.emit()
                self.update_status("Chat deleted. New chat created.")
        else:
            self.update_status("Failed to delete chat.")
        self._update_navigation_buttons()

    def handle_delete_all_chats(self):
        if self._is_generating:
            return self.update_status("Cannot delete all chats while generating.")
        chat_files = self.chat_history_service.get_chat_files()
        if not chat_files:
            return self.update_status("No chats to delete.")
        if not self._confirm_dialog("Delete All Chats", f"Are you sure you want to delete all {len(chat_files)} chats?"):
            return

        if self.chat_history_service.delete_all_chats():
            self.chat_history_service.clear_current_chat()
            self.chat_history_service.create_new_chat()
            self.clear_response_signal.emit()
            self.update_status("All chats deleted. New chat created.")
        else:
            self.update_status("Failed to delete some chats.")
        self._update_navigation_buttons()

    def handle_navigate_left(self):
        self._handle_navigation("left")

    def handle_navigate_right(self):
        self._handle_navigation("right")

    # --- Internal Logic ---

    def _process_message(self, user_input: str):
        if self._is_generating:
            return self.update_status("Please wait for the current response to finish.")

        has_files = self.file_service.has_files()
        if not self.chat_history_service.get_current_chat_id():
            self.chat_history_service.create_new_chat()

        file_data_list, filenames_list = [], None
        if has_files:
            for file_b64, filename in self.file_service.get_files():
                file_data_list.append({
                    'base64': file_b64, 'filename': filename,
                    'mime_type': self._get_mime_type(filename),
                    'file_size': len(base64.b64decode(file_b64))
                })
            if file_data_list:
                filenames_list = [f['filename'] for f in file_data_list]

        display_text = user_input or (
            f"Process file{'s' if len(file_data_list) > 1 else ''}: {', '.join(filenames_list)}"
            if filenames_list else ""
        )

        self.append_user_message_signal.emit(display_text, filenames_list)
        self.chat_history_service.add_message("user", display_text, filenames_list)
        self.clear_input_signal.emit()

        active_service = self._get_active_service()
        self._set_generating_state(True)

        kwargs = {}
        if file_data_list:
            kwargs['files_data'] = file_data_list
            
        has_image = False
        if file_data_list:
            has_image = any(f['mime_type'].startswith('image/') for f in file_data_list)
            
        system_prompt = self.prompt_manager.get_prompt(self.selected_service, self.selected_model, has_image)

        active_service.generate_response(
            system_prompt, user_input,
            self.selected_model, self.chat_history_service.get_current_messages()[:-1], **kwargs
        )

        if has_files:
            self.file_service.clear_files()

    def _handle_ai_response(self, response_text: str):
        if not self._is_streaming:
            self.main_window.response_panel.append_assistant_message(response_text)
        self.chat_history_service.add_message("assistant", response_text)
        if chat_id := self.chat_history_service.save_current_chat():
            self.update_status(f"Chat saved: {chat_id}")
        self._is_streaming = False
        self._set_generating_state(False)

    def _handle_generation_error(self, error_message: str):
        self._set_generating_state(False)
        if self._is_streaming:
            self._is_streaming = False
            self.main_window.response_panel.end_stream()

    def _set_generating_state(self, state: bool):
        self._is_generating = state
        self.main_window.action_buttons_panel.set_generating_state(state)
        if not state:
            self._update_navigation_buttons()
            self.main_window.action_buttons_panel.update_text_action_buttons(bool(self.get_input_text().strip()))

    def _handle_stream_chunk(self, chunk: str):
        if not self._is_streaming:
            self._is_streaming = True
            self.main_window.response_panel.start_stream()
        self.main_window.response_panel.append_stream_chunk(chunk)

    def _handle_thinking_chunk(self, chunk: str):
        if not self._is_streaming:
            self._is_streaming = True
            self.main_window.response_panel.start_stream()
        self.main_window.response_panel.append_thinking_chunk(chunk)

    def _handle_stream_complete(self, full_response: str):
        self.main_window.response_panel.end_stream()

    def _handle_navigation(self, direction: str):
        if self._is_generating:
            return self.update_status("Cannot navigate while generating.")

        current_chat_id = self.chat_history_service.get_current_chat_id()
        if current_chat_id and self.chat_history_service.get_current_messages():
            chat_file = Path("chats") / f"{current_chat_id}.json"
            if not chat_file.exists():
                self.chat_history_service.save_current_chat()

        adjacent_id = self.chat_history_service.get_adjacent_chat_id(direction)
        if adjacent_id:
            if self.chat_history_service.load_chat(adjacent_id):
                self.update_status(f"Loaded chat: {adjacent_id}")
            else:
                self.update_status(f"Failed to load chat: {adjacent_id}")
        elif direction == "left":
            self.update_status("No previous chat.")
        else:
            self.handle_new_chat()
        self._update_navigation_buttons()

    def _handle_chat_loaded(self, chat_data: dict):
        self.main_window.response_panel.clear()
        for message in chat_data.get("messages", []):
            role = message.get("role", "")
            content = message.get("content", "")
            filenames = message.get("filenames") or ([message["filename"]] if message.get("filename") else None)

            if role == "user":
                self.append_user_message_signal.emit(content, filenames)
            elif role == "assistant":
                self.main_window.response_panel.append_assistant_message(content)

        self._update_navigation_buttons()
        QTimer.singleShot(0, self.main_window.response_panel.scroll_to_bottom)

    def _update_navigation_buttons(self):
        can_go_left = self.chat_history_service.get_adjacent_chat_id("left") is not None
        can_go_right = self.chat_history_service.get_adjacent_chat_id("right") is not None
        self.main_window.action_buttons_panel.update_navigation_buttons(can_go_left, can_go_right)

    def _update_service_model_button_label(self):
        self.main_window.action_buttons_panel.set_service_model_text(self.selected_service, self.selected_model)

    def _get_active_service(self):
        return self.services.get(self.selected_service, self.services["Gemini"])

    def _confirm_dialog(self, title: str, text: str) -> bool:
        """Show a dark-themed confirmation dialog. Returns True if user confirmed."""
        msg_box = QMessageBox(self.main_window)
        msg_box.setWindowTitle(title)
        msg_box.setText(text)
        msg_box.setStandardButtons(QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No)
        msg_box.setDefaultButton(QMessageBox.StandardButton.No)
        msg_box.setStyleSheet(DARK_MSGBOX_STYLE)
        return msg_box.exec() == QMessageBox.StandardButton.Yes

    def get_input_text(self) -> str:
        return self.main_window.get_input_text()

    def update_status(self, message: str):
        self.main_window.status_signal.emit(message)

    @staticmethod
    def _get_mime_type(filename: str) -> str:
        import mimetypes
        return mimetypes.guess_type(filename)[0] or "application/octet-stream"
```

### `gui/main_window.py`

```python
# gui/main_window.py
"""
Main Window GUI - Constructs the main application window with a split-pane layout.
Primary chat pane (left) with scoped footer, secondary media pane (right) with tabs.
"""
from PyQt6.QtWidgets import QApplication, QMainWindow, QWidget, QVBoxLayout, QLabel, QSplitter
from PyQt6.QtCore import pyqtSignal, Qt
from PyQt6.QtGui import QIcon, QShortcut, QKeySequence
from gui.widgets.action_buttons_panel import ActionButtonsPanel
from gui.widgets.input_panel import InputPanel
from gui.widgets.response_panel import ResponsePanel
from gui.widgets.media_panel import MediaPanel


class MainWindow(QMainWindow):
    """Main application window with asymmetrical split-pane layout."""

    status_signal = pyqtSignal(str)

    def __init__(self, file_service, config_manager=None):
        super().__init__()
        self.file_service = file_service
        self.config_manager = config_manager
        self.file_service.files_updated.connect(self._on_files_updated)
        self.file_service.status_updated.connect(self.status_signal.emit)
        self.file_service.files_cleared.connect(self._on_files_cleared)
        self.setWindowTitle("PyQt6 Chat Framework")
        self.setWindowIcon(QIcon("assets/icons/app_icon.ico"))
        self.setStyleSheet("""
            QMainWindow, QStatusBar { background-color: #1a1a1a; }
            QLabel { color: #ffffff; font-family: Arial; }
            QPushButton { background-color: #3d3d3d; color: #ffffff; border: 1px solid #333; padding: 8px; font-family: Arial; font-size: 9pt; border-radius: 4px; }
            QPushButton:hover { background-color: #4d4d4d; }
            QPushButton:pressed { background-color: #2d2d2d; }
            QTextEdit { background-color: #1e1e1e; color: #ffffff; border: 1px solid #333; font-family: Consolas; font-size: 9pt; }
            QStatusBar { color: #888888; font-size: 8pt; }
            QSplitter::handle {
                background-color: #333333;
            }
            QSplitter::handle:hover {
                background-color: #4d4d4d;
            }
            QSplitter::handle:pressed {
                background-color: #1E88E5;
            }
        """)

        central = QWidget()
        self.setCentralWidget(central)
        main_layout = QVBoxLayout(central)
        main_layout.setContentsMargins(10, 10, 10, 5)
        main_layout.setSpacing(5)

        # --- Horizontal splitter: chat pane | media pane ---
        self.splitter = QSplitter(Qt.Orientation.Horizontal)
        self.splitter.setHandleWidth(5)
        self.splitter.setChildrenCollapsible(False)

        # Left pane: Chat (response + input + action buttons)
        chat_pane = QWidget()
        chat_pane.setMinimumWidth(400)
        chat_pane_layout = QVBoxLayout(chat_pane)
        chat_pane_layout.setContentsMargins(0, 0, 0, 0)
        chat_pane_layout.setSpacing(10)
        self._build_chat_pane(chat_pane_layout)
        self.splitter.addWidget(chat_pane)

        # Right pane: Media (tabbed image generation interface)
        self.media_panel = MediaPanel(self.config_manager)
        self.media_panel.setMinimumWidth(280)
        self.splitter.addWidget(self.media_panel)

        # Default asymmetric split ~65/35, stretch ratio 3:2
        self.splitter.setSizes([780, 420])
        self.splitter.setStretchFactor(0, 3)
        self.splitter.setStretchFactor(1, 2)

        main_layout.addWidget(self.splitter, 1)

        # --- Status bar ---
        self.status_label = QLabel("Ready")
        self.status_label.setStyleSheet("color: #888; font-size: 8pt;")
        self.status_signal.connect(self.status_label.setText)
        main_layout.addWidget(self.status_label, 0, Qt.AlignmentFlag.AlignLeft)

        self.status_signal.emit("Ready")
        self._setup_shortcuts()

    def _setup_shortcuts(self):
        """Set up global keyboard shortcuts."""
        search_shortcut = QShortcut(QKeySequence.StandardKey.Find, self)
        search_shortcut.activated.connect(self.response_panel.show_search)

        nav_left_shortcut = QShortcut(QKeySequence("Ctrl+Left"), self)
        nav_left_shortcut.activated.connect(lambda: self.action_buttons_panel.navigate_left_signal.emit())

        nav_right_shortcut = QShortcut(QKeySequence("Ctrl+Right"), self)
        nav_right_shortcut.activated.connect(lambda: self.action_buttons_panel.navigate_right_signal.emit())

        delete_all_shortcut = QShortcut(QKeySequence("Ctrl+D"), self)
        delete_all_shortcut.activated.connect(lambda: self.action_buttons_panel.delete_all_chats_signal.emit())

    def _build_chat_pane(self, layout):
        """Build the primary chat pane with response, input, and action buttons."""
        self.main_panel_layout = layout

        # Response panel (takes all available vertical space)
        self.response_panel = ResponsePanel()
        layout.addWidget(self.response_panel)

        # Input panel (scoped footer - dynamic height)
        self.input_panel = InputPanel()
        layout.addWidget(self.input_panel)

        # Action buttons panel (scoped footer - fixed height)
        self.action_buttons_panel = ActionButtonsPanel(self.file_service)
        layout.addWidget(self.action_buttons_panel)

        self.input_panel.text_content_changed_signal.connect(self.action_buttons_panel.update_text_action_buttons)

        layout.setStretchFactor(self.response_panel, 1)
        layout.setStretchFactor(self.input_panel, 0)
        layout.setStretchFactor(self.action_buttons_panel, 0)

    def _on_files_cleared(self):
        self.action_buttons_panel.select_file_signal.emit("", "")

    def _on_files_updated(self, filenames):
        """Handle files updated signal - update status bar with file list."""
        if not filenames:
            self.status_signal.emit("No files selected.")
            return
        if len(filenames) == 1:
            self.status_signal.emit(f"File ready: {filenames[0]}")
        elif len(filenames) <= 3:
            self.status_signal.emit(f"Files ready: {', '.join(filenames)}")
        else:
            self.status_signal.emit(f"Files ready: {', '.join(filenames[:3])}... ({len(filenames)} total)")

    def keyPressEvent(self, event):
        """Handle keyboard events - Ctrl+V for clipboard paste."""
        modifiers = event.modifiers()
        if (modifiers & Qt.KeyboardModifier.ControlModifier) and event.key() == Qt.Key.Key_V:
            clipboard = QApplication.clipboard()
            mime_data = clipboard.mimeData()
            if mime_data.hasImage():
                img = clipboard.image()
                if not img.isNull():
                    from PyQt6.QtCore import QBuffer, QIODevice
                    buf = QBuffer()
                    buf.open(QIODevice.OpenModeFlag.WriteOnly)
                    img.save(buf, "PNG")
                    self.file_service.load_file_from_data(bytes(buf.data()), "clipboard.png")
                    return
        super().keyPressEvent(event)

    def get_input_text(self) -> str:
        """Get the text from the input text edit."""
        return self.input_panel.get_input_text()

    def closeEvent(self, event):
        """Handle window close event to save window size and splitter state."""
        if getattr(self, 'config_manager', None):
            self.config_manager.window_width = self.width()
            self.config_manager.window_height = self.height()
            self.config_manager.splitter_sizes = self.splitter.sizes()
            self.config_manager.save()
        event.accept()
```

### `app/main.py`

```python
# app/main.py
"""
Application Entry Point
"""
import sys
from PyQt6.QtWidgets import QApplication
from PyQt6.QtGui import QGuiApplication
from PyQt6.QtCore import Qt, qInstallMessageHandler, QtMsgType
from app.controller import ApplicationController


def qt_message_handler(mode, context, message):
    """
    Custom Qt message handler to suppress QPainter warnings.

    Args:
        mode: QtMsgType - The type of message
        context: QMessageLogContext - Context information
        message: str - The message content
    """
    # Suppress QPainter warnings as they are not from our code and can be safely ignored
    if "QPainter" in message:
        return

    # For all other messages, use default handling
    # We can't call the original handler directly, so we'll print to stderr for warnings/errors
    if mode in (QtMsgType.QtWarningMsg, QtMsgType.QtCriticalMsg, QtMsgType.QtFatalMsg):
        print(f"Qt {mode.name}: {message}", file=sys.stderr)
    elif mode == QtMsgType.QtInfoMsg:
        print(f"Qt Info: {message}", file=sys.stderr)
    # QtDebugMsg is typically not printed in release builds

if __name__ == "__main__":
    # Set high DPI policy for better scaling on modern displays (must be before QApplication)
    QGuiApplication.setHighDpiScaleFactorRoundingPolicy(Qt.HighDpiScaleFactorRoundingPolicy.PassThrough)
    QApplication.setAttribute(Qt.ApplicationAttribute.AA_ShareOpenGLContexts)

    try:
        # Install custom message handler to suppress QPainter warnings
        qInstallMessageHandler(qt_message_handler)

        # QApplication instance must be created first
        q_app = QApplication(sys.argv)
        
        # Initialize and run the main application controller
        controller = ApplicationController(q_app)
        controller.run()
        
    except Exception as e:
        print(f"FATAL APPLICATION ERROR: {e}", file=sys.stderr)
        sys.exit(1)
```