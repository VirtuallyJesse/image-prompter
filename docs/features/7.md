### TASKS

We're moving the project to the next phase, which is an introduction to integration with various image generation APIs (the models themselves which generate the images).

## CURRENT PHASE TASK:

You have full creative liberty to design and implement any system which covers these goals:

1. Complete implementation of the Airforce image generator in the media panel. Use env `AIRFORCE_API_KEY`. Create `./core/services/airforce_service.py` and `./gui/widgets/airforce_page.py`.

2. The Airforce inline page has a row of buttons at the top (under the navigation tabs). These are stylistically and behaviorally similar to the Pollinations page buttons. These parameters for the API request the user will make to generate the image. These are the buttons for Airforce page:
[Generate]|[Positive Prompt][Negative Prompt][Model][Size][Seed]

Generate makes the call.
Positive/negative prompt are input fields where the user can write to. 
Model and Size use a dropdown selector that opens on hover, similar to our custom service/model selector button which opens a dropdown on hover in the chat response panel. (should be referenced and used/present in the pollinations page file or action buttons panel)
Size sets both the width and height.

Here are the defaults to use, and the ranges:
Positive/Negative are empty, with placeholder text "Positive Prompt..." & "Negative Prompt..."
Models:
`imagen-4`, `grok-imagine`. Use `grok-imagine` as default.
Size: `1024x1024`, `1344x768`, `768x1344`. Use `1024x1024` as default.
Seed `-1` as default.

3. After the generation, the image is received and downloaded to a folder `images`. Use a similar naming convention for the filenames as we do chats e.g. `2026-02-20_15-41-48`. Embed the prompt data and the service used into the metadata of the image file. Save as `.jpg`.

4. The image is displayed on the page, fully contained (never cropped) and using all available spacing.

5. Proper updates to the status bar (generating, errors, etc).

6. Persistence with configurations, similar to pollinations.

7. Left click to open image (in `utils.py`)

A lot of these task requirements are already met in the pollinations page, so consider refactoring to a shared util that both pages will use to reduce code bloat/duplication.

### NON-GOALS

These are OUT OF PHASE TASK:

1. API integration or service creations for "Perchance"
2. Gallery image work
3. No image-to-image support, this is text-to-image integration

### AIRFORCE DEVELOPER GUIDE

The Airforce service unfortunately does not provide official documentation. All we have to work with are code snippets from their Image Playground section on their website. Here are the snippets for our two models:

# IMAGEN-4

```
import requests
import json

url = "https://api.airforce/v1/images/generations"
headers = {"Authorization": "Bearer sk-air-a03E...", "Content-Type": "application/json"}
payload = {
  "model": "grok-imagine",
  "prompt": "",
  "n": 1,
  "size": "1024x1024",
  "response_format": "b64_json",
  "sse": true
}

# SSE handling
with requests.post(url, headers=headers, json=payload, stream=True) as response:
    for line in response.iter_lines():
        if line:
            line_str = line.decode('utf-8')
            if line_str.startswith("data: ") and line_str != "data: [DONE]" and line_str != "data: : keepalive":
                data = json.loads(line_str[6:])
                print(data)
```

# GROK-IMAGINE

```
import requests
import json

url = "https://api.airforce/v1/images/generations"
headers = {"Authorization": "Bearer sk-air-a03E...", "Content-Type": "application/json"}
payload = {
  "model": "grok-imagine",
  "prompt": "",
  "n": 1,
  "size": "1024x1024",
  "response_format": "b64_json",
  "sse": true
}

# SSE handling
with requests.post(url, headers=headers, json=payload, stream=True) as response:
    for line in response.iter_lines():
        if line:
            line_str = line.decode('utf-8')
            if line_str.startswith("data: ") and line_str != "data: [DONE]" and line_str != "data: : keepalive":
                data = json.loads(line_str[6:])
                print(data)
```

You'll notice in these snippets a few discrepencies from the parameters we request. The snippets don't expose a negative prompt or seed, but we'll try sending them anyway! There's also a number value, just set it to 1.

### PROJECT 

A sophisticated desktop application that enhances image generation prompts using AI models and provides seamless integration with various image generation APIs with a modern PyQt6 GUI.

### DELIVERABLES

Please output a brief summary including any design choices, and the updated or new files where applicable. You may create new services or modules. If only small changes to existing files are required, please output them in

SEARCH: 

```
...stuff...
``` 

REPLACE:

```
...stuff...
``` 

style blocks.

### CONTEXT

## üéØ Focused Context (Agent-Selected)

**Project Root:** `image-prompter/`
**Files Included:** 6

---

### File Index

1. `gui/widgets/media_panel.py`
2. `core/config.py`
3. `gui/widgets/pollinations_page.py`
4. `core/services/pollinations_service.py`
5. `gui/widgets/action_buttons_panel.py`
6. `core/utils.py`

---

### `gui/widgets/media_panel.py`

```python
# gui/widgets/media_panel.py
"""
Media Panel - Secondary pane for generative imaging interfacing.
Provides tabbed navigation for different image generation APIs.
"""

from PyQt6.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, QPushButton,
    QStackedWidget, QLabel, QSizePolicy
)
from PyQt6.QtCore import Qt, pyqtSignal
from PyQt6.QtGui import QCursor
from gui.widgets.pollinations_page import PollinationsPage


class MediaPanel(QWidget):
    """Secondary pane with tabbed navigation for image generation API interfaces."""

    status_updated = pyqtSignal(str)

    TAB_NAMES = ["Gallery", "Pollinations", "Airforce", "Perchance"]

    ACTIVE_BG = "#1E88E5"
    ACTIVE_HOVER = "#2A9BF8"
    INACTIVE_BG = "#2a2a2a"
    INACTIVE_HOVER = "#3d3d3d"

    _TAB_ICONS = {"Gallery": "üñºÔ∏è", "Pollinations": "üå∏", "Airforce": "‚úàÔ∏è", "Perchance": "üé≤"}
    _TAB_DESCS = {
        "Gallery": "Generated images will appear here",
        "Pollinations": "Pollinations AI image generation",
        "Airforce": "Airforce image generation API",
        "Perchance": "Perchance image generation",
    }

    def __init__(self, config_manager=None, parent=None):
        super().__init__(parent)
        self.config_manager = config_manager
        self.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Expanding)
        self._current_tab = 0
        self._tabs = []
        self._build_ui()
        self._load_active_tab()

    def _build_ui(self):
        layout = QVBoxLayout(self)
        layout.setContentsMargins(0, 0, 0, 0)
        layout.setSpacing(0)

        # --- Tab bar ---
        tab_bar = QWidget()
        tab_bar.setFixedHeight(34)
        tab_bar.setStyleSheet("background-color: #1a1a1a;")
        tab_layout = QHBoxLayout(tab_bar)
        tab_layout.setContentsMargins(0, 0, 0, 0)
        tab_layout.setSpacing(1)

        for i, name in enumerate(self.TAB_NAMES):
            btn = QPushButton(name)
            btn.setCursor(QCursor(Qt.CursorShape.PointingHandCursor))
            btn.setFocusPolicy(Qt.FocusPolicy.NoFocus)
            btn.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Expanding)
            btn.clicked.connect(lambda _, idx=i: self._switch_tab(idx))
            self._tabs.append(btn)
            tab_layout.addWidget(btn)

        layout.addWidget(tab_bar)

        # --- Stacked content area ---
        self._stack = QStackedWidget()
        self._stack.setStyleSheet("background-color: #2a2a2a; border: 1px solid #333;")

        for name in self.TAB_NAMES:
            if name == "Pollinations":
                self.pollinations_page = PollinationsPage(self.config_manager)
                self.pollinations_page.status_updated.connect(self.status_updated.emit)
                self._stack.addWidget(self.pollinations_page)
            else:
                self._stack.addWidget(self._create_page(name))

        layout.addWidget(self._stack, 1)
        self._update_tab_styles()

    def _create_page(self, name: str) -> QWidget:
        """Create a placeholder page for a tab."""
        page = QWidget()
        page_layout = QVBoxLayout(page)
        page_layout.setAlignment(Qt.AlignmentFlag.AlignCenter)

        icon = QLabel(self._TAB_ICONS.get(name, "üìÑ"))
        icon.setStyleSheet("font-size: 32pt;")
        icon.setAlignment(Qt.AlignmentFlag.AlignCenter)
        page_layout.addWidget(icon)

        title = QLabel(name)
        title.setStyleSheet("color: #666; font-size: 14pt; font-weight: bold;")
        title.setAlignment(Qt.AlignmentFlag.AlignCenter)
        page_layout.addWidget(title)

        desc = QLabel(self._TAB_DESCS.get(name, ""))
        desc.setStyleSheet("color: #444; font-size: 9pt;")
        desc.setAlignment(Qt.AlignmentFlag.AlignCenter)
        desc.setWordWrap(True)
        page_layout.addWidget(desc)

        return page

    def _switch_tab(self, index: int):
        """Switch to the specified tab index."""
        if index == self._current_tab:
            return
        self._current_tab = index
        self._stack.setCurrentIndex(index)
        self._update_tab_styles()
        if self.config_manager:
            self.config_manager.media_active_tab = index
            self.config_manager.save()

    def _load_active_tab(self):
        """Restore the last active tab from config."""
        if self.config_manager:
            tab = getattr(self.config_manager, 'media_active_tab', 0)
            if 0 <= tab < len(self.TAB_NAMES):
                self._current_tab = tab
                self._stack.setCurrentIndex(tab)
                self._update_tab_styles()

    def _update_tab_styles(self):
        """Update tab button visual styles based on active selection."""
        for i, btn in enumerate(self._tabs):
            if i == self._current_tab:
                btn.setStyleSheet(f"""
                    QPushButton {{
                        background-color: {self.ACTIVE_BG};
                        color: #ffffff;
                        font-weight: bold;
                        font-size: 9pt;
                        border: none;
                        border-radius: 0px;
                        padding: 4px 8px;
                    }}
                    QPushButton:hover {{
                        background-color: {self.ACTIVE_HOVER};
                    }}
                """)
            else:
                btn.setStyleSheet(f"""
                    QPushButton {{
                        background-color: {self.INACTIVE_BG};
                        color: #888;
                        font-size: 9pt;
                        border: none;
                        border-radius: 0px;
                        padding: 4px 8px;
                    }}
                    QPushButton:hover {{
                        background-color: {self.INACTIVE_HOVER};
                        color: #fff;
                    }}
                """)
```

### `core/config.py`

```python
"""Configuration Manager for PyQt6 GUI Framework."""
import os
import json

_DEFAULTS = {
    "window_width": 1200,
    "window_height": 800,
    "theme": "dark",
    "current_service": "Gemini",
    "current_model": "Flash",
    "default_system_prompt": "You are a helpful AI assistant.",
    "splitter_sizes": [780, 420],
    "media_active_tab": 0,
    "pollinations_positive_prompt": "",
    "pollinations_negative_prompt": "",
    "pollinations_model": "zimage",
    "pollinations_size": "1024x1024",
    "pollinations_seed": -1,
    "pollinations_last_image": "",
    "display_fields": {
        "core": True,
        "composition": True,
        "lighting": True,
        "style": True,
        "technical": True,
        "post_processing": True,
        "special_elements": True,
        "detailed_prompt": True,
        "grok_imagine_optimized": True,
        "gemini_optimized": True,
        "flux_optimized": True,
        "stable_diffusion_optimized": True,
        "video_optimized": True
    }
}

class ConfigManager:
    """Manages GUI configuration values and local gui_config.json persistence."""

    def __init__(self, config_file: str = "gui_config.json"):
        self.config_file = config_file
        self.__dict__.update(_DEFAULTS)
        self._load_config()

    def _load_config(self) -> None:
        if not os.path.exists(self.config_file):
            return
        try:
            with open(self.config_file, 'r') as f:
                config = json.load(f)
                for k in _DEFAULTS:
                    val = config.get(k, getattr(self, k))
                    if isinstance(val, dict) and isinstance(_DEFAULTS[k], dict):
                        merged = _DEFAULTS[k].copy()
                        merged.update(val)
                        setattr(self, k, merged)
                    else:
                        setattr(self, k, val)
                if "default_service" in config and "current_service" not in config:
                    self.current_service = config["default_service"]
                if "service_models" in config and "current_model" not in config:
                    self.current_model = config.get("service_models", {}).get(self.current_service, self.current_model)
        except Exception:
            pass

    def save(self) -> None:
        try:
            with open(self.config_file, 'w') as f:
                json.dump({k: getattr(self, k) for k in _DEFAULTS}, f, indent=2)
        except Exception:
            pass
```

### `gui/widgets/pollinations_page.py`

```python
# gui/widgets/pollinations_page.py
"""
Pollinations Page - Image generation interface for the Pollinations AI API.
Provides controls for prompt, model, size, seed and displays generated images.
"""

from PyQt6.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, QPushButton, QLineEdit,
    QLabel, QSizePolicy
)
from PyQt6.QtCore import pyqtSignal, Qt, QTimer, QEvent
from PyQt6.QtGui import QCursor, QPixmap

import os

from core.services.pollinations_service import PollinationsService
from core.utils import reveal_file_in_explorer


class ImageDisplay(QLabel):
    """Custom label that displays an image fully contained, never cropped."""

    clicked = pyqtSignal()

    def __init__(self, parent=None):
        super().__init__(parent)
        self._pixmap = None
        self.setAlignment(Qt.AlignmentFlag.AlignCenter)
        self.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Expanding)
        self.setMinimumSize(64, 64)
        self.setStyleSheet("background-color: #121212; border: none;")

    def set_image(self, filepath: str):
        """Load and display an image from file path."""
        self._pixmap = QPixmap(filepath)
        self._update_display()
        self.setCursor(QCursor(Qt.CursorShape.PointingHandCursor))

    def clear_image(self):
        self._pixmap = None
        self.clear()
        self.setCursor(QCursor(Qt.CursorShape.ArrowCursor))

    def mousePressEvent(self, event):
        if event.button() == Qt.MouseButton.LeftButton and self._pixmap:
            self.clicked.emit()
        super().mousePressEvent(event)

    def _update_display(self):
        if self._pixmap and not self._pixmap.isNull():
            scaled = self._pixmap.scaled(
                self.size(),
                Qt.AspectRatioMode.KeepAspectRatio,
                Qt.TransformationMode.SmoothTransformation,
            )
            self.setPixmap(scaled)

    def resizeEvent(self, event):
        super().resizeEvent(event)
        self._update_display()


class PollinationsPage(QWidget):
    """Pollinations AI image generation page with controls and image display."""

    status_updated = pyqtSignal(str)

    MODELS = ["flux", "zimage", "klein", "klein-large", "gptimage"]
    SIZES = ["1024x1024", "1344x768", "768x1344"]
    DEFAULT_MODEL = "zimage"
    DEFAULT_SIZE = "1024x1024"
    DEFAULT_SEED = -1

    _INPUT_STYLE = (
        "QLineEdit {"
        "  background-color: #1e1e1e; color: #eee;"
        "  border: 1px solid #333; border-radius: 3px;"
        "  font-size: 12px; padding: 6px;"
        "}"
        "QLineEdit:disabled { color: #666; }"
    )

    _BTN_GENERATE = (
        "QPushButton {"
        "  background-color: #1E88E5; color: #fff; font-weight: bold;"
        "  border: 1px solid #1E88E5; border-radius: 3px;"
        "  font-size: 12px; padding: 6px 12px;"
        "}"
        "QPushButton:hover { background-color: #2A9BF8; border-color: #2A9BF8; }"
        "QPushButton:pressed { background-color: #1966C2; border-color: #1966C2; }"
    )

    _BTN_CANCEL = (
        "QPushButton {"
        "  background-color: #F44336; color: #fff; font-weight: bold;"
        "  border: 1px solid #F44336; border-radius: 3px;"
        "  font-size: 12px; padding: 6px 12px;"
        "}"
        "QPushButton:hover { background-color: #EF5350; border-color: #EF5350; }"
        "QPushButton:pressed { background-color: #D32F2F; border-color: #D32F2F; }"
    )

    _BTN_DROPDOWN = (
        "QPushButton {"
        "  background-color: #1e1e1e; color: #eee;"
        "  border: 1px solid #333; border-radius: 3px;"
        "  font-size: 12px; padding: 6px 8px;"
        "}"
        "QPushButton:hover { background-color: #2a2a2a; border-color: #555; }"
        "QPushButton:disabled { color: #666; }"
    )

    _DROPDOWN_OPTION = (
        "QPushButton {"
        "  background-color: transparent; color: #eee; border: none;"
        "  text-align: left; padding: 6px 12px; font-size: 12px;"
        "}"
        "QPushButton:hover { background-color: #2a2a2a; }"
    )

    def __init__(self, config_manager=None, parent=None):
        super().__init__(parent)
        self.config_manager = config_manager
        self.current_model = self.DEFAULT_MODEL
        self.current_size = self.DEFAULT_SIZE
        self._is_generating = False
        self._current_image_path = ""

        self.active_dropdown = None
        self.hide_timer = QTimer()
        self.hide_timer.setInterval(250)
        self.hide_timer.timeout.connect(self._hide_dropdown)

        self.service = PollinationsService()
        self.service.image_generated.connect(self._on_image_generated)
        self.service.error_occurred.connect(self._on_error)
        self.service.status_updated.connect(self.status_updated.emit)

        self._build_ui()
        self._load_from_config()

    def _build_ui(self):
        layout = QVBoxLayout(self)
        layout.setContentsMargins(0, 0, 0, 0)
        layout.setSpacing(0)

        # --- Controls bar ---
        controls = QWidget()
        controls.setStyleSheet("background-color: #121212;")
        cl = QHBoxLayout(controls)
        cl.setContentsMargins(4, 4, 4, 4)
        cl.setSpacing(6)

        self.generate_btn = QPushButton("Generate")
        self.generate_btn.setStyleSheet(self._BTN_GENERATE)
        self.generate_btn.setCursor(QCursor(Qt.CursorShape.PointingHandCursor))
        self.generate_btn.setFocusPolicy(Qt.FocusPolicy.NoFocus)
        self.generate_btn.clicked.connect(self._on_generate_clicked)
        cl.addWidget(self.generate_btn)

        self.positive_input = QLineEdit()
        self.positive_input.setPlaceholderText("Positive Prompt...")
        self.positive_input.setStyleSheet(self._INPUT_STYLE)
        self.positive_input.returnPressed.connect(self._on_generate_clicked)
        cl.addWidget(self.positive_input, stretch=2)

        self.negative_input = QLineEdit()
        self.negative_input.setPlaceholderText("Negative Prompt...")
        self.negative_input.setStyleSheet(self._INPUT_STYLE)
        self.negative_input.returnPressed.connect(self._on_generate_clicked)
        cl.addWidget(self.negative_input, stretch=1)

        self.model_btn = QPushButton(self.current_model)
        self.model_btn.setStyleSheet(self._BTN_DROPDOWN)
        self.model_btn.setCursor(QCursor(Qt.CursorShape.PointingHandCursor))
        self.model_btn.setFocusPolicy(Qt.FocusPolicy.NoFocus)
        self.model_btn.setMinimumWidth(90)
        self.model_btn.installEventFilter(self)
        cl.addWidget(self.model_btn)

        self.size_btn = QPushButton(self.current_size)
        self.size_btn.setStyleSheet(self._BTN_DROPDOWN)
        self.size_btn.setCursor(QCursor(Qt.CursorShape.PointingHandCursor))
        self.size_btn.setFocusPolicy(Qt.FocusPolicy.NoFocus)
        self.size_btn.setMinimumWidth(90)
        self.size_btn.installEventFilter(self)
        cl.addWidget(self.size_btn)

        self.seed_input = QLineEdit(str(self.DEFAULT_SEED))
        self.seed_input.setStyleSheet(self._INPUT_STYLE)
        self.seed_input.setFixedWidth(64)
        self.seed_input.setAlignment(Qt.AlignmentFlag.AlignCenter)
        self.seed_input.setToolTip("Seed (-1 for random)")
        self.seed_input.returnPressed.connect(self._on_generate_clicked)
        cl.addWidget(self.seed_input)

        layout.addWidget(controls)

        # --- Image display ---
        self.image_display = ImageDisplay()
        self.image_display.clicked.connect(self._on_image_clicked)
        layout.addWidget(self.image_display, 1)

        self._create_dropdowns()

    def _create_dropdowns(self):
        self.model_dropdown = self._make_dropdown(self.MODELS, self._on_model_selected)
        self.size_dropdown = self._make_dropdown(self.SIZES, self._on_size_selected)

    def _make_dropdown(self, options: list, callback) -> QWidget:
        dd = QWidget(self.window() or None)
        dd.setWindowFlags(Qt.WindowType.FramelessWindowHint | Qt.WindowType.Tool)
        dd.setAttribute(Qt.WidgetAttribute.WA_ShowWithoutActivating)
        dd.setStyleSheet(
            "QWidget { background-color: #1e1e1e; border: 1px solid #333; border-radius: 3px; }"
        )
        lo = QVBoxLayout(dd)
        lo.setContentsMargins(2, 2, 2, 2)
        lo.setSpacing(1)

        for opt in options:
            btn = QPushButton(opt)
            btn.setStyleSheet(self._DROPDOWN_OPTION)
            btn.setCursor(QCursor(Qt.CursorShape.PointingHandCursor))
            btn.clicked.connect(lambda _, o=opt: callback(o))
            lo.addWidget(btn)

        dd.adjustSize()
        dd.hide()
        dd.installEventFilter(self)
        return dd

    # ---------------------------------------------------------------- Dropdowns

    def eventFilter(self, obj, event):
        et = event.type()
        if et == QEvent.Type.Enter:
            if obj == self.model_btn:
                self._show_dropdown(self.model_dropdown, self.model_btn)
            elif obj == self.size_btn:
                self._show_dropdown(self.size_dropdown, self.size_btn)
            elif obj in (self.model_dropdown, self.size_dropdown):
                self.hide_timer.stop()
        elif et == QEvent.Type.Leave:
            if obj in (self.model_btn, self.size_btn,
                       self.model_dropdown, self.size_dropdown):
                self.hide_timer.start()
        return super().eventFilter(obj, event)

    def _show_dropdown(self, dropdown, button):
        if self._is_generating:
            return
        self.hide_timer.stop()
        if self.active_dropdown and self.active_dropdown is not dropdown:
            self.active_dropdown.hide()
        if self.active_dropdown is dropdown:
            return
        self.active_dropdown = dropdown
        pos = button.mapToGlobal(button.rect().bottomLeft())
        dropdown.move(pos.x(), pos.y() + 2)
        dropdown.show()
        dropdown.raise_()

    def _hide_dropdown(self):
        if self.active_dropdown:
            self.active_dropdown.hide()
            self.active_dropdown = None

    def _on_model_selected(self, model: str):
        self.current_model = model
        self.model_btn.setText(model)
        self._hide_dropdown()
        self._save_to_config()

    def _on_size_selected(self, size: str):
        self.current_size = size
        self.size_btn.setText(size)
        self._hide_dropdown()
        self._save_to_config()

    # ------------------------------------------------------------ Generation

    def _on_generate_clicked(self):
        if self._is_generating:
            self.service.cancel_generation()
            self._set_generating(False)
            self.status_updated.emit("Generation cancelled.")
            return

        prompt = self.positive_input.text().strip()
        if not prompt:
            self.status_updated.emit("Error: Positive prompt cannot be empty.")
            return

        try:
            seed = int(self.seed_input.text().strip())
        except ValueError:
            seed = -1

        w, h = self.current_size.split("x")
        self._set_generating(True)
        self._save_to_config()
        self.service.generate_image(
            prompt=prompt,
            negative_prompt=self.negative_input.text().strip(),
            model=self.current_model,
            width=int(w),
            height=int(h),
            seed=seed,
        )

    def _on_image_generated(self, filepath: str):
        self._set_generating(False)
        self._current_image_path = filepath
        self.image_display.set_image(filepath)
        self._save_to_config()

    def _on_error(self, _error_msg: str):
        self._set_generating(False)

    def _set_generating(self, state: bool):
        self._is_generating = state
        self.positive_input.setEnabled(not state)
        self.negative_input.setEnabled(not state)
        self.model_btn.setEnabled(not state)
        self.size_btn.setEnabled(not state)
        self.seed_input.setEnabled(not state)

        if state:
            self._hide_dropdown()
            self.generate_btn.setText("Cancel")
            self.generate_btn.setStyleSheet(self._BTN_CANCEL)
        else:
            self.generate_btn.setText("Generate")
            self.generate_btn.setStyleSheet(self._BTN_GENERATE)

    def hideEvent(self, event):
        """Close dropdowns when page is hidden (tab switch)."""
        self._hide_dropdown()
        super().hideEvent(event)

    def _on_image_clicked(self):
        """Open file explorer and select the current image."""
        if self._current_image_path and os.path.isfile(self._current_image_path):
            reveal_file_in_explorer(self._current_image_path)
        else:
            self.status_updated.emit("Image file not found on disk.")

    def _save_to_config(self):
        """Persist current Pollinations settings to config."""
        if not self.config_manager:
            return
        self.config_manager.pollinations_positive_prompt = self.positive_input.text()
        self.config_manager.pollinations_negative_prompt = self.negative_input.text()
        self.config_manager.pollinations_model = self.current_model
        self.config_manager.pollinations_size = self.current_size
        try:
            self.config_manager.pollinations_seed = int(self.seed_input.text())
        except ValueError:
            self.config_manager.pollinations_seed = self.DEFAULT_SEED
        self.config_manager.pollinations_last_image = self._current_image_path
        self.config_manager.save()

    def _load_from_config(self):
        """Load persisted Pollinations settings from config."""
        if not self.config_manager:
            return

        self.positive_input.setText(
            getattr(self.config_manager, 'pollinations_positive_prompt', ''))
        self.negative_input.setText(
            getattr(self.config_manager, 'pollinations_negative_prompt', ''))

        model = getattr(self.config_manager, 'pollinations_model', self.DEFAULT_MODEL)
        if model in self.MODELS:
            self.current_model = model
            self.model_btn.setText(model)

        size = getattr(self.config_manager, 'pollinations_size', self.DEFAULT_SIZE)
        if size in self.SIZES:
            self.current_size = size
            self.size_btn.setText(size)

        seed = getattr(self.config_manager, 'pollinations_seed', self.DEFAULT_SEED)
        self.seed_input.setText(str(seed))

        last_image = getattr(self.config_manager, 'pollinations_last_image', '')
        if last_image and os.path.isfile(last_image):
            self._current_image_path = last_image
            self.image_display.set_image(last_image)
```

### `core/services/pollinations_service.py`

```python
# core/services/pollinations_service.py
"""
Pollinations AI Image Generation Service.
Handles API communication with Pollinations for text-to-image generation.
"""

import os
import urllib.request
import urllib.parse
import urllib.error
from datetime import datetime
from pathlib import Path

from PyQt6.QtCore import QObject, pyqtSignal, QThread


class PollinationsWorker(QThread):
    """Worker thread for Pollinations API image generation."""
    finished = pyqtSignal(str)
    error = pyqtSignal(str)

    BASE_URL = "https://gen.pollinations.ai/image"

    def __init__(self, prompt, negative_prompt, model, width, height, seed):
        super().__init__()
        self.prompt = prompt
        self.negative_prompt = negative_prompt
        self.model = model
        self.width = width
        self.height = height
        self.seed = seed
        self._is_cancelled = False
        self.api_key = os.environ.get("POLLINATIONS_API_KEY", "")

    def cancel(self):
        self._is_cancelled = True

    def run(self):
        try:
            encoded_prompt = urllib.parse.quote(self.prompt, safe="")
            params = {
                "model": self.model,
                "width": self.width,
                "height": self.height,
                "seed": self.seed,
                "nologo": "true",
            }
            if self.negative_prompt:
                params["negative_prompt"] = self.negative_prompt

            query_string = urllib.parse.urlencode(params)
            full_url = f"{self.BASE_URL}/{encoded_prompt}?{query_string}"

            headers = {"User-Agent": "ImagePrompter/1.0"}
            if self.api_key:
                headers["Authorization"] = f"Bearer {self.api_key}"

            req = urllib.request.Request(full_url, headers=headers)
            response = urllib.request.urlopen(req, timeout=180)

            if self._is_cancelled:
                self.error.emit("Generation cancelled.")
                return

            content_type = response.headers.get("Content-Type", "")
            if "image" not in content_type:
                body = response.read(500).decode("utf-8", errors="replace")
                self.error.emit(f"Unexpected response ({content_type}): {body}")
                return

            image_data = response.read()

            if self._is_cancelled:
                self.error.emit("Generation cancelled.")
                return

            filepath = self._save_image(image_data)
            self.finished.emit(str(filepath))

        except urllib.error.HTTPError as e:
            if not self._is_cancelled:
                body = ""
                try:
                    body = e.read(300).decode("utf-8", errors="replace")
                except Exception:
                    pass
                self.error.emit(f"HTTP {e.code}: {body or e.reason}")
        except urllib.error.URLError as e:
            if not self._is_cancelled:
                self.error.emit(f"Connection error: {e.reason}")
        except Exception as e:
            if not self._is_cancelled:
                self.error.emit(str(e))

    def _save_image(self, image_data: bytes) -> Path:
        """Save image data to disk, embedding metadata when possible."""
        images_dir = Path("images")
        images_dir.mkdir(exist_ok=True)

        timestamp = datetime.now().strftime("%Y-%m-%d_%H-%M-%S")
        filepath = images_dir / f"{timestamp}.jpg"
        counter = 1
        while filepath.exists():
            filepath = images_dir / f"{timestamp}_{counter}.jpg"
            counter += 1

        metadata_str = (
            f"Prompt: {self.prompt} | "
            f"Negative: {self.negative_prompt or 'None'} | "
            f"Model: {self.model} | "
            f"Size: {self.width}x{self.height} | "
            f"Seed: {self.seed} | "
            f"Service: Pollinations"
        )

        saved_with_meta = False
        try:
            from PIL import Image
            import io

            img = Image.open(io.BytesIO(image_data))
            if img.mode in ("RGBA", "P", "LA"):
                img = img.convert("RGB")

            exif = img.getexif()
            exif[0x010E] = metadata_str       # ImageDescription
            exif[0x0131] = "Pollinations AI"  # Software
            img.save(str(filepath), "JPEG", quality=95, exif=exif.tobytes())
            saved_with_meta = True
        except Exception:
            pass

        if not saved_with_meta:
            with open(filepath, "wb") as f:
                f.write(image_data)

        return filepath


class PollinationsService(QObject):
    """Service for Pollinations AI image generation."""
    image_generated = pyqtSignal(str)
    status_updated = pyqtSignal(str)
    error_occurred = pyqtSignal(str)

    def __init__(self):
        super().__init__()
        self.worker = None

    def generate_image(self, prompt, negative_prompt="", model="zimage",
                       width=1024, height=1024, seed=-1):
        """Start image generation in a background thread."""
        if not prompt.strip():
            self.error_occurred.emit("Prompt cannot be empty.")
            self.status_updated.emit("Error: Prompt cannot be empty.")
            return

        self.status_updated.emit(f"Generating with {model} ({width}x{height})...")

        self.worker = PollinationsWorker(
            prompt, negative_prompt, model, width, height, seed
        )
        self.worker.finished.connect(self._on_finished)
        self.worker.error.connect(self._on_error)
        self.worker.finished.connect(self.worker.deleteLater)
        self.worker.error.connect(self.worker.deleteLater)
        self.worker.start()

    def _on_finished(self, filepath):
        if self.sender() is not self.worker:
            return
        self.worker = None
        self.image_generated.emit(filepath)
        self.status_updated.emit(f"Image saved: {filepath}")

    def _on_error(self, msg):
        if self.sender() is not self.worker:
            return
        self.worker = None
        self.error_occurred.emit(msg)
        self.status_updated.emit(f"Error: {msg}")

    def cancel_generation(self):
        """Cancel the current generation if running."""
        if self.worker and self.worker.isRunning():
            self.worker.cancel()
```

### `gui/widgets/action_buttons_panel.py`

```python
# gui/widgets/action_buttons_panel.py
"""
Action Buttons Panel - Contains action buttons for the chat framework GUI.
"""

from PyQt6.QtWidgets import QWidget, QHBoxLayout, QPushButton, QSizePolicy, QFileDialog, QVBoxLayout, QGridLayout
from PyQt6.QtCore import pyqtSignal, Qt, QBuffer, QIODevice, QTimer, QEvent
from PyQt6.QtGui import QCursor



class ActionButtonsPanel(QWidget):
    """A panel containing all action buttons for the chat framework."""

    # Signals
    interrupt_signal = pyqtSignal()
    service_model_selected_signal = pyqtSignal(str, str)  # service, model
    select_file_signal = pyqtSignal(str, str)  # base64, filename
    send_signal = pyqtSignal()
    new_chat_signal = pyqtSignal()
    delete_chat_signal = pyqtSignal()
    delete_all_chats_signal = pyqtSignal()
    navigate_left_signal = pyqtSignal()
    navigate_right_signal = pyqtSignal()
    display_toggled_signal = pyqtSignal(dict)

    # Service to available models mapping
    SERVICE_MODELS = {
        "Gemini": ["Flash", "Pro"],
        "NVIDIA NIM": ["DeepSeek V3.2", "Kimi K2", "Kimi K2.5", "GLM-4.7", "GLM-5", "Qwen3.5-397B-A17B"]
    }

    # NVIDIA NIM models that support image/vision input
    NIM_VISION_MODELS = {"Kimi K2.5", "Qwen3.5-397B-A17B"}

    SERVICE_MODEL_OPTIONS = [(s, m) for s, models in SERVICE_MODELS.items() for m in models]

    def __init__(self, file_service, parent=None):
        super().__init__(parent)
        self.file_service = file_service
        self.file_service.files_updated.connect(self._update_file_controls_state)
        self.file_service.files_cleared.connect(self._update_file_controls_state)
        
        self._is_generating = False

        # Hover menu state
        self.active_dropdown = None
        self.hide_timer = QTimer()
        self.hide_timer.setInterval(250)
        self.hide_timer.timeout.connect(self._hide_dropdown)

        self.layout = QHBoxLayout(self)
        self.layout.setContentsMargins(0, 0, 0, 0)

        # Current selections
        self.current_service = "Gemini"
        self.current_model = "Flash"

        self._create_buttons()

    BLUE = ("#1E88E5", "#2A9BF8", "#1966C2")
    GREEN = ("#4CAF50", "#5CBF60", "#45A049")
    RED = ("#F44336", "#EF5350", "#D32F2F")
    GREY = ("#9E9E9E", "#BDBDBD", "#757575")
    ORANGE = ("#FF6B35", "#FF8C5A", "#E5562A")

    @staticmethod
    def _btn_style(colors, padding="8px"):
        bg, hover, pressed = colors
        return f"""
            QPushButton {{ background-color: {bg}; color: white; font-weight: bold; font-size: 10pt; border: 2px solid {bg}; border-radius: 4px; padding: {padding}; }}
            QPushButton:hover {{ background-color: {hover}; border-color: {hover}; }}
            QPushButton:pressed {{ background-color: {pressed}; border-color: {pressed}; }}
            QPushButton:disabled {{ background-color: #CCCCCC; color: #666666; border-color: #CCCCCC; }}
        """

    def _create_buttons(self):
        def make_btn(text, style, tooltip=""):
            btn = QPushButton(text)
            btn.setStyleSheet(style)
            btn.setCursor(QCursor(Qt.CursorShape.PointingHandCursor))
            btn.setFocusPolicy(Qt.FocusPolicy.NoFocus)
            if tooltip: btn.setToolTip(tooltip)
            return btn

        self.service_model_btn = make_btn(f"{self.current_service}:{self.current_model}", self._btn_style(self.BLUE))
        self.service_model_btn.installEventFilter(self)
        self.layout.addWidget(self.service_model_btn, stretch=2)

        self.display_btn = make_btn("Display", self._btn_style(self.GREY))
        self.display_btn.installEventFilter(self)
        self.layout.addWidget(self.display_btn, stretch=1)

        chat_mgmt_widget = QWidget()
        chat_mgmt_layout = QGridLayout(chat_mgmt_widget)
        chat_mgmt_layout.setContentsMargins(0, 0, 0, 0)
        chat_mgmt_layout.setSpacing(2)

        self.new_chat_btn = make_btn("üÜï", self._btn_style(self.GREEN, "4px"), tooltip="New Chat")
        self.new_chat_btn.clicked.connect(self.new_chat_signal.emit)
        chat_mgmt_layout.addWidget(self.new_chat_btn, 0, 0)

        self.delete_chat_btn = make_btn("üóëÔ∏è", self._btn_style(self.RED, "4px"), tooltip="Delete Chat")
        self.delete_chat_btn.clicked.connect(self.delete_chat_signal.emit)
        chat_mgmt_layout.addWidget(self.delete_chat_btn, 0, 1)

        self.nav_left_btn = make_btn("‚óÄ", "", tooltip="Previous Chat")
        self.nav_left_btn.clicked.connect(self.navigate_left_signal.emit)
        chat_mgmt_layout.addWidget(self.nav_left_btn, 1, 0)

        self.nav_right_btn = make_btn("‚ñ∂", "", tooltip="Next Chat")
        self.nav_right_btn.clicked.connect(self.navigate_right_signal.emit)
        chat_mgmt_layout.addWidget(self.nav_right_btn, 1, 1)
        
        self.update_navigation_buttons(False, False)

        chat_mgmt_widget.setSizePolicy(QSizePolicy.Policy.Preferred, QSizePolicy.Policy.Preferred)
        chat_mgmt_widget.setMaximumHeight(40)
        for btn in [self.new_chat_btn, self.delete_chat_btn, self.nav_left_btn, self.nav_right_btn]:
            btn.setSizePolicy(QSizePolicy.Policy.Preferred, QSizePolicy.Policy.Preferred)
        
        self.layout.addWidget(chat_mgmt_widget, stretch=1)

        select_file_container = QWidget()
        select_file_container.setSizePolicy(QSizePolicy.Policy.Preferred, QSizePolicy.Policy.Preferred)
        select_file_container_layout = QHBoxLayout(select_file_container)
        select_file_container_layout.setContentsMargins(0, 0, 0, 0)
        select_file_container_layout.setSpacing(0)
        
        self.select_file_btn = make_btn("Attach", self._btn_style(self.ORANGE))
        self.select_file_btn.setAcceptDrops(True)
        self.select_file_btn.dragEnterEvent = self._upload_drag_enter
        self.select_file_btn.dropEvent = self._upload_drop
        self.select_file_btn.clicked.connect(self._on_select_file_clicked)
        select_file_container_layout.addWidget(self.select_file_btn)
        
        self.clear_files_btn = make_btn("√ó", self._btn_style(self.RED, "2px 6px"), tooltip="Clear all files")
        self.clear_files_btn.setStyleSheet(self.clear_files_btn.styleSheet() + "QPushButton { min-width: 20px; max-width: 20px; min-height: 20px; max-height: 20px; font-size: 12pt; }")
        self.clear_files_btn.clicked.connect(self._on_clear_files_clicked)
        self.clear_files_btn.hide()
        self.clear_files_btn.setParent(select_file_container)
        self.clear_files_btn.raise_()
        
        self.select_file_btn.installEventFilter(self)
        self.layout.addWidget(select_file_container, stretch=2)

        self.send_btn = make_btn("Send", self._btn_style(self.GREEN))
        self.send_btn.clicked.connect(self._on_send_btn_clicked)
        self.send_btn.setEnabled(False)
        self.layout.addWidget(self.send_btn, stretch=2)

        # Set size policies
        for btn in [self.service_model_btn, self.display_btn, self.select_file_btn, self.send_btn]:
            btn.setSizePolicy(QSizePolicy.Policy.Preferred, QSizePolicy.Policy.Preferred)

        # Create unified dropdowns
        self._create_dropdowns()

    def _create_dropdowns(self):
        self._create_unified_dropdown()
        self._create_display_dropdown()

    def _create_unified_dropdown(self):
        """Create unified dropdown for service:model selection."""
        parent_window = self.window() or None
        dropdown = QWidget(parent_window)
        dropdown.setWindowFlags(Qt.WindowType.FramelessWindowHint | Qt.WindowType.Tool)
        dropdown.setAttribute(Qt.WidgetAttribute.WA_ShowWithoutActivating)
        dropdown.setStyleSheet("QWidget { background-color: #2a2a2a; border: 1px solid #555; border-radius: 4px; }")
        layout = QVBoxLayout(dropdown)
        layout.setContentsMargins(4, 4, 4, 4)
        layout.setSpacing(2)

        for service, model in self.SERVICE_MODEL_OPTIONS:
            option_btn = QPushButton(f"{service}:{model}")
            option_btn.setStyleSheet("""
                QPushButton { background-color: transparent; color: white; border: none; text-align: left; padding: 6px 12px; font-size: 9pt; }
                QPushButton:hover { background-color: #3d3d3d; }
            """)
            option_btn.clicked.connect(lambda checked, s=service, m=model: self._on_service_model_selected(s, m))
            layout.addWidget(option_btn)

        dropdown.adjustSize()
        dropdown.hide()
        dropdown.installEventFilter(self)
        self.unified_dropdown = dropdown

    def _create_display_dropdown(self):
        """Create dropdown for display field toggling."""
        parent_window = self.window() or None
        dropdown = QWidget(parent_window)
        dropdown.setWindowFlags(Qt.WindowType.FramelessWindowHint | Qt.WindowType.Tool)
        dropdown.setAttribute(Qt.WidgetAttribute.WA_ShowWithoutActivating)
        dropdown.setStyleSheet("QWidget { background-color: #2a2a2a; border: 1px solid #555; border-radius: 4px; }")
        layout = QVBoxLayout(dropdown)
        layout.setContentsMargins(4, 4, 4, 4)
        layout.setSpacing(2)

        self.display_checkboxes = {}
        fields = [
            "core", "composition", "lighting", "style", "technical", 
            "post_processing", "special_elements", "detailed_prompt",
            "grok_imagine_optimized", "gemini_optimized", "flux_optimized", 
            "stable_diffusion_optimized", "video_optimized", "ooc_note"
        ]
        
        self.display_fields = {}
        
        for field in fields:
            btn = QPushButton(f"‚òë {field}")
            btn.setStyleSheet("""
                QPushButton { background-color: transparent; color: white; border: none; text-align: left; padding: 4px 12px; font-size: 9pt; }
                QPushButton:hover { background-color: #3d3d3d; }
            """)
            btn.clicked.connect(lambda checked, f=field: self._on_display_toggle(f))
            layout.addWidget(btn)
            self.display_checkboxes[field] = btn

        dropdown.adjustSize()
        dropdown.hide()
        dropdown.installEventFilter(self)
        self.display_dropdown = dropdown

    def set_display_fields(self, fields: dict):
        self.display_fields = fields.copy()
        if hasattr(self, 'display_checkboxes'):
            for field, btn in self.display_checkboxes.items():
                is_checked = self.display_fields.get(field, True)
                btn.setText(f"{'‚òë' if is_checked else '‚òê'} {field}")

    def _on_display_toggle(self, field: str):
        current = self.display_fields.get(field, True)
        self.display_fields[field] = not current
        self.set_display_fields(self.display_fields)
        self.display_toggled_signal.emit(self.display_fields)


    def eventFilter(self, obj, event):
        """Handle hover events for dropdown menus and clear button positioning."""
        et = event.type()

        # Handle select_file_btn resize to reposition clear button
        if hasattr(self, 'select_file_btn') and obj == self.select_file_btn and et == QEvent.Type.Resize:
            self._update_clear_button_position()

        # Enter events
        if et == QEvent.Type.Enter:
            if obj == self.service_model_btn:
                self._show_dropdown("unified")
            elif obj == self.display_btn:
                self._show_dropdown("display")
            elif obj in [self.unified_dropdown, self.display_dropdown]:
                self.hide_timer.stop()

        # Leave events
        elif et == QEvent.Type.Leave:
            if obj in [self.service_model_btn, self.unified_dropdown, self.display_btn, self.display_dropdown]:
                self.hide_timer.start()

        return super().eventFilter(obj, event)
    
    def _update_clear_button_position(self):
        """Update clear button position to top-right of select_file_btn."""
        if not self.clear_files_btn.isVisible():
            return
        btn_rect = self.select_file_btn.geometry()
        clear_btn_size = 20
        # Position at top-right with small offset
        x = btn_rect.right() - clear_btn_size - 4
        y = btn_rect.top() + 4
        self.clear_files_btn.setGeometry(x, y, clear_btn_size, clear_btn_size)

    def _show_dropdown(self, dropdown_type):
        if self._is_generating: return
        self.hide_timer.stop()
        
        target_dropdown = self.unified_dropdown if dropdown_type == "unified" else self.display_dropdown
        target_btn = self.service_model_btn if dropdown_type == "unified" else self.display_btn
        
        if self.active_dropdown and self.active_dropdown != target_dropdown:
            self.active_dropdown.hide()
        if self.active_dropdown == target_dropdown: return

        self.active_dropdown = target_dropdown
        btn_global_pos = target_btn.mapToGlobal(target_btn.rect().topLeft())
        target_dropdown.move(btn_global_pos.x(), btn_global_pos.y() - target_dropdown.height() - 2)
        target_dropdown.show()
        target_dropdown.raise_()

    def _hide_dropdown(self):
        if self.active_dropdown:
            self.active_dropdown.hide()
            self.active_dropdown = None
            self.active_button = None

    def _on_service_model_selected(self, service: str, model: str):
        """Handle unified service:model selection."""
        self.current_service = service
        self.current_model = model
        self.service_model_btn.setText(f"{service}:{model}")
        self._update_file_controls_state()
        
        self.service_model_selected_signal.emit(service, model)
        self._hide_dropdown()

    def _update_file_controls_state(self):
        """Update state of file controls based on current service and file selection."""
        # Disable file selection for NVIDIA NIM models that don't support vision
        no_file_support = (self.current_service == "NVIDIA NIM"
                           and self.current_model not in self.NIM_VISION_MODELS)
        has_files = self.file_service.has_files()
        
        self.select_file_btn.setEnabled(not no_file_support and not self._is_generating)
        
        if self._is_generating:
            # During generation, this is the Cancel button, so keep it enabled
            self.send_btn.setEnabled(True)
        elif has_files:
            # Disable Send button if files attached and model doesn't support them
            self.send_btn.setEnabled(not no_file_support)
        
        # Show/hide clear button based on file state
        self.clear_files_btn.setVisible(has_files)
        self.clear_files_btn.setEnabled(not self._is_generating)
        if has_files:
            self._update_clear_button_position()

    def _on_send_btn_clicked(self):
        if self._is_generating:
            self.interrupt_signal.emit()
        else:
            self.send_signal.emit()

    def set_generating_state(self, state: bool):
        """Enable or disable actions based on whether AI is currently generating."""
        self._is_generating = state
        self.new_chat_btn.setEnabled(not state)
        self.delete_chat_btn.setEnabled(not state)
        self.service_model_btn.setEnabled(not state)
        self.display_btn.setEnabled(not state)
        
        if state:
            self._hide_dropdown()
            self.update_navigation_buttons(False, False)
            self.send_btn.setText("Cancel")
            self.send_btn.setStyleSheet(self._btn_style(self.RED))
            grey_style = self._btn_style(self.GREY, "4px")
            self.new_chat_btn.setStyleSheet(grey_style)
            self.delete_chat_btn.setStyleSheet(grey_style)
        else:
            self.send_btn.setText("Send")
            self.send_btn.setStyleSheet(self._btn_style(self.GREEN))
            self.new_chat_btn.setStyleSheet(self._btn_style(self.GREEN, "4px"))
            self.delete_chat_btn.setStyleSheet(self._btn_style(self.RED, "4px"))
            
        self._update_file_controls_state()

    def update_text_action_buttons(self, has_content: bool):
        """
        Update Send button enabled state based on input text content.

        Args:
            has_content: True if input field has non-whitespace text, False otherwise
        """
        if self._is_generating:
            self.send_btn.setEnabled(True)
            return

        # Only update if no files attached - files take precedence
        if not self.file_service.has_files():
            self.send_btn.setEnabled(has_content)

    def _on_select_file_clicked(self):
        paths, _ = QFileDialog.getOpenFileNames(self, "Select file(s)", "", "All Files (*)")
        for path in paths: self.file_service.load_file_from_path(path)
        if files := self.file_service.get_files():
            self.select_file_signal.emit(files[0][0] or "", "")
    
    def _on_clear_files_clicked(self):
        """Handle clear files button click."""
        self.file_service.clear_files()
        self.select_file_signal.emit("", "")

    def _upload_drag_enter(self, event):
        """Handle drag enter event for select file button."""
        md = event.mimeData()
        if md.hasUrls():
            for url in md.urls():
                if url.isLocalFile():
                    event.acceptProposedAction()
                    return
        if md.hasImage():
            event.acceptProposedAction()
            return
        event.ignore()

    def _upload_drop(self, event):
        """Handle drop event for upload button - supports multiple files."""
        try:
            md = event.mimeData()
            if md.hasUrls():
                files_loaded = False
                for url in md.urls():
                    if url.isLocalFile():
                        path = url.toLocalFile()
                        if self.file_service.load_file_from_path(path):
                            files_loaded = True
                if files_loaded:
                    # Emit signal with first file's data for backward compatibility
                    files = self.file_service.get_files()
                    if files:
                        b64, _ = files[0]
                        self.select_file_signal.emit(b64 or "", "")
                    event.acceptProposedAction()
                    return
            elif md.hasImage():
                img = md.imageData()
                if img:
                    buf = QBuffer()
                    buf.open(QIODevice.OpenModeFlag.WriteOnly)
                    img.save(buf, "PNG")
                    if self.file_service.load_file_from_data(bytes(buf.data()), "clipboard"):
                        if files := self.file_service.get_files():
                            self.select_file_signal.emit(files[0][0] or "", "")
                        event.acceptProposedAction()
                        return
        except Exception:
            pass
        event.ignore()

    def set_service_model_text(self, service: str, model: str):
        """Set the text of the unified service:model button."""
        self.current_service = service
        self.current_model = model
        self.service_model_btn.setText(f"{service}:{model}")
        self._update_file_controls_state()

    def update_navigation_buttons(self, can_go_left: bool, can_go_right: bool):
        for btn, enabled in [(self.nav_left_btn, can_go_left), (self.nav_right_btn, can_go_right)]:
            btn.setEnabled(enabled)
            btn.setStyleSheet(self._btn_style(self.BLUE if enabled else self.GREY, "4px"))
```

### `core/utils.py`

```python
# core/utils.py
"""Shared utility functions for the application."""

import os
import sys
import subprocess


def reveal_file_in_explorer(filepath: str) -> bool:
    """
    Open the system file explorer and select/highlight the given file.

    Platform behavior:
        Windows: explorer /select,<path>
        macOS:   open -R <path>
        Linux:   xdg-open <parent directory>

    Returns True if the command was launched, False on error or missing file.
    """
    filepath = os.path.normpath(os.path.abspath(filepath))
    if not os.path.exists(filepath):
        return False
    try:
        if sys.platform == "win32":
            subprocess.Popen(["explorer", f"/select,{filepath}"])
        elif sys.platform == "darwin":
            subprocess.Popen(["open", "-R", filepath])
        else:
            subprocess.Popen(["xdg-open", os.path.dirname(filepath)])
        return True
    except Exception:
        return False
```