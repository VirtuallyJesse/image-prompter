### TASK

We are building a new app and project named `Image Assistant`. Provided is a comprehensive pyqt6-gui framework to get us started.

Image Assistant features to implement now:

Feature 1. "The Brain": A comprehensive and detailed system prompt to instruct the model to generate a text prompt for use with generative imaging models by transforming the user's basic idea aka. their Send message. (I have the prompt created already, ready for insertion).

Feature 2. "The Eyes": A second comprehensive and detailed system prompt that is used when an image is attached with the request, which basically instructs the model to do the same but mandates describing the image, or describing it with modifications per the user idea. (Again, I have this fully completed and ready, you do not need to craft.)

These two features need an implementation solution, as we only have one way to define a system prompt currently. We require separation for non-image attatched system prompt, image attatched system prompt, and system prompts that can be defined **per model**. We need a system to handle this diversity as cleanly as possible.

Feature 3. "The Mouth": The extensive system prompts mandates strict output in the form of json fields. These are the fields for reference that the model will return:

- `core`: Subject's physique (height, build, skin tone), clothing/fabric texture (material, weave, color), posture (body angles, limb positions), action (movement vectors, speed), facial expression (muscle contractions, eye shape), gaze direction (eye line, focus point), immediate environment (object placements, distances), camera angle (tilt, height), background objects (types, scales).",
- `composition`: Rule of thirds application (grid placements), foreground/midground/background layering (depth ratios), negative space usage (empty areas), leading lines (directional elements).",
- `lighting`: Source type (natural/artificial, e.g., sun, LED), direction (angles from subject), color temp (Kelvin values), intensity (lux levels), shadow behavior (length, sharpness).",
- `style`: Artistic influences (e.g., photorealism, painterly), color palette (specific hues, saturation), texture rendering (smooth/rough).",
- `technical`: Focal length (mm), aperture (f-stop), shutter speed (seconds), DoF (shallow/deep), lens type (wide-angle/telephoto), resolution (pixels), framing (crop ratios).",
- `post_processing`: Specific filters (e.g., vignette strength), color grading (curves adjustments), sharpening (radius).",
- `special_elements`: Visible particles (size, density), reflections (surfaces, angles), distortions (lens flare, warping).",
- `detailed_prompt`: Verbose natural language detailing entire image.",
- `grok_imagine_optimized`: 60-75 tokens, optimized for Grok models.",
- `gemini_optimized`: 90‚Äì105 tokens, optimized for Gemini models.",
- `flux_optimized`: 140-150 tokens, optimized for Flux models.",
- `stable_diffusion_optimized`: 150-200 tokens, optimized for Stable Diffusion models.",
- `video_optimized`: 70‚Äì80 tokens, action-centric verbs for image-to-video.",

In the app, we need a new configuration menu (open on mouse hover) button which hosts toggles for the **visual display** of these fields in the response panel render for the models output (not touching the reasoning/thinking). All output text will still be captured/saved to raw chat history. This filtering view is only occurring in places where the markdown render currently occurs - basically don't try to interact with streaming. These toggled states should be saved to the `gui_config.json` for persistance of user preference. These fields may change at any time across development, so keep that in mind when designing.

### GOALS

1. A dedicated place where I can easily modify or test different system prompts per model.
2. The new button is stylistically and behaviorally similar to the existing framework buttons.

### NON-GOALS

These are currently out of scope and are for future implementation:

1. Generating the actual images (we do TEXT)
2. Quick-access enhancement modifiers in the form of toggle-able nested buttons that append details to the user's prompt e.g.

```example
  "Genre & Theme": [
  	("cyberpunk", "CYBERPUNK", "üåÜ", "Genre: Neon-drenched cyberpunk with buzzing glows, rain-slick streets reflecting holographic ads, faint lens flares and low-angle shadows‚Äîfuturistic, electric, and rebelliously high-tech."),
```

This will come later.

3. Format the json fields into cleanly segmented blocks, with a copy to clipboard button. This will come later.

### PROJECT 

A sophisticated desktop application that enhances image generation prompts using AI models and provides seamless integration with various image generation APIs with a modern PyQt6 GUI.

### DELIVERABLES

Please output a brief summary including any design choices, and the updated or new files where applicable. You may create new services or modules. If only small changes to existing files are required, please output them in

SEARCH: 

```
...stuff...
``` 

REPLACE:

```
...stuff...
``` 

style blocks.

### CONTEXT

## üéØ Focused Context (Agent-Selected)

**Project Root:** `image-prompter/`
**Files Included:** 8

---

### File Index

1. `app/controller.py`
2. `gui/widgets/response_panel.py`
3. `gui/widgets/action_buttons_panel.py`
4. `core/config.py`
5. `gui/main_window.py`
6. `core/services/gemini_service.py`
7. `core/services/nvidia_nim_service.py`
8. `core/services/file_service.py`

---

### `app/controller.py`

```python
# app/controller.py
"""Application Controller - Orchestrates application logic and connects GUI to services."""
import sys
import base64
from pathlib import Path
from PyQt6.QtWidgets import QApplication, QMessageBox
from PyQt6.QtCore import pyqtSignal, QObject, QTimer

from gui.main_window import MainWindow
from core.config import ConfigManager
from core.services.file_service import FileService
from core.services.gemini_service import GeminiService
from core.services.nvidia_nim_service import NvidiaNimService
from core.services.chat_history_service import ChatHistoryService

DARK_MSGBOX_STYLE = """
    QMessageBox, QLabel { background-color: #1a1a1a; color: #ffffff; }
    QPushButton { background-color: #3d3d3d; color: #ffffff; border: 1px solid #333; padding: 8px; border-radius: 4px; }
    QPushButton:hover { background-color: #4d4d4d; }
"""


class ApplicationController(QObject):
    """Orchestrates the application logic, connecting GUI signals to backend services."""
    append_user_message_signal = pyqtSignal(str, object)
    clear_input_signal = pyqtSignal()
    clear_response_signal = pyqtSignal()

    def __init__(self, app: QApplication):
        super().__init__()
        self.app = app
        self.config_manager = ConfigManager()

        self.file_service = FileService()
        self.services = {"Gemini": GeminiService(), "NVIDIA NIM": NvidiaNimService()}
        self.chat_history_service = ChatHistoryService()

        self.selected_service = getattr(self.config_manager, "current_service", "Gemini")
        self.selected_model = getattr(self.config_manager, "current_model", "Flash")

        self.main_window = MainWindow(self.file_service)
        self.main_window.config_manager = self.config_manager

        for service in self.services.values():
            service.response_generated.connect(self._handle_ai_response)
            service.status_updated.connect(self.main_window.status_signal.emit)
            service.chunk_received.connect(self._handle_stream_chunk)
            service.thinking_chunk_received.connect(self._handle_thinking_chunk)
            service.stream_complete.connect(self._handle_stream_complete)
            service.error_occurred.connect(self._handle_generation_error)

        self._is_streaming = False
        self._is_generating = False

        self.chat_history_service.chat_loaded.connect(self._handle_chat_loaded)
        self._connect_signals()
        self._initialize_ui()

    def _connect_signals(self):
        abp = self.main_window.action_buttons_panel
        ip = self.main_window.input_panel

        abp.select_file_signal.connect(self.handle_select_file)
        abp.send_signal.connect(self.handle_send)
        abp.interrupt_signal.connect(self.handle_interrupt)
        abp.service_model_selected_signal.connect(self.handle_service_model_selected)
        abp.new_chat_signal.connect(self.handle_new_chat)
        abp.delete_chat_signal.connect(self.handle_delete_chat)
        abp.delete_all_chats_signal.connect(self.handle_delete_all_chats)
        abp.navigate_left_signal.connect(self.handle_navigate_left)
        abp.navigate_right_signal.connect(self.handle_navigate_right)

        ip.send_signal.connect(self.handle_send)
        ip.navigate_left_signal.connect(self.handle_navigate_left)
        ip.navigate_right_signal.connect(self.handle_navigate_right)

        self.append_user_message_signal.connect(self.main_window.response_panel.append_user_message)
        self.clear_input_signal.connect(lambda: ip.set_input_text(""))
        self.clear_response_signal.connect(self.main_window.response_panel.clear)

    def _initialize_ui(self):
        self._update_service_model_button_label()
        self.chat_history_service.create_new_chat()
        self._update_navigation_buttons()

    def run(self):
        self.main_window.resize(self.config_manager.window_width, self.config_manager.window_height)
        self.main_window.show()
        sys.exit(self.app.exec())

    # --- Action Handlers ---

    def handle_select_file(self, b64_data: str, filename: str):
        if not self.file_service.has_files():
            self.update_status("No files selected.")

    def handle_interrupt(self):
        if self._is_generating:
            self.update_status("Interrupting generation...")
            active_service = self._get_active_service()
            if hasattr(active_service, 'cancel_generation'):
                active_service.cancel_generation()

    def handle_send(self):
        user_input = self.get_input_text()
        if not user_input.strip() and not self.file_service.has_files():
            return self.update_status("Error: Input cannot be empty.")
        self._process_message(user_input)

    def handle_service_model_selected(self, service: str, model: str):
        self.selected_service = service
        self.selected_model = model
        self.config_manager.current_service = service
        self.config_manager.current_model = model
        self.config_manager.save()
        self._update_service_model_button_label()
        self.update_status(f"Selected: {service} - {model}")

    def handle_new_chat(self):
        if self._is_generating:
            return self.update_status("Cannot create a new chat while generating.")
        if self.chat_history_service.get_current_messages():
            self.chat_history_service.save_current_chat()
        self.chat_history_service.create_new_chat()
        self.clear_response_signal.emit()
        self.clear_input_signal.emit()
        self.update_status("New chat created.")
        self._update_navigation_buttons()

    def handle_delete_chat(self):
        if self._is_generating:
            return self.update_status("Cannot delete chat while generating.")
        current_chat_id = self.chat_history_service.get_current_chat_id()
        if not current_chat_id:
            return self.update_status("No chat to delete.")
        if not self._confirm_dialog("Delete Chat", "Are you sure you want to delete this chat?"):
            return

        if self.chat_history_service.delete_chat(current_chat_id):
            adjacent_id = (self.chat_history_service.get_adjacent_chat_id("left") or
                           self.chat_history_service.get_adjacent_chat_id("right"))
            if adjacent_id:
                self.chat_history_service.load_chat(adjacent_id)
                self.update_status(f"Chat deleted. Loaded chat: {adjacent_id}")
            else:
                self.chat_history_service.create_new_chat()
                self.clear_response_signal.emit()
                self.update_status("Chat deleted. New chat created.")
        else:
            self.update_status("Failed to delete chat.")
        self._update_navigation_buttons()

    def handle_delete_all_chats(self):
        if self._is_generating:
            return self.update_status("Cannot delete all chats while generating.")
        chat_files = self.chat_history_service.get_chat_files()
        if not chat_files:
            return self.update_status("No chats to delete.")
        if not self._confirm_dialog("Delete All Chats", f"Are you sure you want to delete all {len(chat_files)} chats?"):
            return

        if self.chat_history_service.delete_all_chats():
            self.chat_history_service.clear_current_chat()
            self.chat_history_service.create_new_chat()
            self.clear_response_signal.emit()
            self.update_status("All chats deleted. New chat created.")
        else:
            self.update_status("Failed to delete some chats.")
        self._update_navigation_buttons()

    def handle_navigate_left(self):
        self._handle_navigation("left")

    def handle_navigate_right(self):
        self._handle_navigation("right")

    # --- Internal Logic ---

    def _process_message(self, user_input: str):
        if self._is_generating:
            return self.update_status("Please wait for the current response to finish.")

        has_files = self.file_service.has_files()
        if not self.chat_history_service.get_current_chat_id():
            self.chat_history_service.create_new_chat()

        file_data_list, filenames_list = [], None
        if has_files:
            for file_b64, filename in self.file_service.get_files():
                file_data_list.append({
                    'base64': file_b64, 'filename': filename,
                    'mime_type': self._get_mime_type(filename),
                    'file_size': len(base64.b64decode(file_b64))
                })
            if file_data_list:
                filenames_list = [f['filename'] for f in file_data_list]

        display_text = user_input or (
            f"Process file{'s' if len(file_data_list) > 1 else ''}: {', '.join(filenames_list)}"
            if filenames_list else ""
        )

        self.append_user_message_signal.emit(display_text, filenames_list)
        self.chat_history_service.add_message("user", display_text, filenames_list)
        self.clear_input_signal.emit()

        active_service = self._get_active_service()
        self._set_generating_state(True)

        kwargs = {}
        if self.selected_service == "Gemini" and file_data_list:
            kwargs['files_data'] = file_data_list

        active_service.generate_response(
            self.config_manager.default_system_prompt, user_input,
            self.selected_model, self.chat_history_service.get_current_messages()[:-1], **kwargs
        )

        if has_files:
            self.file_service.clear_files()

    def _handle_ai_response(self, response_text: str):
        if not self._is_streaming:
            self.main_window.response_panel.append_assistant_message(response_text)
        self.chat_history_service.add_message("assistant", response_text)
        if chat_id := self.chat_history_service.save_current_chat():
            self.update_status(f"Chat saved: {chat_id}")
        self._is_streaming = False
        self._set_generating_state(False)

    def _handle_generation_error(self, error_message: str):
        self._set_generating_state(False)
        if self._is_streaming:
            self._is_streaming = False
            self.main_window.response_panel.end_stream()

    def _set_generating_state(self, state: bool):
        self._is_generating = state
        self.main_window.action_buttons_panel.set_generating_state(state)
        if not state:
            self._update_navigation_buttons()
            self.main_window.action_buttons_panel.update_text_action_buttons(bool(self.get_input_text().strip()))

    def _handle_stream_chunk(self, chunk: str):
        if not self._is_streaming:
            self._is_streaming = True
            self.main_window.response_panel.start_stream()
        self.main_window.response_panel.append_stream_chunk(chunk)

    def _handle_thinking_chunk(self, chunk: str):
        if not self._is_streaming:
            self._is_streaming = True
            self.main_window.response_panel.start_stream()
        self.main_window.response_panel.append_thinking_chunk(chunk)

    def _handle_stream_complete(self, full_response: str):
        self.main_window.response_panel.end_stream()

    def _handle_navigation(self, direction: str):
        if self._is_generating:
            return self.update_status("Cannot navigate while generating.")

        current_chat_id = self.chat_history_service.get_current_chat_id()
        if current_chat_id and self.chat_history_service.get_current_messages():
            chat_file = Path("chats") / f"{current_chat_id}.json"
            if not chat_file.exists():
                self.chat_history_service.save_current_chat()

        adjacent_id = self.chat_history_service.get_adjacent_chat_id(direction)
        if adjacent_id:
            if self.chat_history_service.load_chat(adjacent_id):
                self.update_status(f"Loaded chat: {adjacent_id}")
            else:
                self.update_status(f"Failed to load chat: {adjacent_id}")
        elif direction == "left":
            self.update_status("No previous chat.")
        else:
            self.handle_new_chat()
        self._update_navigation_buttons()

    def _handle_chat_loaded(self, chat_data: dict):
        self.main_window.response_panel.clear()
        for message in chat_data.get("messages", []):
            role = message.get("role", "")
            content = message.get("content", "")
            filenames = message.get("filenames") or ([message["filename"]] if message.get("filename") else None)

            if role == "user":
                self.append_user_message_signal.emit(content, filenames)
            elif role == "assistant":
                self.main_window.response_panel.append_assistant_message(content)

        self._update_navigation_buttons()
        QTimer.singleShot(0, self.main_window.response_panel.scroll_to_bottom)

    def _update_navigation_buttons(self):
        can_go_left = self.chat_history_service.get_adjacent_chat_id("left") is not None
        can_go_right = self.chat_history_service.get_adjacent_chat_id("right") is not None
        self.main_window.action_buttons_panel.update_navigation_buttons(can_go_left, can_go_right)

    def _update_service_model_button_label(self):
        self.main_window.action_buttons_panel.set_service_model_text(self.selected_service, self.selected_model)

    def _get_active_service(self):
        return self.services.get(self.selected_service, self.services["Gemini"])

    def _confirm_dialog(self, title: str, text: str) -> bool:
        """Show a dark-themed confirmation dialog. Returns True if user confirmed."""
        msg_box = QMessageBox(self.main_window)
        msg_box.setWindowTitle(title)
        msg_box.setText(text)
        msg_box.setStandardButtons(QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No)
        msg_box.setDefaultButton(QMessageBox.StandardButton.No)
        msg_box.setStyleSheet(DARK_MSGBOX_STYLE)
        return msg_box.exec() == QMessageBox.StandardButton.Yes

    def get_input_text(self) -> str:
        return self.main_window.get_input_text()

    def update_status(self, message: str):
        self.main_window.status_signal.emit(message)

    @staticmethod
    def _get_mime_type(filename: str) -> str:
        import mimetypes
        return mimetypes.guess_type(filename)[0] or "application/octet-stream"
```

### `gui/widgets/response_panel.py`

```python
# gui/widgets/response_panel.py
"""
Response Panel - Displays chat history with Gemini responses and user inputs.
Read-only, highlightable for copying, no size constraints.
"""

from typing import Optional, List
import html
import markdown
from PyQt6.QtWidgets import (
    QWidget, QVBoxLayout, QTextEdit, QSizePolicy, QLineEdit, QPushButton, QHBoxLayout
)
from PyQt6.QtCore import Qt, pyqtSignal, QPoint, QTimer
from PyQt6.QtGui import QKeyEvent, QTextCursor


class SearchLineEdit(QLineEdit):
    """Custom QLineEdit with keyboard shortcuts for search widget."""

    def keyPressEvent(self, event: QKeyEvent):
        if event.key() == Qt.Key.Key_Escape:
            # Close the search widget
            self.parent().close_requested.emit()
            event.accept()
        elif event.key() == Qt.Key.Key_Return or event.key() == Qt.Key.Key_Enter:
            # Go to next match
            self.parent().next_requested.emit()
            event.accept()
        else:
            # Default behavior for other keys
            super().keyPressEvent(event)


class SearchWidget(QWidget):
    """A search widget for finding text in the response panel."""

    search_requested = pyqtSignal(str)  # search term
    next_requested = pyqtSignal()
    previous_requested = pyqtSignal()
    close_requested = pyqtSignal()

    def __init__(self, parent=None):
        super().__init__(parent)
        self.setWindowFlags(Qt.WindowType.FramelessWindowHint | Qt.WindowType.Tool)
        self.setStyleSheet("""
            QWidget {
                background-color: #2a2a2a;
                border: 1px solid #555;
                border-radius: 4px;
            }
            QLineEdit {
                background-color: #1e1e1e;
                color: #ffffff;
                border: 1px solid #333;
                border-radius: 4px;
                padding: 4px;
                font-size: 10pt;
            }
            QPushButton {
                background-color: #3d3d3d;
                color: #ffffff;
                border: 1px solid #333;
                border-radius: 4px;
                padding: 4px;
                font-size: 10pt;
            }
            QPushButton:hover { background-color: #4d4d4d; }
            QPushButton:pressed { background-color: #2d2d2d; }
        """)

        layout = QHBoxLayout(self)
        layout.setContentsMargins(8, 8, 8, 8)
        layout.setSpacing(4)

        self.search_input = SearchLineEdit()
        self.search_input.setPlaceholderText("Search...")
        self.search_input.textChanged.connect(self.search_requested.emit)
        layout.addWidget(self.search_input)

        self.prev_btn = QPushButton("‚ñ≤")
        self.prev_btn.setFixedSize(24, 24)
        self.prev_btn.clicked.connect(self.previous_requested.emit)
        layout.addWidget(self.prev_btn)

        self.next_btn = QPushButton("‚ñº")
        self.next_btn.setFixedSize(24, 24)
        self.next_btn.clicked.connect(self.next_requested.emit)
        layout.addWidget(self.next_btn)

        self.close_btn = QPushButton("√ó")
        self.close_btn.setFixedSize(24, 24)
        self.close_btn.clicked.connect(self.close_requested.emit)
        layout.addWidget(self.close_btn)

        self.adjustSize()

    def set_match_count(self, current, total):
        """Update button tooltips with match info."""
        if total > 0:
            self.prev_btn.setToolTip(f"Previous match ({current}/{total})")
            self.next_btn.setToolTip(f"Next match ({current}/{total})")
        else:
            self.prev_btn.setToolTip("No matches")
            self.next_btn.setToolTip("No matches")


class ResponsePanel(QWidget):
    """A panel for displaying chat history."""

    def __init__(self, parent=None):
        super().__init__(parent)
        self.layout = QVBoxLayout(self)
        self.layout.setContentsMargins(0, 0, 0, 0)
        self.layout.setSpacing(10)

        self.response_text = QTextEdit()
        self.response_text.setReadOnly(True)
        self.response_text.setPlainText("")
        self.response_text.setStyleSheet("background-color: #2a2a2a; color: #ffffff; border: 1px solid #333;")
        self.response_text.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Ignored)
        self.response_text.setMinimumHeight(40)
        self.layout.addWidget(self.response_text, stretch=1)

        # Search functionality
        self.search_widget = None
        self.search_matches = []
        self.current_match_index = -1
        
        # Streaming state
        self._is_streaming = False
        self._stream_buffer = ""  # Buffer for current streaming response
        self._thinking_buffer = ""  # Buffer for thinking content
        self._stream_has_thinking = False  # Track if we've received thinking tokens
        
        # Performance: Batched streaming updates
        self._pending_text = ""  # Pending text to be flushed
        self._pending_is_thinking = False  # Type of pending text
        self._update_timer = QTimer()
        self._update_timer.timeout.connect(self._flush_pending_updates)
        self._update_timer.setInterval(50)  # 50ms batch interval
        
        # Performance: Throttled auto-scroll
        self._scroll_timer = QTimer()
        self._scroll_timer.timeout.connect(self._do_scroll)
        self._scroll_timer.setInterval(100)  # 100ms scroll interval
        self._scroll_pending = False
        
        # Track stream start position for re-rendering
        self._stream_start_cursor_pos = 0
        
        # Color constants
        self.THINKING_COLOR = "#4ECDC4"  # Teal for thinking tokens
        self.ASSISTANT_COLOR = "#ffffff"  # White for regular response
        self.USER_COLOR = "#888888"  # Grey for user messages

    def start_stream(self):
        """Prepare panel for streaming (add new message block)."""
        self._is_streaming = True
        self._stream_buffer = ""
        self._thinking_buffer = ""
        self._stream_has_thinking = False
        self._pending_text = ""
        self._pending_is_thinking = False
        # Move cursor to end and record position for later re-rendering
        self.response_text.moveCursor(QTextCursor.MoveOperation.End)
        self._stream_start_cursor_pos = self.response_text.textCursor().position()
        # Start update timer
        self._update_timer.start()
        self._scroll_timer.start()

    def append_stream_chunk(self, text: str):
        """Append regular response chunk in real-time (white color)."""
        if not text:
            return
        self._stream_buffer += text
        # If switching from thinking to response, add visual separator
        if self._stream_has_thinking and self._pending_is_thinking:
            # Flush any pending thinking text first
            self._flush_pending_updates()
            # Add newline separator between thinking and response
            self.response_text.moveCursor(QTextCursor.MoveOperation.End)
            self.response_text.insertHtml('<br>')
        # Queue for batched update
        self._pending_text += text
        self._pending_is_thinking = False
        self._scroll_pending = True

    def append_thinking_chunk(self, text: str):
        """Append thinking chunk in teal color."""
        if not text:
            return
        self._thinking_buffer += text
        self._stream_has_thinking = True
        # Queue for batched update
        self._pending_text += text
        self._pending_is_thinking = True
        self._scroll_pending = True

    def _flush_pending_updates(self):
        """Flush pending text updates to the display (called by timer)."""
        if not self._pending_text:
            return
        color = self.THINKING_COLOR if self._pending_is_thinking else self.ASSISTANT_COLOR
        html_text = f'<span style="color: {color}; white-space: pre-wrap;">{html.escape(self._pending_text).replace(chr(10), "<br>")}</span>'
        self.response_text.moveCursor(QTextCursor.MoveOperation.End)
        self.response_text.insertHtml(html_text)
        self._pending_text = ""

    def _do_scroll(self):
        """Perform throttled auto-scroll (called by timer)."""
        if self._scroll_pending:
            scrollbar = self.response_text.verticalScrollBar()
            scrollbar.setValue(scrollbar.maximum())
            self._scroll_pending = False

    def end_stream(self):
        """Finalize streaming message with proper markdown rendering."""
        if self._is_streaming:
            # Stop timers
            self._update_timer.stop()
            self._scroll_timer.stop()
            # Flush any remaining pending updates
            self._flush_pending_updates()
            
            self._is_streaming = False
            
            # Re-render the streamed content with proper markdown
            self._rerender_stream_with_markdown()
            
            # Add line break after completed message
            self.response_text.moveCursor(QTextCursor.MoveOperation.End)
            self.response_text.insertHtml("<br>")
            
            # Final scroll to bottom
            scrollbar = self.response_text.verticalScrollBar()
            scrollbar.setValue(scrollbar.maximum())
            
            # Reset buffers
            self._stream_buffer = ""
            self._thinking_buffer = ""
            self._stream_has_thinking = False

    def _insert_md(self, text: str, color: str, br: bool = True):
        if not text.strip(): return
        self.response_text.moveCursor(QTextCursor.MoveOperation.End)
        html = f'<span style="color: {color};">{markdown.markdown(text, extensions=["extra", "codehilite", "nl2br"])}</span>'
        self.response_text.insertHtml(html + ('<br>' if br else ''))

    def _rerender_stream_with_markdown(self):
        """Remove raw streamed text and replace with markdown-rendered version."""
        cursor = self.response_text.textCursor()
        cursor.setPosition(self._stream_start_cursor_pos)
        cursor.movePosition(QTextCursor.MoveOperation.End, QTextCursor.MoveMode.KeepAnchor)
        cursor.removeSelectedText()
        
        self._insert_md(self._thinking_buffer, self.THINKING_COLOR, br=bool(self._stream_buffer.strip()))
        self._insert_md(self._stream_buffer, self.ASSISTANT_COLOR, br=False)

    def show_search(self):
        """Show the search widget."""
        if self.search_widget is None:
            self.search_widget = SearchWidget(self.window())
            self.search_widget.search_requested.connect(self.perform_search)
            self.search_widget.next_requested.connect(self.next_match)
            self.search_widget.previous_requested.connect(self.previous_match)
            self.search_widget.close_requested.connect(self.hide_search)

        # Position in top-right
        panel_rect = self.geometry()
        widget_size = self.search_widget.sizeHint()
        x = panel_rect.right() - widget_size.width() - 10
        y = panel_rect.top() + 10
        self.search_widget.move(self.mapToGlobal(panel_rect.topLeft()) + QPoint(x, y))
        self.search_widget.show()
        self.search_widget.raise_()
        self.search_widget.activateWindow()
        # Set focus after the widget is fully shown and activated
        QTimer.singleShot(10, lambda: self.search_widget.search_input.setFocus())

    def hide_search(self):
        """Hide the search widget."""
        if self.search_widget:
            self.search_widget.hide()
            self.clear_search_highlights()

    def perform_search(self, term: str):
        """
        Perform case-insensitive search for the given term in the response text.

        Finds all occurrences of the term, stores their positions, and highlights the first match.
        If no matches found, clears any existing highlights.

        Args:
            term: The search term to find
        """
        if not term:
            self.clear_search_highlights()
            return

        # Get plain text for searching
        plain_text = self.response_text.toPlainText()
        self.search_matches = []
        start = 0
        term_lower = term.lower()

        while True:
            pos = plain_text.lower().find(term_lower, start)
            if pos == -1:
                break
            self.search_matches.append((pos, pos + len(term)))
            start = pos + 1

        if self.search_matches:
            self.current_match_index = 0
            self.update_highlights()
            self.scroll_to_match(0)
        else:
            self.clear_search_highlights()

        self.update_search_widget()

    def navigate_match(self, step: int):
        """Navigate through search matches by step (+1 or -1)."""
        if self.search_matches:
            self.current_match_index = (self.current_match_index + step) % len(self.search_matches)
            self.update_highlights()
            self.scroll_to_match(self.current_match_index)
            self.update_search_widget()

    def next_match(self):
        self.navigate_match(1)

    def previous_match(self):
        self.navigate_match(-1)

    def update_highlights(self):
        """
        Update search highlights using QTextEdit extra selections.

        Applies different highlighting: yellow background for current match,
        cyan background for other matches. Clears previous highlights first.
        """
        from PyQt6.QtGui import QTextCharFormat

        self.response_text.setExtraSelections([])
        if not self.search_matches:
            return

        selections = []
        for i, (start, end) in enumerate(self.search_matches):
            cursor = QTextCursor(self.response_text.document())
            cursor.setPosition(start)
            cursor.setPosition(end, QTextCursor.MoveMode.KeepAnchor)

            selection = QTextEdit.ExtraSelection()
            selection.cursor = cursor

            format = QTextCharFormat()
            if i == self.current_match_index:
                # Current match - yellow background, black text
                format.setBackground(Qt.GlobalColor.yellow)
                format.setForeground(Qt.GlobalColor.black)
            else:
                # Other matches - light blue background
                format.setBackground(Qt.GlobalColor.cyan)

            selection.format = format
            selections.append(selection)

        self.response_text.setExtraSelections(selections)

    def clear_search_highlights(self):
        self.response_text.setExtraSelections([])
        self.search_matches.clear()
        self.current_match_index = -1
        self.update_search_widget()

    def scroll_to_match(self, index):
        """
        Scroll the text edit to make the specified match visible.

        Args:
            index: Index of the match in self.search_matches to scroll to
        """
        if 0 <= index < len(self.search_matches):
            start, end = self.search_matches[index]
            cursor = self.response_text.textCursor()
            cursor.setPosition(start)
            self.response_text.setTextCursor(cursor)
            self.response_text.ensureCursorVisible()

    def update_search_widget(self):
        """
        Update the search widget with current match count information.

        Displays current match number and total matches in the widget tooltips.
        """
        if self.search_widget:
            if self.search_matches:
                current = self.current_match_index + 1
                total = len(self.search_matches)
            else:
                current = 0
                total = 0
            self.search_widget.set_match_count(current, total)

    def append_user_message(self, text: str, filenames: Optional[List[str]] = None):
        """Append a user message in grey color."""
        display_text = text
        if filenames:
            display_text = f"{text} [{', '.join(filenames)}]"
        html_text = f'<span style="color: #888888;">{html.escape(display_text).replace(chr(10), "<br>")}</span><br>'
        self.response_text.moveCursor(QTextCursor.MoveOperation.End)
        self.response_text.insertHtml(html_text)

    def append_assistant_message(self, text: str):
        import re
        if match := re.search(r'<thinking>\n?(.*?)\n?</thinking>\n?', text, re.DOTALL):
            self._insert_md(match.group(1), self.THINKING_COLOR, br=bool(text.strip()))
            self._insert_md(text[match.end():].lstrip('\n'), self.ASSISTANT_COLOR)
        else:
            self._insert_md(text, self.ASSISTANT_COLOR)

    def scroll_to_bottom(self):
        """Scroll the response text to the bottom."""
        scrollbar = self.response_text.verticalScrollBar()
        scrollbar.setValue(scrollbar.maximum())

    def clear(self):
        """Clear the response area."""
        self.response_text.clear()
```

### `gui/widgets/action_buttons_panel.py`

```python
# gui/widgets/action_buttons_panel.py
"""
Action Buttons Panel - Contains action buttons for the chat framework GUI.
"""

from PyQt6.QtWidgets import QWidget, QHBoxLayout, QPushButton, QSizePolicy, QFileDialog, QVBoxLayout, QGridLayout
from PyQt6.QtCore import pyqtSignal, Qt, QBuffer, QIODevice, QTimer, QEvent
from PyQt6.QtGui import QCursor



class ActionButtonsPanel(QWidget):
    """A panel containing all action buttons for the chat framework."""

    # Signals
    interrupt_signal = pyqtSignal()
    service_model_selected_signal = pyqtSignal(str, str)  # service, model
    select_file_signal = pyqtSignal(str, str)  # base64, filename
    send_signal = pyqtSignal()
    new_chat_signal = pyqtSignal()
    delete_chat_signal = pyqtSignal()
    delete_all_chats_signal = pyqtSignal()
    navigate_left_signal = pyqtSignal()
    navigate_right_signal = pyqtSignal()

    # Service to available models mapping
    SERVICE_MODELS = {
        "Gemini": ["Flash", "Pro"],
        "NVIDIA NIM": ["DeepSeek V3.2", "Kimi K2"]
    }

    SERVICE_MODEL_OPTIONS = [(s, m) for s, models in SERVICE_MODELS.items() for m in models]

    def __init__(self, file_service, parent=None):
        super().__init__(parent)
        self.file_service = file_service
        self.file_service.files_updated.connect(self._update_file_controls_state)
        self.file_service.files_cleared.connect(self._update_file_controls_state)
        
        self._is_generating = False

        # Hover menu state
        self.active_dropdown = None
        self.hide_timer = QTimer()
        self.hide_timer.setInterval(250)
        self.hide_timer.timeout.connect(self._hide_dropdown)

        self.layout = QHBoxLayout(self)
        self.layout.setContentsMargins(0, 0, 0, 0)

        # Current selections
        self.current_service = "Gemini"
        self.current_model = "Flash"

        self._create_buttons()

    BLUE = ("#1E88E5", "#2A9BF8", "#1966C2")
    GREEN = ("#4CAF50", "#5CBF60", "#45A049")
    RED = ("#F44336", "#EF5350", "#D32F2F")
    GREY = ("#9E9E9E", "#BDBDBD", "#757575")
    ORANGE = ("#FF6B35", "#FF8C5A", "#E5562A")

    @staticmethod
    def _btn_style(colors, padding="8px"):
        bg, hover, pressed = colors
        return f"""
            QPushButton {{ background-color: {bg}; color: white; font-weight: bold; font-size: 10pt; border: 2px solid {bg}; border-radius: 4px; padding: {padding}; }}
            QPushButton:hover {{ background-color: {hover}; border-color: {hover}; }}
            QPushButton:pressed {{ background-color: {pressed}; border-color: {pressed}; }}
            QPushButton:disabled {{ background-color: #CCCCCC; color: #666666; border-color: #CCCCCC; }}
        """

    def _create_buttons(self):
        def make_btn(text, style, tooltip=""):
            btn = QPushButton(text)
            btn.setStyleSheet(style)
            btn.setCursor(QCursor(Qt.CursorShape.PointingHandCursor))
            btn.setFocusPolicy(Qt.FocusPolicy.NoFocus)
            if tooltip: btn.setToolTip(tooltip)
            return btn

        self.service_model_btn = make_btn(f"{self.current_service}:{self.current_model}", self._btn_style(self.BLUE))
        self.service_model_btn.installEventFilter(self)
        self.layout.addWidget(self.service_model_btn, stretch=2)

        chat_mgmt_widget = QWidget()
        chat_mgmt_layout = QGridLayout(chat_mgmt_widget)
        chat_mgmt_layout.setContentsMargins(0, 0, 0, 0)
        chat_mgmt_layout.setSpacing(2)

        self.new_chat_btn = make_btn("üÜï", self._btn_style(self.GREEN, "4px"), tooltip="New Chat")
        self.new_chat_btn.clicked.connect(self.new_chat_signal.emit)
        chat_mgmt_layout.addWidget(self.new_chat_btn, 0, 0)

        self.delete_chat_btn = make_btn("üóëÔ∏è", self._btn_style(self.RED, "4px"), tooltip="Delete Chat")
        self.delete_chat_btn.clicked.connect(self.delete_chat_signal.emit)
        chat_mgmt_layout.addWidget(self.delete_chat_btn, 0, 1)

        self.nav_left_btn = make_btn("‚óÄ", "", tooltip="Previous Chat")
        self.nav_left_btn.clicked.connect(self.navigate_left_signal.emit)
        chat_mgmt_layout.addWidget(self.nav_left_btn, 1, 0)

        self.nav_right_btn = make_btn("‚ñ∂", "", tooltip="Next Chat")
        self.nav_right_btn.clicked.connect(self.navigate_right_signal.emit)
        chat_mgmt_layout.addWidget(self.nav_right_btn, 1, 1)
        
        self.update_navigation_buttons(False, False)

        chat_mgmt_widget.setSizePolicy(QSizePolicy.Policy.Preferred, QSizePolicy.Policy.Preferred)
        chat_mgmt_widget.setMaximumHeight(40)
        for btn in [self.new_chat_btn, self.delete_chat_btn, self.nav_left_btn, self.nav_right_btn]:
            btn.setSizePolicy(QSizePolicy.Policy.Preferred, QSizePolicy.Policy.Preferred)
        
        self.layout.addWidget(chat_mgmt_widget, stretch=1)

        select_file_container = QWidget()
        select_file_container.setSizePolicy(QSizePolicy.Policy.Preferred, QSizePolicy.Policy.Preferred)
        select_file_container_layout = QHBoxLayout(select_file_container)
        select_file_container_layout.setContentsMargins(0, 0, 0, 0)
        select_file_container_layout.setSpacing(0)
        
        self.select_file_btn = make_btn("Attach", self._btn_style(self.ORANGE))
        self.select_file_btn.setAcceptDrops(True)
        self.select_file_btn.dragEnterEvent = self._upload_drag_enter
        self.select_file_btn.dropEvent = self._upload_drop
        self.select_file_btn.clicked.connect(self._on_select_file_clicked)
        select_file_container_layout.addWidget(self.select_file_btn)
        
        self.clear_files_btn = make_btn("√ó", self._btn_style(self.RED, "2px 6px"), tooltip="Clear all files")
        self.clear_files_btn.setStyleSheet(self.clear_files_btn.styleSheet() + "QPushButton { min-width: 20px; max-width: 20px; min-height: 20px; max-height: 20px; font-size: 12pt; }")
        self.clear_files_btn.clicked.connect(self._on_clear_files_clicked)
        self.clear_files_btn.hide()
        self.clear_files_btn.setParent(select_file_container)
        self.clear_files_btn.raise_()
        
        self.select_file_btn.installEventFilter(self)
        self.layout.addWidget(select_file_container, stretch=2)

        self.send_btn = make_btn("Send", self._btn_style(self.GREEN))
        self.send_btn.clicked.connect(self._on_send_btn_clicked)
        self.send_btn.setEnabled(False)
        self.layout.addWidget(self.send_btn, stretch=2)

        # Set size policies
        for btn in [self.service_model_btn, self.select_file_btn, self.send_btn]:
            btn.setSizePolicy(QSizePolicy.Policy.Preferred, QSizePolicy.Policy.Preferred)

        # Create unified dropdown
        self._create_unified_dropdown()

    def _create_unified_dropdown(self):
        """Create unified dropdown for service:model selection."""
        parent_window = self.window() or None
        dropdown = QWidget(parent_window)
        dropdown.setWindowFlags(Qt.WindowType.FramelessWindowHint | Qt.WindowType.Tool)
        dropdown.setAttribute(Qt.WidgetAttribute.WA_ShowWithoutActivating)
        dropdown.setStyleSheet("QWidget { background-color: #2a2a2a; border: 1px solid #555; border-radius: 4px; }")
        layout = QVBoxLayout(dropdown)
        layout.setContentsMargins(4, 4, 4, 4)
        layout.setSpacing(2)

        for service, model in self.SERVICE_MODEL_OPTIONS:
            option_btn = QPushButton(f"{service}:{model}")
            option_btn.setStyleSheet("""
                QPushButton { background-color: transparent; color: white; border: none; text-align: left; padding: 6px 12px; font-size: 9pt; }
                QPushButton:hover { background-color: #3d3d3d; }
            """)
            option_btn.clicked.connect(lambda checked, s=service, m=model: self._on_service_model_selected(s, m))
            layout.addWidget(option_btn)

        dropdown.adjustSize()
        dropdown.hide()
        dropdown.installEventFilter(self)
        self.unified_dropdown = dropdown


    def eventFilter(self, obj, event):
        """Handle hover events for dropdown menus and clear button positioning."""
        et = event.type()

        # Handle select_file_btn resize to reposition clear button
        if hasattr(self, 'select_file_btn') and obj == self.select_file_btn and et == QEvent.Type.Resize:
            self._update_clear_button_position()

        # Enter events
        if et == QEvent.Type.Enter:
            if obj == self.service_model_btn:
                self._show_dropdown("unified")
            elif obj == self.unified_dropdown:
                self.hide_timer.stop()

        # Leave events
        elif et == QEvent.Type.Leave:
            if obj in [self.service_model_btn, self.unified_dropdown]:
                self.hide_timer.start()

        return super().eventFilter(obj, event)
    
    def _update_clear_button_position(self):
        """Update clear button position to top-right of select_file_btn."""
        if not self.clear_files_btn.isVisible():
            return
        btn_rect = self.select_file_btn.geometry()
        clear_btn_size = 20
        # Position at top-right with small offset
        x = btn_rect.right() - clear_btn_size - 4
        y = btn_rect.top() + 4
        self.clear_files_btn.setGeometry(x, y, clear_btn_size, clear_btn_size)

    def _show_dropdown(self, dropdown_type):
        if dropdown_type != "unified": return
        if self._is_generating: return
        self.hide_timer.stop()
        if self.active_dropdown and self.active_dropdown != self.unified_dropdown:
            self.active_dropdown.hide()
        if self.active_dropdown == self.unified_dropdown: return

        self.active_dropdown = self.unified_dropdown
        btn_global_pos = self.service_model_btn.mapToGlobal(self.service_model_btn.rect().topLeft())
        self.unified_dropdown.move(btn_global_pos.x(), btn_global_pos.y() - self.unified_dropdown.height() - 2)
        self.unified_dropdown.show()
        self.unified_dropdown.raise_()

    def _hide_dropdown(self):
        if self.active_dropdown:
            self.active_dropdown.hide()
            self.active_dropdown = None
            self.active_button = None

    def _on_service_model_selected(self, service: str, model: str):
        """Handle unified service:model selection."""
        self.current_service = service
        self.current_model = model
        self.service_model_btn.setText(f"{service}:{model}")
        self._update_file_controls_state()
        
        self.service_model_selected_signal.emit(service, model)
        self._hide_dropdown()

    def _update_file_controls_state(self):
        """Update state of file controls based on current service and file selection."""
        # Disable file selection for Nvidia Nim as it doesn't support attachments
        is_nim = self.current_service == "NVIDIA NIM"
        has_files = self.file_service.has_files()
        
        self.select_file_btn.setEnabled(not is_nim and not self._is_generating)
        
        if self._is_generating:
            # During generation, this is the Cancel button, so keep it enabled
            self.send_btn.setEnabled(True)
        elif has_files:
            # Disable Send button if files attached and NVIDIA NIM selected
            self.send_btn.setEnabled(not is_nim)
        
        # Show/hide clear button based on file state
        self.clear_files_btn.setVisible(has_files)
        self.clear_files_btn.setEnabled(not self._is_generating)
        if has_files:
            self._update_clear_button_position()

    def _on_send_btn_clicked(self):
        if self._is_generating:
            self.interrupt_signal.emit()
        else:
            self.send_signal.emit()

    def set_generating_state(self, state: bool):
        """Enable or disable actions based on whether AI is currently generating."""
        self._is_generating = state
        self.new_chat_btn.setEnabled(not state)
        self.delete_chat_btn.setEnabled(not state)
        self.service_model_btn.setEnabled(not state)
        
        if state:
            self._hide_dropdown()
            self.update_navigation_buttons(False, False)
            self.send_btn.setText("Cancel")
            self.send_btn.setStyleSheet(self._btn_style(self.RED))
            grey_style = self._btn_style(self.GREY, "4px")
            self.new_chat_btn.setStyleSheet(grey_style)
            self.delete_chat_btn.setStyleSheet(grey_style)
        else:
            self.send_btn.setText("Send")
            self.send_btn.setStyleSheet(self._btn_style(self.GREEN))
            self.new_chat_btn.setStyleSheet(self._btn_style(self.GREEN, "4px"))
            self.delete_chat_btn.setStyleSheet(self._btn_style(self.RED, "4px"))
            
        self._update_file_controls_state()

    def update_text_action_buttons(self, has_content: bool):
        """
        Update Send button enabled state based on input text content.

        Args:
            has_content: True if input field has non-whitespace text, False otherwise
        """
        if self._is_generating:
            self.send_btn.setEnabled(True)
            return

        # Only update if no files attached - files take precedence
        if not self.file_service.has_files():
            self.send_btn.setEnabled(has_content)

    def _on_select_file_clicked(self):
        paths, _ = QFileDialog.getOpenFileNames(self, "Select file(s)", "", "All Files (*)")
        for path in paths: self.file_service.load_file_from_path(path)
        if files := self.file_service.get_files():
            self.select_file_signal.emit(files[0][0] or "", "")
    
    def _on_clear_files_clicked(self):
        """Handle clear files button click."""
        self.file_service.clear_files()
        self.select_file_signal.emit("", "")

    def _upload_drag_enter(self, event):
        """Handle drag enter event for select file button."""
        md = event.mimeData()
        if md.hasUrls():
            for url in md.urls():
                if url.isLocalFile():
                    event.acceptProposedAction()
                    return
        if md.hasImage():
            event.acceptProposedAction()
            return
        event.ignore()

    def _upload_drop(self, event):
        """Handle drop event for upload button - supports multiple files."""
        try:
            md = event.mimeData()
            if md.hasUrls():
                files_loaded = False
                for url in md.urls():
                    if url.isLocalFile():
                        path = url.toLocalFile()
                        if self.file_service.load_file_from_path(path):
                            files_loaded = True
                if files_loaded:
                    # Emit signal with first file's data for backward compatibility
                    files = self.file_service.get_files()
                    if files:
                        b64, _ = files[0]
                        self.select_file_signal.emit(b64 or "", "")
                    event.acceptProposedAction()
                    return
            elif md.hasImage():
                img = md.imageData()
                if img:
                    buf = QBuffer()
                    buf.open(QIODevice.OpenModeFlag.WriteOnly)
                    img.save(buf, "PNG")
                    if self.file_service.load_file_from_data(bytes(buf.data()), "clipboard"):
                        if files := self.file_service.get_files():
                            self.select_file_signal.emit(files[0][0] or "", "")
                        event.acceptProposedAction()
                        return
        except Exception:
            pass
        event.ignore()

    def set_service_model_text(self, service: str, model: str):
        """Set the text of the unified service:model button."""
        self.current_service = service
        self.current_model = model
        self.service_model_btn.setText(f"{service}:{model}")
        self._update_file_controls_state()

    def update_navigation_buttons(self, can_go_left: bool, can_go_right: bool):
        for btn, enabled in [(self.nav_left_btn, can_go_left), (self.nav_right_btn, can_go_right)]:
            btn.setEnabled(enabled)
            btn.setStyleSheet(self._btn_style(self.BLUE if enabled else self.GREY, "4px"))
```

### `core/config.py`

```python
"""Configuration Manager for PyQt6 GUI Framework."""
import os
import json

_DEFAULTS = {
    "window_width": 1200,
    "window_height": 800,
    "theme": "dark",
    "current_service": "Gemini",
    "current_model": "Flash",
    "default_system_prompt": "You are a helpful AI assistant."
}

class ConfigManager:
    """Manages GUI configuration values and local gui_config.json persistence."""

    def __init__(self, config_file: str = "gui_config.json"):
        self.config_file = config_file
        self.__dict__.update(_DEFAULTS)
        self._load_config()

    def _load_config(self) -> None:
        if not os.path.exists(self.config_file):
            return
        try:
            with open(self.config_file, 'r') as f:
                config = json.load(f)
                for k in _DEFAULTS:
                    setattr(self, k, config.get(k, getattr(self, k)))
                if "default_service" in config and "current_service" not in config:
                    self.current_service = config["default_service"]
                if "service_models" in config and "current_model" not in config:
                    self.current_model = config.get("service_models", {}).get(self.current_service, self.current_model)
        except Exception:
            pass

    def save(self) -> None:
        try:
            with open(self.config_file, 'w') as f:
                json.dump({k: getattr(self, k) for k in _DEFAULTS}, f, indent=2)
        except Exception:
            pass
```

### `gui/main_window.py`

```python
# gui/main_window.py
"""
Main Window GUI - Constructs the main application window and its layout.
"""
from PyQt6.QtWidgets import QApplication, QMainWindow, QWidget, QVBoxLayout, QLabel, QGridLayout
from PyQt6.QtCore import pyqtSignal, Qt
from PyQt6.QtGui import QIcon, QShortcut, QKeySequence
from gui.widgets.action_buttons_panel import ActionButtonsPanel
from gui.widgets.input_panel import InputPanel
from gui.widgets.response_panel import ResponsePanel




# ========== Main Window Class ==========

class MainWindow(QMainWindow):
    # Signals for communication with main logic
    status_signal = pyqtSignal(str)

    def __init__(self, file_service):
        super().__init__()
        self.file_service = file_service
        self.file_service.files_updated.connect(self._on_files_updated)
        self.file_service.status_updated.connect(self.status_signal.emit)
        self.file_service.files_cleared.connect(self._on_files_cleared)
        self.setWindowTitle("PyQt6 Chat Framework")
        self.setWindowIcon(QIcon("assets/icons/app_icon.ico"))
        self.setStyleSheet("""
            QMainWindow, QStatusBar { background-color: #1a1a1a; }
            QLabel { color: #ffffff; font-family: Arial; }
            QPushButton { background-color: #3d3d3d; color: #ffffff; border: 1px solid #333; padding: 8px; font-family: Arial; font-size: 9pt; border-radius: 4px; }
            QPushButton:hover { background-color: #4d4d4d; }
            QPushButton:pressed { background-color: #2d2d2d; }
            QTextEdit { background-color: #1e1e1e; color: #ffffff; border: 1px solid #333; font-family: Consolas; font-size: 9pt; }
            QStatusBar { color: #888888; font-size: 8pt; }
        """)

        central = QWidget()
        self.setCentralWidget(central)
        main_layout = QGridLayout(central)
        main_layout.setContentsMargins(10, 10, 10, 5)

        main_panel = QWidget()
        main_panel_layout = QVBoxLayout(main_panel)
        main_panel_layout.setContentsMargins(0, 0, 0, 0)
        main_panel_layout.setSpacing(10)

        # Add main panel to grid
        main_layout.addWidget(main_panel, 0, 0)

        self._build_main_panel(main_panel_layout)

        # --- Custom Footer ---
        # Status label (bottom-left)
        self.status_label = QLabel("Ready")
        self.status_label.setStyleSheet("color: #888; font-size: 8pt;")
        self.status_signal.connect(self.status_label.setText)
        main_layout.addWidget(self.status_label, 1, 0, Qt.AlignmentFlag.AlignLeft)

        # --- End Custom Footer ---

        self.status_signal.emit("Ready")

        # Set up keyboard shortcuts
        self._setup_shortcuts()


    def _setup_shortcuts(self):
        """Set up global keyboard shortcuts."""
        # Ctrl+F for search
        search_shortcut = QShortcut(QKeySequence.StandardKey.Find, self)
        search_shortcut.activated.connect(self.response_panel.show_search)

        # Ctrl+Left for navigate left
        nav_left_shortcut = QShortcut(QKeySequence("Ctrl+Left"), self)
        nav_left_shortcut.activated.connect(lambda: self.action_buttons_panel.navigate_left_signal.emit())

        # Ctrl+Right for navigate right
        nav_right_shortcut = QShortcut(QKeySequence("Ctrl+Right"), self)
        nav_right_shortcut.activated.connect(lambda: self.action_buttons_panel.navigate_right_signal.emit())

        # Ctrl+D for delete all chats
        delete_all_shortcut = QShortcut(QKeySequence("Ctrl+D"), self)
        delete_all_shortcut.activated.connect(lambda: self.action_buttons_panel.delete_all_chats_signal.emit())


    def _build_main_panel(self, layout):
        self.main_panel_layout = layout  # Store reference to main panel layout

        # Response panel
        self.response_panel = ResponsePanel()
        layout.addWidget(self.response_panel)

        # Input panel
        self.input_panel = InputPanel()
        layout.addWidget(self.input_panel)

        # Action buttons panel
        self.action_buttons_panel = ActionButtonsPanel(self.file_service)
        layout.addWidget(self.action_buttons_panel)

        self.input_panel.text_content_changed_signal.connect(self.action_buttons_panel.update_text_action_buttons)

        self.main_panel_layout.setStretchFactor(self.response_panel, 1)
        self.main_panel_layout.setStretchFactor(self.input_panel, 0)
        self.main_panel_layout.setStretchFactor(self.action_buttons_panel, 0)

    def _on_files_cleared(self):
        self.action_buttons_panel.select_file_signal.emit("", "")

    def _on_files_updated(self, filenames):
        """Handle files updated signal - update status bar with file list."""
        if not filenames:
            self.status_signal.emit("No files selected.")
            return
        
        if len(filenames) == 1:
            self.status_signal.emit(f"File ready: {filenames[0]}")
        else:
            # Show first few filenames, then count
            if len(filenames) <= 3:
                files_str = ", ".join(filenames)
                self.status_signal.emit(f"Files ready: {files_str}")
            else:
                files_str = ", ".join(filenames[:3])
                self.status_signal.emit(f"Files ready: {files_str}... ({len(filenames)} total)")

    def keyPressEvent(self, event):
        """Handle keyboard events - Ctrl+V for clipboard paste."""
        modifiers = event.modifiers()

        # Check for Ctrl+V (or Cmd+V on Mac)
        if (modifiers & Qt.KeyboardModifier.ControlModifier) and event.key() == Qt.Key.Key_V:
            # Check if clipboard has image data
            clipboard = QApplication.clipboard()
            mime_data = clipboard.mimeData()

            if mime_data.hasImage():
                img = clipboard.image()
                if not img.isNull():
                    # Convert QImage to bytes
                    from PyQt6.QtCore import QBuffer, QIODevice
                    buf = QBuffer()
                    buf.open(QIODevice.OpenModeFlag.WriteOnly)
                    img.save(buf, "PNG")
                    self.file_service.load_file_from_data(bytes(buf.data()), "clipboard.png")
                    return

        # Call parent implementation for other key events
        super().keyPressEvent(event)

    def get_input_text(self) -> str:
        """Get the text from the input text edit."""
        return self.input_panel.get_input_text()

    def closeEvent(self, event):
        """Handle window close event to save window size."""
        if getattr(self, 'config_manager', None):
            self.config_manager.window_width = self.width()
            self.config_manager.window_height = self.height()
            self.config_manager.save()
        event.accept()
```

### `core/services/gemini_service.py`

```python
import os
import base64
from PyQt6.QtCore import pyqtSignal
from google import genai
from google.genai import types
from core.services.base_service import BaseAIService, BaseAIWorker

SAFETY_CATEGORIES = [
    "HARM_CATEGORY_HATE_SPEECH", "HARM_CATEGORY_DANGEROUS_CONTENT",
    "HARM_CATEGORY_SEXUALLY_EXPLICIT", "HARM_CATEGORY_HARASSMENT",
]


class GeminiWorker(BaseAIWorker):
    """Worker thread to handle streaming API calls to Google Gemini."""
    retry_with_new_key = pyqtSignal(str, int)

    def __init__(self, client, model_name, contents, config, attempt_count=0):
        super().__init__()
        self.client = client
        self.model_name = model_name
        self.contents = contents
        self.config = config
        self.attempt_count = attempt_count

    def run(self):
        try:
            response_stream = self.client.models.generate_content_stream(
                model=self.model_name, contents=self.contents, config=self.config
            )
            full_response, full_thinking = "", ""

            for chunk in response_stream:
                if self._is_cancelled:
                    break
                if hasattr(chunk, 'candidates') and chunk.candidates:
                    for candidate in chunk.candidates:
                        if hasattr(candidate, 'content') and candidate.content:
                            for part in candidate.content.parts:
                                if hasattr(part, 'thought') and part.thought and hasattr(part, 'text') and part.text:
                                    self.thinking_chunk.emit(part.text)
                                    full_thinking += part.text
                                elif hasattr(part, 'text') and part.text:
                                    self.chunk.emit(part.text)
                                    full_response += part.text
                elif hasattr(chunk, 'text') and chunk.text:
                    self.chunk.emit(chunk.text)
                    full_response += chunk.text

            if self._is_cancelled:
                self.error.emit("Generation interrupted by user.")
                return

            self._emit_result(full_response, full_thinking)

        except Exception as e:
            error_message = str(e)
            if "429" in error_message or "rate limit" in error_message.lower():
                self.retry_with_new_key.emit(error_message, self.attempt_count)
            else:
                self.error.emit(error_message)


class GeminiService(BaseAIService):
    """Service for interacting with Google Gemini API using google-genai SDK."""

    MODEL_MAP = {"Flash": "gemini-2.5-flash", "Pro": "gemini-2.5-pro"}
    MAX_FILE_SIZE = 15 * 1024 * 1024  # 15MB

    def __init__(self):
        super().__init__()
        self.api_keys = []
        self.current_key_index = 0
        self.rotation_attempts = 0
        self.client = None
        self._pending_request = None

        rotate_keys = os.environ.get("GEMINI_ROTATE_API_KEY")
        single_key = os.environ.get("GEMINI_API_KEY")
        if rotate_keys:
            self.api_keys = [k.strip() for k in rotate_keys.split(",") if k.strip()]
        elif single_key:
            self.api_keys = [single_key]

        if self.api_keys:
            try:
                self.client = genai.Client(api_key=self.api_keys[0])
            except Exception as e:
                print(f"Failed to initialize Gemini Client: {e}")

    def _emit_error(self, message: str):
        """Emit error to both status and error signals, clear pending request."""
        self.status_updated.emit(f"Error: {message}")
        self.error_occurred.emit(message)
        self._pending_request = None

    def _build_and_start(self):
        """Build request from pending parameters and start worker."""
        if not self._pending_request or not self.client:
            return

        params = self._pending_request
        files_data = params.get('files_data')
        user_input = params['user_input']

        if not user_input.strip() and not files_data:
            return self._emit_error("Input cannot be empty.")

        if files_data:
            for fd in files_data:
                if fd.get('file_size', 0) > self.MAX_FILE_SIZE:
                    return self._emit_error(f"File '{fd.get('filename', 'Unknown')}' too large. Maximum size: 15MB.")

        # Build conversation history
        contents = []
        for msg in (params.get('conversation_history') or []):
            role, content = msg.get("role", ""), msg.get("content", "")
            if not content:
                continue
            api_role = "model" if role == "assistant" else "user"
            try:
                contents.append(types.Content(role=api_role, parts=[types.Part.from_text(text=content)]))
            except Exception:
                contents.append({"role": api_role, "parts": [{"text": content}]})

        # Build current message parts
        current_parts = []
        if files_data:
            for fd in files_data:
                try:
                    if b64 := fd.get('base64'):
                        current_parts.append(types.Part.from_bytes(
                            data=base64.b64decode(b64),
                            mime_type=fd.get('mime_type', 'application/octet-stream')
                        ))
                except Exception as e:
                    return self._emit_error(f"Error processing file '{fd.get('filename', 'Unknown')}': {e}")

        if user_input.strip():
            current_parts.append(types.Part.from_text(text=user_input))
        if current_parts:
            contents.append(types.Content(role="user", parts=current_parts))

        config = types.GenerateContentConfig(
            system_instruction=params['system_prompt'],
            safety_settings=[types.SafetySetting(category=c, threshold="BLOCK_NONE") for c in SAFETY_CATEGORIES],
            thinking_config=types.ThinkingConfig(include_thoughts=True, thinking_budget=8192)
        )

        api_model = self.MODEL_MAP.get(params['model_name'], "gemini-2.5-flash")
        self._start_worker(GeminiWorker(self.client, api_model, contents, config, self.rotation_attempts))

    def generate_response(self, system_prompt, user_input, model_name="Flash",
                          conversation_history=None, files_data=None):
        """Generate a response using the Gemini API in a background thread."""
        self.rotation_attempts = 0
        if self.api_keys:
            self.current_key_index = 0

        if not self.client:
            msg = "No Gemini API keys configured." if not self.api_keys else "Failed to initialize Gemini client."
            return self._emit_error(msg)

        self._pending_request = {
            'system_prompt': system_prompt, 'user_input': user_input,
            'model_name': model_name, 'conversation_history': conversation_history,
            'files_data': files_data
        }
        self.status_updated.emit(f"Generating response using {model_name}...")
        self._build_and_start()

    def _handle_success(self, response_text: str):
        super()._handle_success(response_text)
        self._pending_request = None

    def _handle_error(self, error_message: str):
        super()._handle_error(error_message)
        self._pending_request = None

    def _handle_retry(self, error_message: str, attempt_count: int):
        """Handle retry on 429 errors by rotating API keys."""
        if not self._pending_request:
            return self._emit_error(error_message)

        if len(self.api_keys) <= 1:
            return self._emit_error("All API keys rate limited.")

        self.current_key_index = (self.current_key_index + 1) % len(self.api_keys)
        self.rotation_attempts += 1
        self.status_updated.emit(f"API Key Rate Limited. Rotating to next key (attempt {attempt_count + 1})...")

        try:
            self.client = genai.Client(api_key=self.api_keys[self.current_key_index])
        except Exception:
            return self._emit_error("Failed to recreate client with new API key.")

        self._build_and_start()
```

### `core/services/nvidia_nim_service.py`

```python
# nvidia_nim_service.py
import os
from openai import OpenAI
from core.services.base_service import BaseAIService, BaseAIWorker

class NvidiaNimWorker(BaseAIWorker):
    """
    Worker thread to handle streaming API calls to NVIDIA NIM via OpenAI SDK.
    """
    def __init__(self, client, model_name, messages, enable_thinking=True):
        super().__init__()
        self.client = client
        self.model_name = model_name
        self.messages = messages
        self.enable_thinking = enable_thinking

    def run(self):
        try:
            # Build request parameters
            request_params = {
                "model": self.model_name,
                "messages": self.messages,
                "stream": True
            }
            
            # Add thinking parameter for models that support it (DeepSeek, Kimi K2)
            # Per NVIDIA NIM docs: must be wrapped in chat_template_kwargs
            if self.enable_thinking:
                request_params["extra_body"] = {"chat_template_kwargs": {"thinking": True}}
            
            # Use streaming API
            response_stream = self.client.chat.completions.create(**request_params)
            
            full_response = ""
            full_thinking = ""
            
            for chunk in response_stream:
                if self._is_cancelled:
                    break
                if chunk.choices and len(chunk.choices) > 0:
                    delta = chunk.choices[0].delta
                    
                    # Check for reasoning content (DeepSeek, Kimi K2 format)
                    if hasattr(delta, 'reasoning_content') and delta.reasoning_content:
                        self.thinking_chunk.emit(delta.reasoning_content)
                        full_thinking += delta.reasoning_content
                    
                    # Regular content
                    if hasattr(delta, 'content') and delta.content:
                        self.chunk.emit(delta.content)
                        full_response += delta.content
            
            if self._is_cancelled:
                self.error.emit("Generation interrupted by user.")
                return

            self._emit_result(full_response, full_thinking)

        except Exception as e:
            self.error.emit(str(e))

class NvidiaNimService(BaseAIService):
    """Service for interacting with NVIDIA NIM API using OpenAI SDK."""

    # Model mapping: GUI friendly name -> API model ID
    MODEL_MAP = {
        "DeepSeek V3.2": "deepseek-ai/deepseek-v3.2",
        "Kimi K2": "moonshotai/kimi-k2-thinking"
    }

    def __init__(self):
        super().__init__()
        self.api_key = os.environ.get("NVIDIA_NIM_API_KEY")
        self.client = None

        if self.api_key:
            try:
                # Initialize OpenAI client with NVIDIA NIM base URL
                self.client = OpenAI(
                    api_key=self.api_key,
                    base_url="https://integrate.api.nvidia.com/v1"
                )
            except Exception as e:
                print(f"Failed to initialize NVIDIA NIM Client: {e}")
        else:
            print("Warning: NVIDIA_NIM_API_KEY environment variable not set.")
            print("NVIDIA NIM service will be unavailable until API key is configured.")

    def _emit_error(self, message: str):
        self.status_updated.emit(f"Error: {message}")
        self.error_occurred.emit(message)

    def generate_response(self, system_prompt: str, user_input: str, model_name: str = "DeepSeek V3.2", conversation_history: list = None, **kwargs):
        """Generates a response using the NVIDIA NIM API in a background thread."""
        if not self.client:
            return self._emit_error("NVIDIA_NIM_API_KEY not found.")
        if not user_input.strip():
            return self._emit_error("Input cannot be empty.")

        api_model = self.MODEL_MAP.get(model_name, "deepseek-ai/deepseek-v3.2")
        self.status_updated.emit(f"Generating response using NVIDIA NIM {model_name}...")

        messages = []
        if system_prompt:
            messages.append({"role": "system", "content": system_prompt})
        if conversation_history:
            messages.extend([{"role": m.get("role", ""), "content": m.get("content", "")} for m in conversation_history if m.get("content")])
        messages.append({"role": "user", "content": user_input})

        worker = NvidiaNimWorker(self.client, api_model, messages, enable_thinking=True)
        self._start_worker(worker)
```

### `core/services/file_service.py`

```python
# core/services/file_service.py
"""
File Service - Handles file loading, processing, and management for API transmission.
"""
import base64
from typing import Tuple, List
from PyQt6.QtCore import pyqtSignal, QObject


class FileService(QObject):
    """
    Service for handling file operations: loading, encoding for API transmission.
    Supports multiple files.
    """
    files_updated = pyqtSignal(list)  # list of filenames
    files_cleared = pyqtSignal()
    status_updated = pyqtSignal(str)

    def __init__(self):
        super().__init__()
        self.files_b64: List[str] = []
        self.filenames: List[str] = []

    def _add_file(self, b64: str, filename: str):
        """Add an encoded file and emit update signals."""
        self.files_b64.append(b64)
        self.filenames.append(filename)
        self.files_updated.emit(self.filenames.copy())
        count = len(self.filenames)
        self.status_updated.emit("File loaded." if count == 1 else f"File loaded. Total: {count} files.")

    def load_file_from_path(self, path: str) -> bool:
        """Load file from path and encode to base64. Appends to existing files list."""
        try:
            with open(path, "rb") as fh:
                b64 = base64.b64encode(fh.read()).decode("utf-8")
            self._add_file(b64, path.split('/')[-1].split('\\')[-1])
            return True
        except Exception as e:
            self.status_updated.emit(f"‚ùå Failed to load file: {e}")
            return False

    def load_file_from_data(self, data: bytes, source: str = "") -> bool:
        """Load file from raw data and encode to base64. Appends to existing files list."""
        try:
            self._add_file(base64.b64encode(data).decode("utf-8"), source or "clipboard")
            return True
        except Exception as e:
            self.status_updated.emit(f"‚ùå Error loading file: {e}")
            return False

    def clear_files(self):
        """Clear all files."""
        self.files_b64.clear()
        self.filenames.clear()
        self.files_cleared.emit()
        self.status_updated.emit("Files cleared.")

    def remove_file(self, index: int) -> bool:
        """
        Remove a specific file by index.

        Args:
            index: Index of file to remove

        Returns:
            bool: True if successful, False if index out of range
        """
        if 0 <= index < len(self.files_b64):
            self.files_b64.pop(index)
            removed_filename = self.filenames.pop(index)
            self.files_updated.emit(self.filenames.copy())
            self.status_updated.emit(f"Removed: {removed_filename}")
            return True
        return False

    def get_files(self) -> List[Tuple[str, str]]:
        """
        Get all file data.

        Returns:
            List of tuples (base64, filename)
        """
        return list(zip(self.files_b64, self.filenames))

    def has_files(self) -> bool:
        """Check if any files are currently loaded."""
        return len(self.files_b64) > 0
```