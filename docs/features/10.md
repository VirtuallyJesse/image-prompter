### TASKS

We're moving the project to the next phase, which is an introduction to integration with various image generation APIs (the models themselves which generate the images).

## CURRENT PHASE TASK:

You have full creative liberty to design and implement any system which covers these goals:

1. Complete implementation of the Gallery page in the media panel. If desired, create `./core/services/gallery_service.py` and/or `./gui/widgets/gallery_page.py` only as needed.

2. The Gallery page, as it's naming suggests, acts as a Media Gallery, displaying the images present in the `images` folder in a visually appealing grid.

3. For the items themselves, display as such in individual containers in the grid:

<the image, never cropped>
<the prompt, obtained from the exif, and truncated/clamped in display to avoid excessive length>
<service/model/creationtimestamp>

Left clicking an image opens the image in the explorer like our other pages.
Left clicking the prompt text copies it to clipboard, allowing the user to quickly re-use prompts.

4. The Gallery offers internal page pagination (`12` images per page, e.g. Â« â€¹ 1 2 3 4 5 â€º Â» Page 1 of 6 (65 items), centered in top bar) and display filtering toggles (right justified in top bar). Both of these are visible/shared in the same header/top bar. Filters: `All`, `Pollinations`, `Airforce`, `Perchance`. Filters the images by service, data present in metadata. For this top bar, use the same height and styling as the top bar present in the other pages.

5. Persistence with configurations, similar to pollinations. Last pagination page, current filter, etc.

6. There is no scrolling, either horizontal or vertical bars in the Gallery page. We attempt to display the items at all times using dynamic scaling (`12` is adjustable). You will still need to design the grid layout - aim for visualization of 3 rows, and 4 columns (4 items per row). For edge cases where the user is making the media panel extremely small, prefer logic that clips containers into each other, or maybe some other priority system over spawning scroll bars. Though we already have a minimum display with protection in place to prevent the panel from becoming non-usable.

7. Follow the similar visual design of the other pages: flexible, minimal space waste, maximum content area utilized.

Considerations: cache where you can for efficiency/reducing disk reads against EXIF metadata extraction (thumbnails = not needed), graceful handling if images on disk are moved/deleted/missing exif. Perchance omits some EXIF data on downloads, but we hope to modify this in the future to achieve parity (out of your scope), but keep it in mind when designing.

### PROJECT 

A sophisticated desktop application that enhances image generation prompts using AI models and provides seamless integration with various image generation APIs with a modern PyQt6 GUI.

### DELIVERABLES

Please output a brief summary including any design choices, and the updated or new files where applicable. You may create new services or modules. If only small changes to existing files are required, please output them in

SEARCH: 

```
...stuff...
``` 

REPLACE:

```
...stuff...
``` 

style blocks.

### CONTEXT

## ðŸŽ¯ Focused Context (Agent-Selected)

**Project Root:** `image-prompter/`
**Files Included:** 6

---

### File Index

1. `gui/widgets/media_panel.py`
2. `core/config.py`
3. `core/utils.py`
4. `core/services/perchance_service.py`
5. `gui/widgets/image_gen_common.py`
6. `gui/widgets/pollinations_page.py`

---

### `gui/widgets/media_panel.py`

```python
# gui/widgets/media_panel.py
"""
Media Panel - Secondary pane for generative imaging interfacing.
Provides tabbed navigation for different image generation APIs.
"""

from PyQt6.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, QPushButton,
    QStackedWidget, QLabel, QSizePolicy
)
from PyQt6.QtCore import Qt, pyqtSignal
from PyQt6.QtGui import QCursor
from gui.widgets.pollinations_page import PollinationsPage
from gui.widgets.airforce_page import AirforcePage
from gui.widgets.perchance_page import PerchancePage


class MediaPanel(QWidget):
    """Secondary pane with tabbed navigation for image generation API interfaces."""

    status_updated = pyqtSignal(str)

    TAB_NAMES = ["Gallery", "Pollinations", "Airforce", "Perchance"]

    ACTIVE_BG = "#1E88E5"
    ACTIVE_HOVER = "#2A9BF8"
    INACTIVE_BG = "#2a2a2a"
    INACTIVE_HOVER = "#3d3d3d"

    _TAB_ICONS = {"Gallery": "ðŸ–¼ï¸", "Pollinations": "ðŸŒ¸", "Airforce": "âœˆï¸", "Perchance": "ðŸŽ²"}
    _TAB_DESCS = {
        "Gallery": "Generated images will appear here",
        "Pollinations": "Pollinations AI image generation",
        "Airforce": "Airforce image generation API",
        "Perchance": "Perchance image generation",
    }

    def __init__(self, config_manager=None, parent=None):
        super().__init__(parent)
        self.config_manager = config_manager
        self.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Expanding)
        self._current_tab = 0
        self._tabs = []
        self._build_ui()
        self._load_active_tab()

    def _build_ui(self):
        layout = QVBoxLayout(self)
        layout.setContentsMargins(0, 0, 0, 0)
        layout.setSpacing(0)

        # --- Tab bar ---
        tab_bar = QWidget()
        tab_bar.setFixedHeight(34)
        tab_bar.setStyleSheet("background-color: #1a1a1a;")
        tab_layout = QHBoxLayout(tab_bar)
        tab_layout.setContentsMargins(0, 0, 0, 0)
        tab_layout.setSpacing(1)

        for i, name in enumerate(self.TAB_NAMES):
            btn = QPushButton(name)
            btn.setCursor(QCursor(Qt.CursorShape.PointingHandCursor))
            btn.setFocusPolicy(Qt.FocusPolicy.NoFocus)
            btn.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Expanding)
            btn.clicked.connect(lambda _, idx=i: self._switch_tab(idx))
            self._tabs.append(btn)
            tab_layout.addWidget(btn)

        layout.addWidget(tab_bar)

        # --- Stacked content area ---
        self._stack = QStackedWidget()
        self._stack.setStyleSheet("background-color: #2a2a2a; border: 1px solid #333;")

        for name in self.TAB_NAMES:
            if name == "Pollinations":
                self.pollinations_page = PollinationsPage(self.config_manager)
                self.pollinations_page.status_updated.connect(self.status_updated.emit)
                self._stack.addWidget(self.pollinations_page)
            elif name == "Airforce":
                self.airforce_page = AirforcePage(self.config_manager)
                self.airforce_page.status_updated.connect(self.status_updated.emit)
                self._stack.addWidget(self.airforce_page)
            elif name == "Perchance":
                self.perchance_page = PerchancePage(self.config_manager)
                self.perchance_page.status_updated.connect(self.status_updated.emit)
                self._stack.addWidget(self.perchance_page)
            else:
                self._stack.addWidget(self._create_page(name))

        layout.addWidget(self._stack, 1)
        self._update_tab_styles()

    def _create_page(self, name: str) -> QWidget:
        """Create a placeholder page for a tab."""
        page = QWidget()
        page_layout = QVBoxLayout(page)
        page_layout.setAlignment(Qt.AlignmentFlag.AlignCenter)

        icon = QLabel(self._TAB_ICONS.get(name, "ðŸ“„"))
        icon.setStyleSheet("font-size: 32pt;")
        icon.setAlignment(Qt.AlignmentFlag.AlignCenter)
        page_layout.addWidget(icon)

        title = QLabel(name)
        title.setStyleSheet("color: #666; font-size: 14pt; font-weight: bold;")
        title.setAlignment(Qt.AlignmentFlag.AlignCenter)
        page_layout.addWidget(title)

        desc = QLabel(self._TAB_DESCS.get(name, ""))
        desc.setStyleSheet("color: #444; font-size: 9pt;")
        desc.setAlignment(Qt.AlignmentFlag.AlignCenter)
        desc.setWordWrap(True)
        page_layout.addWidget(desc)

        return page

    def _switch_tab(self, index: int):
        """Switch to the specified tab index."""
        if index == self._current_tab:
            return
        self._current_tab = index
        self._stack.setCurrentIndex(index)
        self._update_tab_styles()
        if self.config_manager:
            self.config_manager.media_active_tab = index
            self.config_manager.save()

    def _load_active_tab(self):
        """Restore the last active tab from config."""
        if self.config_manager:
            tab = getattr(self.config_manager, 'media_active_tab', 0)
            if 0 <= tab < len(self.TAB_NAMES):
                self._current_tab = tab
                self._stack.setCurrentIndex(tab)
                self._update_tab_styles()

    def _update_tab_styles(self):
        """Update tab button visual styles based on active selection."""
        for i, btn in enumerate(self._tabs):
            if i == self._current_tab:
                btn.setStyleSheet(f"""
                    QPushButton {{
                        background-color: {self.ACTIVE_BG};
                        color: #ffffff;
                        font-weight: bold;
                        font-size: 9pt;
                        border: none;
                        border-radius: 0px;
                        padding: 4px 8px;
                    }}
                    QPushButton:hover {{
                        background-color: {self.ACTIVE_HOVER};
                    }}
                """)
            else:
                btn.setStyleSheet(f"""
                    QPushButton {{
                        background-color: {self.INACTIVE_BG};
                        color: #888;
                        font-size: 9pt;
                        border: none;
                        border-radius: 0px;
                        padding: 4px 8px;
                    }}
                    QPushButton:hover {{
                        background-color: {self.INACTIVE_HOVER};
                        color: #fff;
                    }}
                """)
```

### `core/config.py`

```python
"""Configuration Manager for PyQt6 GUI Framework."""
import os
import json

_DEFAULTS = {
    "window_width": 1200,
    "window_height": 800,
    "theme": "dark",
    "current_service": "Gemini",
    "current_model": "Flash",
    "default_system_prompt": "You are a helpful AI assistant.",
    "splitter_sizes": [780, 420],
    "media_active_tab": 0,
    "pollinations_positive_prompt": "",
    "pollinations_negative_prompt": "",
    "pollinations_model": "zimage",
    "pollinations_size": "1024x1024",
    "pollinations_seed": -1,
    "pollinations_last_image": "",
    "airforce_positive_prompt": "",
    "airforce_negative_prompt": "",
    "airforce_model": "grok-imagine",
    "airforce_size": "1024x1024",
    "airforce_seed": -1,
    "airforce_last_image": "",
    "perchance_url": "https://perchance.org/a1481832-0a06-414f-baa6-616052e5f61d",
    "adblocker": {
        "blocked_domains": [
            "a.pub.network",
            "d.pub.network",
            "cdn.snigelweb.com",
            "googletagmanager.com",
            "cloudflareinsights.com",
            "static.criteo.net",
            "secure.quantserve.com",
            "fundingchoicesmessages.google.com"
        ],
        "hidden_selectors": [
            ".ad-providers-ctn-el",
            "#adCtn",
            "#pmLink"
        ]
    },
    "display_fields": {
        "core": True,
        "composition": True,
        "lighting": True,
        "style": True,
        "technical": True,
        "post_processing": True,
        "special_elements": True,
        "detailed_prompt": True,
        "grok_imagine_optimized": True,
        "gemini_optimized": True,
        "flux_optimized": True,
        "stable_diffusion_optimized": True,
        "video_optimized": True
    }
}

class ConfigManager:
    """Manages GUI configuration values and local gui_config.json persistence."""

    def __init__(self, config_file: str = "gui_config.json"):
        self.config_file = config_file
        self.__dict__.update(_DEFAULTS)
        self._load_config()

    def _load_config(self) -> None:
        if not os.path.exists(self.config_file):
            return
        try:
            with open(self.config_file, 'r') as f:
                config = json.load(f)
                for k in _DEFAULTS:
                    val = config.get(k, getattr(self, k))
                    if isinstance(val, dict) and isinstance(_DEFAULTS[k], dict):
                        merged = _DEFAULTS[k].copy()
                        merged.update(val)
                        setattr(self, k, merged)
                    else:
                        setattr(self, k, val)
                if "default_service" in config and "current_service" not in config:
                    self.current_service = config["default_service"]
                if "service_models" in config and "current_model" not in config:
                    self.current_model = config.get("service_models", {}).get(self.current_service, self.current_model)
        except Exception:
            pass

    def save(self) -> None:
        try:
            with open(self.config_file, 'w') as f:
                json.dump({k: getattr(self, k) for k in _DEFAULTS}, f, indent=2)
        except Exception:
            pass
```

### `core/utils.py`

```python
# core/utils.py
"""Shared utility functions for the application."""

import os
import sys
import subprocess
from datetime import datetime
from pathlib import Path


def reveal_file_in_explorer(filepath: str) -> bool:
    """
    Open the system file explorer and select/highlight the given file.

    Platform behavior:
        Windows: explorer /select,<path>
        macOS:   open -R <path>
        Linux:   xdg-open <parent directory>

    Returns True if the command was launched, False on error or missing file.
    """
    filepath = os.path.normpath(os.path.abspath(filepath))
    if not os.path.exists(filepath):
        return False
    try:
        if sys.platform == "win32":
            subprocess.Popen(["explorer", f"/select,{filepath}"])
        elif sys.platform == "darwin":
            subprocess.Popen(["open", "-R", filepath])
        else:
            subprocess.Popen(["xdg-open", os.path.dirname(filepath)])
        return True
    except Exception:
        return False


def open_file(filepath: str) -> bool:
    """
    Open a file with the system's default application.

    Returns True if the command was launched, False on error or missing file.
    """
    filepath = os.path.normpath(os.path.abspath(filepath))
    if not os.path.exists(filepath):
        return False
    try:
        if sys.platform == "win32":
            os.startfile(filepath)
        elif sys.platform == "darwin":
            subprocess.Popen(["open", filepath])
        else:
            subprocess.Popen(["xdg-open", filepath])
        return True
    except Exception:
        return False


def save_generated_image(
    image_data: bytes,
    prompt: str,
    negative_prompt: str,
    model: str,
    size: str,
    seed: int,
    service: str,
) -> str:
    """Save generated image to the images/ directory with embedded EXIF metadata.

    Uses a timestamp-based filename (``YYYY-MM-DD_HH-MM-SS.jpg``) and embeds
    prompt / generation metadata into the EXIF ImageDescription tag when
    Pillow is available.

    Args:
        image_data:      Raw image bytes (any format Pillow can open).
        prompt:          Positive prompt text.
        negative_prompt: Negative prompt text (may be empty).
        model:           Model identifier string.
        size:            Size string, e.g. ``"1024x1024"``.
        seed:            Seed value used for generation.
        service:         Service name (e.g. ``"Pollinations"``, ``"Airforce"``).

    Returns:
        The absolute-ish path to the saved file as a string.
    """
    images_dir = Path("images")
    images_dir.mkdir(exist_ok=True)

    timestamp = datetime.now().strftime("%Y-%m-%d_%H-%M-%S")
    filepath = images_dir / f"{timestamp}.jpg"
    counter = 1
    while filepath.exists():
        filepath = images_dir / f"{timestamp}_{counter}.jpg"
        counter += 1

    metadata_str = (
        f"Prompt: {prompt} | "
        f"Negative: {negative_prompt or 'None'} | "
        f"Model: {model} | "
        f"Size: {size} | "
        f"Seed: {seed} | "
        f"Service: {service}"
    )

    saved_with_meta = False
    try:
        from PIL import Image
        import io

        img = Image.open(io.BytesIO(image_data))
        if img.mode in ("RGBA", "P", "LA"):
            img = img.convert("RGB")

        exif = img.getexif()
        exif[0x010E] = metadata_str        # ImageDescription
        exif[0x0131] = f"{service} AI"     # Software
        img.save(str(filepath), "JPEG", quality=95, exif=exif.tobytes())
        saved_with_meta = True
    except Exception:
        pass

    if not saved_with_meta:
        with open(filepath, "wb") as f:
            f.write(image_data)

    return str(filepath)
```

### `core/services/perchance_service.py`

```python
# core/services/perchance_service.py
"""
Perchance Service â€“ WebEngine profile management, ad blocking, and image
download handling for the embedded Perchance image generator.
"""

import os
from datetime import datetime
from pathlib import Path

_WEBENGINE_AVAILABLE = False
try:
    from PyQt6.QtWebEngineCore import (
        QWebEngineProfile,
        QWebEnginePage,
        QWebEngineUrlRequestInterceptor,
    )
    _WEBENGINE_AVAILABLE = True
except ImportError:
    QWebEngineUrlRequestInterceptor = None


def is_webengine_available() -> bool:
    """Return *True* if PyQt6-WebEngine is installed and importable."""
    return _WEBENGINE_AVAILABLE


# â”€â”€ Ad-block request interceptor â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

if _WEBENGINE_AVAILABLE:

    class AdBlockInterceptor(QWebEngineUrlRequestInterceptor):
        """Block network requests whose URL contains a blocked-domain substring."""

        def __init__(self, blocked_domains: list, parent=None):
            super().__init__(parent)
            self.blocked_domains = blocked_domains or []

        def interceptRequest(self, info):
            url = info.requestUrl().toString()
            for domain in self.blocked_domains:
                if domain in url:
                    info.block(True)
                    return


# â”€â”€ Service class â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

class PerchanceService:
    """
    Creates a persistent WebEngine profile with ad-blocking and handles
    image downloads from the embedded Perchance page.
    """

    DEFAULT_BLOCKED_DOMAINS = [
        "a.pub.network",
        "d.pub.network",
        "cdn.snigelweb.com",
        "googletagmanager.com",
        "cloudflareinsights.com",
        "static.criteo.net",
        "secure.quantserve.com",
        "fundingchoicesmessages.google.com",
    ]

    DEFAULT_HIDDEN_SELECTORS = [
        ".ad-providers-ctn-el",
        "#adCtn",
        "#pmLink",
    ]

    def __init__(self, config_manager=None):
        self.config_manager = config_manager
        self._profile = None
        self._interceptor = None
        self._page = None
        self._status_callback = None

    # -- External setters ------------------------------------------------

    def set_page(self, page):
        """Store a reference to the active QWebEnginePage for JS access."""
        self._page = page

    def set_status_callback(self, callback):
        """Register a callable for status messages (e.g. a pyqtSignal emit)."""
        self._status_callback = callback

    def _emit_status(self, msg: str):
        if self._status_callback:
            self._status_callback(msg)

    # â”€â”€ Profile creation â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    def create_profile(self, parent=None):
        """
        Build a *persistent* QWebEngineProfile:

        * Disk-backed cookies (login survives restarts)
        * Ad-blocking request interceptor
        * Download-requested handler for saving images

        Returns the profile, or ``None`` when WebEngine is unavailable.
        """
        if not _WEBENGINE_AVAILABLE:
            return None

        from PyQt6.QtCore import QStandardPaths

        base = QStandardPaths.writableLocation(
            QStandardPaths.StandardLocation.AppDataLocation
        )
        storage_root = os.path.join(base, "webengine", "perchance")
        os.makedirs(storage_root, exist_ok=True)

        profile = QWebEngineProfile("perchance", parent)
        profile.setPersistentStoragePath(os.path.join(storage_root, "storage"))
        profile.setCachePath(os.path.join(storage_root, "cache"))
        profile.setHttpCacheType(QWebEngineProfile.HttpCacheType.DiskHttpCache)

        try:
            profile.setPersistentCookiesPolicy(
                QWebEngineProfile.PersistentCookiesPolicy.ForcePersistentCookies
            )
        except AttributeError:
            pass  # older PyQt6 build without this enum

        # Layer 1 â€“ network-level ad blocking
        blocked = self._get_blocked_domains()
        if blocked:
            self._interceptor = AdBlockInterceptor(blocked, parent)
            profile.setUrlRequestInterceptor(self._interceptor)

        # Image download handling
        profile.downloadRequested.connect(self._on_download_requested)

        self._profile = profile
        return profile

    # â”€â”€ Ad-hide JavaScript (Layer 2) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    def get_ad_hide_script(self) -> str:
        """
        Return a JavaScript snippet that hides ad-related DOM elements and
        watches for dynamically inserted ones via MutationObserver.
        """
        selectors = self._get_hidden_selectors()
        if not selectors:
            return ""

        selectors_js = ", ".join(f'"{s}"' for s in selectors)
        return f"""
(function() {{
    if (window._perchanceAdblockActive) return;
    window._perchanceAdblockActive = true;

    var selectors = [{selectors_js}];

    function hide() {{
        selectors.forEach(function(s) {{
            document.querySelectorAll(s).forEach(function(el) {{
                el.style.setProperty('display', 'none', 'important');
                el.style.setProperty('visibility', 'hidden', 'important');
                el.style.position = 'absolute';
                el.style.left = '-9999px';
            }});
        }});
    }}

    hide();
    setTimeout(hide, 1000);
    setTimeout(hide, 3000);

    var obs = new MutationObserver(function() {{ hide(); }});
    if (document.body) {{
        obs.observe(document.body, {{ childList: true, subtree: true }});
    }} else {{
        document.addEventListener('DOMContentLoaded', function() {{
            hide();
            obs.observe(document.body, {{ childList: true, subtree: true }});
        }});
    }}
}})();
"""

    # â”€â”€ Download handling â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    def _on_download_requested(self, download):
        """
        Accept image downloads and redirect them to ``images/`` with a
        timestamp-based temporary filename.  Non-image downloads are
        silently ignored.
        """
        try:
            mime_type = (download.mimeType() or "").lower()
            dl_name = (download.downloadFileName() or "").lower()
            is_image = mime_type.startswith("image/") or dl_name.endswith(
                (".png", ".jpg", ".jpeg", ".webp", ".gif")
            )
            if not is_image:
                return

            images_dir = Path("images")
            images_dir.mkdir(exist_ok=True)

            timestamp = datetime.now().strftime("%Y-%m-%d_%H-%M-%S")
            orig_ext = Path(download.downloadFileName() or "image.png").suffix or ".png"
            temp_name = f"_perchance_tmp_{timestamp}{orig_ext}"

            download.setDownloadDirectory(str(images_dir.resolve()))
            download.setDownloadFileName(temp_name)

            # Best-effort prompt capture via async JS callback
            captured = {"prompt": ""}
            if self._page:
                self._page.runJavaScript(
                    "(function(){var e=document.querySelector('textarea');"
                    "return e?e.value:'';})()",
                    lambda result, c=captured: c.update({"prompt": result or ""}),
                )

            temp_path = images_dir / temp_name

            download.isFinishedChanged.connect(
                lambda tp=temp_path, ts=timestamp, cap=captured: self._finalize_download(
                    tp, ts, cap
                )
            )

            download.accept()
            self._emit_status("Downloading image from Perchance\u2026")

        except Exception as e:
            self._emit_status(f"Download error: {e}")

    def _finalize_download(self, temp_path: Path, timestamp: str, captured: dict):
        """
        Post-process a completed download:

        1. Open with Pillow (if available)
        2. Convert to RGB JPEG
        3. Embed EXIF metadata (prompt + service)
        4. Remove the temporary file

        Falls back to a simple rename when Pillow is absent.
        """
        if not temp_path.exists():
            return
        try:
            if temp_path.stat().st_size == 0:
                temp_path.unlink(missing_ok=True)
                return
        except OSError:
            return

        images_dir = temp_path.parent
        prompt = captured.get("prompt", "")

        # Determine unique final path
        final_path = images_dir / f"{timestamp}.jpg"
        counter = 1
        while final_path.exists():
            final_path = images_dir / f"{timestamp}_{counter}.jpg"
            counter += 1

        saved = False
        try:
            from PIL import Image

            img = Image.open(str(temp_path))
            if img.mode in ("RGBA", "P", "LA"):
                img = img.convert("RGB")

            parts = []
            if prompt:
                parts.append(f"Prompt: {prompt}")
            parts.append("Service: Perchance")
            metadata_str = " | ".join(parts)

            exif = img.getexif()
            exif[0x010E] = metadata_str      # ImageDescription
            exif[0x0131] = "Perchance AI"    # Software
            img.save(str(final_path), "JPEG", quality=95, exif=exif.tobytes())
            saved = True
        except ImportError:
            pass
        except Exception as e:
            self._emit_status(f"Image conversion note: {e}")

        if not saved:
            # Fallback: rename temp file directly
            try:
                temp_path.rename(final_path)
                saved = True
            except OSError:
                pass

        # Clean up temp file (Pillow path leaves it behind)
        if temp_path.exists():
            try:
                temp_path.unlink(missing_ok=True)
            except OSError:
                pass

        if saved:
            self._emit_status(f"Image saved: {final_path.name}")

    # â”€â”€ Config helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    def _get_blocked_domains(self) -> list:
        if self.config_manager:
            ab = getattr(self.config_manager, "adblocker", {})
            if isinstance(ab, dict) and ab.get("blocked_domains"):
                return ab["blocked_domains"]
        return self.DEFAULT_BLOCKED_DOMAINS

    def _get_hidden_selectors(self) -> list:
        if self.config_manager:
            ab = getattr(self.config_manager, "adblocker", {})
            if isinstance(ab, dict) and ab.get("hidden_selectors"):
                return ab["hidden_selectors"]
        return self.DEFAULT_HIDDEN_SELECTORS
```

### `gui/widgets/image_gen_common.py`

```python
# gui/widgets/image_gen_common.py
"""
Shared components for image generation pages.
Provides ImageDisplay widget, UI style constants, and dropdown factory.
"""

from PyQt6.QtWidgets import QLabel, QSizePolicy, QWidget, QVBoxLayout, QPushButton
from PyQt6.QtCore import pyqtSignal, Qt
from PyQt6.QtGui import QCursor, QPixmap


# â”€â”€ Shared style constants â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

INPUT_STYLE = (
    "QLineEdit {"
    "  background-color: #1e1e1e; color: #eee;"
    "  border: 1px solid #333; border-radius: 3px;"
    "  font-size: 12px; padding: 6px;"
    "}"
    "QLineEdit:disabled { color: #666; }"
)

BTN_GENERATE = (
    "QPushButton {"
    "  background-color: #1E88E5; color: #fff; font-weight: bold;"
    "  border: 1px solid #1E88E5; border-radius: 3px;"
    "  font-size: 12px; padding: 6px 12px;"
    "}"
    "QPushButton:hover { background-color: #2A9BF8; border-color: #2A9BF8; }"
    "QPushButton:pressed { background-color: #1966C2; border-color: #1966C2; }"
)

BTN_CANCEL = (
    "QPushButton {"
    "  background-color: #F44336; color: #fff; font-weight: bold;"
    "  border: 1px solid #F44336; border-radius: 3px;"
    "  font-size: 12px; padding: 6px 12px;"
    "}"
    "QPushButton:hover { background-color: #EF5350; border-color: #EF5350; }"
    "QPushButton:pressed { background-color: #D32F2F; border-color: #D32F2F; }"
)

BTN_DROPDOWN = (
    "QPushButton {"
    "  background-color: #1e1e1e; color: #eee;"
    "  border: 1px solid #333; border-radius: 3px;"
    "  font-size: 12px; padding: 6px 8px;"
    "}"
    "QPushButton:hover { background-color: #2a2a2a; border-color: #555; }"
    "QPushButton:disabled { color: #666; }"
)

DROPDOWN_OPTION = (
    "QPushButton {"
    "  background-color: transparent; color: #eee; border: none;"
    "  text-align: left; padding: 6px 12px; font-size: 12px;"
    "}"
    "QPushButton:hover { background-color: #2a2a2a; }"
)

DROPDOWN_CONTAINER = (
    "QWidget { background-color: #1e1e1e; border: 1px solid #333; border-radius: 3px; }"
)


# â”€â”€ Shared widgets â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

class ImageDisplay(QLabel):
    """Custom label that displays an image fully contained, never cropped."""

    clicked = pyqtSignal()

    def __init__(self, parent=None):
        super().__init__(parent)
        self._pixmap = None
        self.setAlignment(Qt.AlignmentFlag.AlignCenter)
        self.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Expanding)
        self.setMinimumSize(64, 64)
        self.setStyleSheet("background-color: #121212; border: none;")

    def set_image(self, filepath: str):
        """Load and display an image from file path."""
        self._pixmap = QPixmap(filepath)
        self._update_display()
        self.setCursor(QCursor(Qt.CursorShape.PointingHandCursor))

    def clear_image(self):
        self._pixmap = None
        self.clear()
        self.setCursor(QCursor(Qt.CursorShape.ArrowCursor))

    def mousePressEvent(self, event):
        if event.button() == Qt.MouseButton.LeftButton and self._pixmap:
            self.clicked.emit()
        super().mousePressEvent(event)

    def _update_display(self):
        if self._pixmap and not self._pixmap.isNull():
            scaled = self._pixmap.scaled(
                self.size(),
                Qt.AspectRatioMode.KeepAspectRatio,
                Qt.TransformationMode.SmoothTransformation,
            )
            self.setPixmap(scaled)

    def resizeEvent(self, event):
        super().resizeEvent(event)
        self._update_display()


# â”€â”€ Shared helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

def make_dropdown(parent_widget, options: list, callback, event_filter_obj) -> QWidget:
    """Create a hover-activated dropdown widget with the given options.

    Args:
        parent_widget:    Widget whose window() is used as the dropdown parent.
        options:          List of string labels for the dropdown items.
        callback:         Called with the selected option string on click.
        event_filter_obj: QObject that will receive Enter/Leave events on the dropdown.
    """
    dd = QWidget(parent_widget.window() or None)
    dd.setWindowFlags(Qt.WindowType.FramelessWindowHint | Qt.WindowType.Tool)
    dd.setAttribute(Qt.WidgetAttribute.WA_ShowWithoutActivating)
    dd.setStyleSheet(DROPDOWN_CONTAINER)
    lo = QVBoxLayout(dd)
    lo.setContentsMargins(2, 2, 2, 2)
    lo.setSpacing(1)

    for opt in options:
        btn = QPushButton(opt)
        btn.setStyleSheet(DROPDOWN_OPTION)
        btn.setCursor(QCursor(Qt.CursorShape.PointingHandCursor))
        btn.clicked.connect(lambda _, o=opt: callback(o))
        lo.addWidget(btn)

    dd.adjustSize()
    dd.hide()
    dd.installEventFilter(event_filter_obj)
    return dd
```

### `gui/widgets/pollinations_page.py`

```python
# gui/widgets/pollinations_page.py
"""
Pollinations Page - Image generation interface for the Pollinations AI API.
Provides controls for prompt, model, size, seed and displays generated images.
"""

from PyQt6.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, QPushButton, QLineEdit
)
from PyQt6.QtCore import pyqtSignal, Qt, QTimer, QEvent
from PyQt6.QtGui import QCursor

import os

from gui.widgets.image_gen_common import (
    ImageDisplay, INPUT_STYLE, BTN_GENERATE, BTN_CANCEL,
    BTN_DROPDOWN, make_dropdown,
)
from core.services.pollinations_service import PollinationsService
from core.utils import reveal_file_in_explorer


class PollinationsPage(QWidget):
    """Pollinations AI image generation page with controls and image display."""

    status_updated = pyqtSignal(str)

    MODELS = ["flux", "zimage", "klein", "klein-large", "gptimage"]
    SIZES = ["1024x1024", "1344x768", "768x1344"]
    DEFAULT_MODEL = "zimage"
    DEFAULT_SIZE = "1024x1024"
    DEFAULT_SEED = -1

    def __init__(self, config_manager=None, parent=None):
        super().__init__(parent)
        self.config_manager = config_manager
        self.current_model = self.DEFAULT_MODEL
        self.current_size = self.DEFAULT_SIZE
        self._is_generating = False
        self._current_image_path = ""

        self.active_dropdown = None
        self.hide_timer = QTimer()
        self.hide_timer.setInterval(250)
        self.hide_timer.timeout.connect(self._hide_dropdown)

        self.service = PollinationsService()
        self.service.image_generated.connect(self._on_image_generated)
        self.service.error_occurred.connect(self._on_error)
        self.service.status_updated.connect(self.status_updated.emit)

        self._build_ui()
        self._load_from_config()

    def _build_ui(self):
        layout = QVBoxLayout(self)
        layout.setContentsMargins(0, 0, 0, 0)
        layout.setSpacing(0)

        # --- Controls bar ---
        controls = QWidget()
        controls.setStyleSheet("background-color: #121212;")
        cl = QHBoxLayout(controls)
        cl.setContentsMargins(4, 4, 4, 4)
        cl.setSpacing(6)

        self.generate_btn = QPushButton("Generate")
        self.generate_btn.setStyleSheet(BTN_GENERATE)
        self.generate_btn.setCursor(QCursor(Qt.CursorShape.PointingHandCursor))
        self.generate_btn.setFocusPolicy(Qt.FocusPolicy.NoFocus)
        self.generate_btn.clicked.connect(self._on_generate_clicked)
        cl.addWidget(self.generate_btn)

        self.positive_input = QLineEdit()
        self.positive_input.setPlaceholderText("Positive Prompt...")
        self.positive_input.setStyleSheet(INPUT_STYLE)
        self.positive_input.returnPressed.connect(self._on_generate_clicked)
        cl.addWidget(self.positive_input, stretch=2)

        self.negative_input = QLineEdit()
        self.negative_input.setPlaceholderText("Negative Prompt...")
        self.negative_input.setStyleSheet(INPUT_STYLE)
        self.negative_input.returnPressed.connect(self._on_generate_clicked)
        cl.addWidget(self.negative_input, stretch=1)

        self.model_btn = QPushButton(self.current_model)
        self.model_btn.setStyleSheet(BTN_DROPDOWN)
        self.model_btn.setCursor(QCursor(Qt.CursorShape.PointingHandCursor))
        self.model_btn.setFocusPolicy(Qt.FocusPolicy.NoFocus)
        self.model_btn.setMinimumWidth(90)
        self.model_btn.installEventFilter(self)
        cl.addWidget(self.model_btn)

        self.size_btn = QPushButton(self.current_size)
        self.size_btn.setStyleSheet(BTN_DROPDOWN)
        self.size_btn.setCursor(QCursor(Qt.CursorShape.PointingHandCursor))
        self.size_btn.setFocusPolicy(Qt.FocusPolicy.NoFocus)
        self.size_btn.setMinimumWidth(90)
        self.size_btn.installEventFilter(self)
        cl.addWidget(self.size_btn)

        self.seed_input = QLineEdit(str(self.DEFAULT_SEED))
        self.seed_input.setStyleSheet(INPUT_STYLE)
        self.seed_input.setFixedWidth(64)
        self.seed_input.setAlignment(Qt.AlignmentFlag.AlignCenter)
        self.seed_input.setToolTip("Seed (-1 for random)")
        self.seed_input.returnPressed.connect(self._on_generate_clicked)
        cl.addWidget(self.seed_input)

        layout.addWidget(controls)

        # --- Image display ---
        self.image_display = ImageDisplay()
        self.image_display.clicked.connect(self._on_image_clicked)
        layout.addWidget(self.image_display, 1)

        # --- Dropdowns ---
        self.model_dropdown = make_dropdown(
            self, self.MODELS, self._on_model_selected, self
        )
        self.size_dropdown = make_dropdown(
            self, self.SIZES, self._on_size_selected, self
        )

    # ---------------------------------------------------------------- Dropdowns

    def eventFilter(self, obj, event):
        et = event.type()
        if et == QEvent.Type.Enter:
            if obj == self.model_btn:
                self._show_dropdown(self.model_dropdown, self.model_btn)
            elif obj == self.size_btn:
                self._show_dropdown(self.size_dropdown, self.size_btn)
            elif obj in (self.model_dropdown, self.size_dropdown):
                self.hide_timer.stop()
        elif et == QEvent.Type.Leave:
            if obj in (self.model_btn, self.size_btn,
                       self.model_dropdown, self.size_dropdown):
                self.hide_timer.start()
        return super().eventFilter(obj, event)

    def _show_dropdown(self, dropdown, button):
        if self._is_generating:
            return
        self.hide_timer.stop()
        if self.active_dropdown and self.active_dropdown is not dropdown:
            self.active_dropdown.hide()
        if self.active_dropdown is dropdown:
            return
        self.active_dropdown = dropdown
        pos = button.mapToGlobal(button.rect().bottomLeft())
        dropdown.move(pos.x(), pos.y() + 2)
        dropdown.show()
        dropdown.raise_()

    def _hide_dropdown(self):
        if self.active_dropdown:
            self.active_dropdown.hide()
            self.active_dropdown = None

    def _on_model_selected(self, model: str):
        self.current_model = model
        self.model_btn.setText(model)
        self._hide_dropdown()
        self._save_to_config()

    def _on_size_selected(self, size: str):
        self.current_size = size
        self.size_btn.setText(size)
        self._hide_dropdown()
        self._save_to_config()

    # ------------------------------------------------------------ Generation

    def _on_generate_clicked(self):
        if self._is_generating:
            self.service.cancel_generation()
            self._set_generating(False)
            self.status_updated.emit("Generation cancelled.")
            return

        prompt = self.positive_input.text().strip()
        if not prompt:
            self.status_updated.emit("Error: Positive prompt cannot be empty.")
            return

        try:
            seed = int(self.seed_input.text().strip())
        except ValueError:
            seed = -1

        w, h = self.current_size.split("x")
        self._set_generating(True)
        self._save_to_config()
        self.service.generate_image(
            prompt=prompt,
            negative_prompt=self.negative_input.text().strip(),
            model=self.current_model,
            width=int(w),
            height=int(h),
            seed=seed,
        )

    def _on_image_generated(self, filepath: str):
        self._set_generating(False)
        self._current_image_path = filepath
        self.image_display.set_image(filepath)
        self._save_to_config()

    def _on_error(self, _error_msg: str):
        self._set_generating(False)

    def _set_generating(self, state: bool):
        self._is_generating = state
        self.positive_input.setEnabled(not state)
        self.negative_input.setEnabled(not state)
        self.model_btn.setEnabled(not state)
        self.size_btn.setEnabled(not state)
        self.seed_input.setEnabled(not state)

        if state:
            self._hide_dropdown()
            self.generate_btn.setText("Cancel")
            self.generate_btn.setStyleSheet(BTN_CANCEL)
        else:
            self.generate_btn.setText("Generate")
            self.generate_btn.setStyleSheet(BTN_GENERATE)

    def hideEvent(self, event):
        """Close dropdowns when page is hidden (tab switch)."""
        self._hide_dropdown()
        super().hideEvent(event)

    def _on_image_clicked(self):
        """Open file explorer and select the current image."""
        if self._current_image_path and os.path.isfile(self._current_image_path):
            reveal_file_in_explorer(self._current_image_path)
        else:
            self.status_updated.emit("Image file not found on disk.")

    def _save_to_config(self):
        """Persist current Pollinations settings to config."""
        if not self.config_manager:
            return
        self.config_manager.pollinations_positive_prompt = self.positive_input.text()
        self.config_manager.pollinations_negative_prompt = self.negative_input.text()
        self.config_manager.pollinations_model = self.current_model
        self.config_manager.pollinations_size = self.current_size
        try:
            self.config_manager.pollinations_seed = int(self.seed_input.text())
        except ValueError:
            self.config_manager.pollinations_seed = self.DEFAULT_SEED
        self.config_manager.pollinations_last_image = self._current_image_path
        self.config_manager.save()

    def _load_from_config(self):
        """Load persisted Pollinations settings from config."""
        if not self.config_manager:
            return

        self.positive_input.setText(
            getattr(self.config_manager, 'pollinations_positive_prompt', ''))
        self.negative_input.setText(
            getattr(self.config_manager, 'pollinations_negative_prompt', ''))

        model = getattr(self.config_manager, 'pollinations_model', self.DEFAULT_MODEL)
        if model in self.MODELS:
            self.current_model = model
            self.model_btn.setText(model)

        size = getattr(self.config_manager, 'pollinations_size', self.DEFAULT_SIZE)
        if size in self.SIZES:
            self.current_size = size
            self.size_btn.setText(size)

        seed = getattr(self.config_manager, 'pollinations_seed', self.DEFAULT_SEED)
        self.seed_input.setText(str(seed))

        last_image = getattr(self.config_manager, 'pollinations_last_image', '')
        if last_image and os.path.isfile(last_image):
            self._current_image_path = last_image
            self.image_display.set_image(last_image)
```