# REFACTOR PLAN TEMPLATE (for docs/features/<N>_REFACTOR.md)

## Header (one-paragraph)
- Short summary of what will be refactored (files/modules) and the goal (e.g., "separate API services, business logic, and GUI into distinct packages while preserving all existing behavior and GUI elements"). Keep it factual and single-paragraph.

---

## 1) Preconditions: required artifacts to start
Before any code changes begin the author must produce and attach the following artifacts in the feature doc:
- **Behavioral Invariant List**: explicit list of features/behaviors that must be preserved (see format below).
- **Acceptance Test Corpus**: concrete inputs + expected outputs for APIs, JSON fields, and important UI flows (minimal, reproducible).
- **Golden GUI Snapshots**: screenshots of key UI states and a short description of how to reproduce each state from the running legacy app.
- **File & Function Map (current)**: list of files and the functions/classes they expose that are in-scope for the refactor.

> Required formats:
> - Behavioral Invariant List (YAML or JSON): `[{id, description, trigger, expected_outcome, severity}]`
> - Acceptance Test Corpus: one file per test case with name, input, expected output, and run command.

---

## 2) Explicit invariants (MANDATORY)
For each invariant include:
- `ID` (short code)
- `Type` (API / GUI / Config / Data / Behavior)
- `Trigger` (how it is exercised)
- `Expected` (precise assertion; e.g., JSON schema, field presence, exact string, HTTP status)
- `Verification method` (unit test, integration test, snapshot diff, manual test)
- `Blocking` (true/false — a blocking invariant halts the refactor if it fails)

Example:
```

* id: OUTBOX\_CHECKBOXES
  type: GUI
  trigger: open main window
  expected: checkboxes \['Gemini Response','Flux Response','Stable Diffusion','Pollinations'] present and functional
  verification: pixel-snapshot diff + UI automation click test
  blocking: true

```

---

## 3) Current code structure & scoping
- Enumerate the exact files in scope and the functions/classes to be refactored.
- For each file include a one-liner about responsibilities and any non-obvious side-effects (I/O, global state, config changes).
- If you cannot enumerate everything, list the top-3 unknowns that must be clarified before starting.

---

## 4) High-level approach (concise)
- Short statement of the chosen decomposition (packages/modules) and why (single responsibility, testability, reuse).
- No timelines, no migration steps that read like PM deliverables — this is purely the technical decomposition.

---

## 5) Stepwise refactor phases (technical, verifiable)
For each phase include:
- **Scope**: files/functions touched
- **Goal**: what will be moved/changed (only technical goals)
- **Invariants verified before merging**: the subset of invariants to be verified in this gate
- **Artifacts produced**: mapping table `old_symbol -> new_symbol`, test results, diff artifacts (git patch), LLM audit report (see LLM protocol below)
- **Rollback artifact**: exact git command/file backup to revert if invariants fail

Example phase:
```

Phase 1 — Extract gemini\_service

* Scope: main.py\:GeminiClient.\*, prompts.py\:api\_keys
* Goal: move Gemini calls to services/gemini\_service.py and provide interface class GeminiService
* Invariants to verify: API\_RESPONSE\_SCHEMA, AUTH\_BEHAVIOR, RETRY\_LOGIC
* Artifacts: services/gemini\_service.py, tests/test\_gemini\_service.py, mapping.md (old->new), llm\_audit\_gemini.md
* Rollback: git checkout -- main.py; git revert <commit>

```

---

## 6) Breaking changes & careful handling
- List all **explicit** breaking changes: config keys renamed, public API signatures changed, JSON fields reorganized, changed model names, GUI element name/text changed.
- For each breaking change include:
  - `old` and `new` symbol/field name (verbatim)
  - a migration shim suggestion (non-invasive) or test that proves the shim preserves behavior
  - which invariant would fail if not handled

---

## 7) Verification matrix (tests & checks)
Each refactor merge must include automated verification as follows:
- **Unit tests**: for all extracted services and logic; ensure 100% coverage for moved public functions.
- **API contract tests**: using example inputs in Acceptance Test Corpus; compare responses with `deepdiff` or JSON schema validation.
- **Behavioral regression tests**: run legacy test inputs and assert outputs match within tolerance. For non-deterministic outputs, assert presence/shape rather than exact content.
- **GUI snapshot tests**: capture new GUI states and compare to Golden GUI Snapshots. Report pixel diffs and threshold.
- **End-to-end smoke**: run the app and execute a small set of user journeys (scripts) that exercise the invariants.
- **LLM-assisted audit**: run the LLM audit protocol (below) and attach report.

If any verification fails for a blocking invariant, the change is reverted or blocked.

---

## 8) LLM Audit Protocol (force stepwise comparison — copy/paste prompts)
When you ask an LLM to compare old vs new, follow this forced sequence (do not allow single-step "compare and summary"):

1. **Extraction Step (run on old)**  
   Prompt:  
```

Extract and list verbatim: all top-level GUI element labels, checkbox names, button names, field names, config keys, API endpoints, and JSON response fields from the codebase in the repo/paths provided. Output a JSON array of objects {type, name, source\_file, source\_line, short\_description}.

```
Save result as `old_artifact_list.json`.

2. **Extraction Step (run on new)**  
Same prompt for new code. Save as `new_artifact_list.json`.

3. **Diff Step (automated)**  
Use script to compare `old_artifact_list.json` vs `new_artifact_list.json`. Produce:
- `present_in_old_only.json`
- `present_in_new_only.json`
- `changed_items.json` (old_name -> new_name mapping candidates)
Attach these to the feature doc.

4. **LLM Analysis Step (on the diff)**  
Prompt:
```

Given these diffs (attach present\_in\_old\_only.json, present\_in\_new\_only.json, changed\_items.json), produce:

* A prioritized list of blocking regressions (why blocking)
* Suggested exact tests or assertions (unit/integration/gui) that would prove each regression
* Suggested small shims or adapter code (no code, describe exact API surface/behavior to implement) to preserve compatibility
  Output as: {regression\_id, description, severity, suggested\_assertion, suggested\_shim}

```
Attach response as `llm_audit_report.md`.

5. **Human verification**: a human must review LLM audit and mark each regression as:
- `Confirmed` / `False positive` / `Requires clarification`. Clarifications reopen a step.

> Never accept "code looks perfect" from the LLM unless the above artifacts show no diffs for blocking invariants.

---

## 9) Deliverables (what to commit to the feature branch)
- `docs/features/<N>_REFACTOR.md` (this file)
- `pre_refactor/` folder: Behavioral Invariant List, Acceptance Test Corpus, Golden GUI Snapshots, old file map
- For each phase: mapping.md, unit tests, test results, llm_audit_*.md, git patch artifacts
- `post_refactor/` folder: new file map, test results, GUI snapshots, and `diff` artifacts

---

## 10) Lint/Style & patterns to apply (concise)
- Design patterns to prefer (list): Adapter (for API shims), Facade (for high-level controller), Service Layer (external APIs), Observer/Event Bus (GUI <-> core decoupling).
- Explicit rule: **never** remove a public symbol or config key without either (a) a shim preserving old name or (b) a documented migration path attached to the feature doc.
- Explicit rule: keep files under 300 lines unless justified; but don’t sacrifice clarity for line counts.

---

## 11) If requirements are unclear
- Allow up to 3 clarifying questions (not 5) **only** about behavioral invariants (do not ask about architecture preferences).
- Questions must be short and targeted. After answers, the plan is finalized and changes are applied.

---

## Appendix — Useful scripts/commands (examples to include in the feature doc)
- `python tools/extract_artifacts.py --paths legacy_repo > old_artifact_list.json`
- `python tools/extract_artifacts.py --paths new_repo > new_artifact_list.json`
- `python tools/diff_artifacts.py old_artifact_list.json new_artifact_list.json`
- `pytest tests/ --maxfail=1 --disable-warnings -q`
- `deepdiff old_response.json new_response.json`
- GUI screenshot: `python tools/capture_gui_state.py --target 'main_window' --out golden.png`

---

## Minimal example content for docs/features/0001_REFACTOR.md
(When creating the new feature file, populate sections 1–3 with actual artifact file links and a small sampling of invariants.)
